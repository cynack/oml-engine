/**
 * @license
 * webvr-polyfill
 * Copyright Â© 2018 Cynack
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.OML = factory());
}(this, (function () { 'use strict';

if ( Number.EPSILON === undefined ) {
	Number.EPSILON = Math.pow( 2, - 52 );
}
if ( Number.isInteger === undefined ) {
	Number.isInteger = function ( value ) {
		return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;
	};
}
if ( Math.sign === undefined ) {
	Math.sign = function ( x ) {
		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;
	};
}
if ( 'name' in Function.prototype === false ) {
	Object.defineProperty( Function.prototype, 'name', {
		get: function () {
			return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];
		}
	} );
}
if ( Object.assign === undefined ) {
	( function () {
		Object.assign = function ( target ) {
			if ( target === undefined || target === null ) {
				throw new TypeError( 'Cannot convert undefined or null to object' );
			}
			var output = Object( target );
			for ( var index = 1; index < arguments.length; index ++ ) {
				var source = arguments[ index ];
				if ( source !== undefined && source !== null ) {
					for ( var nextKey in source ) {
						if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {
							output[ nextKey ] = source[ nextKey ];
						}
					}
				}
			}
			return output;
		};
	} )();
}
function EventDispatcher() {}
Object.assign( EventDispatcher.prototype, {
	addEventListener: function ( type, listener ) {
		if ( this._listeners === undefined ) this._listeners = {};
		var listeners = this._listeners;
		if ( listeners[ type ] === undefined ) {
			listeners[ type ] = [];
		}
		if ( listeners[ type ].indexOf( listener ) === - 1 ) {
			listeners[ type ].push( listener );
		}
	},
	hasEventListener: function ( type, listener ) {
		if ( this._listeners === undefined ) return false;
		var listeners = this._listeners;
		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;
	},
	removeEventListener: function ( type, listener ) {
		if ( this._listeners === undefined ) return;
		var listeners = this._listeners;
		var listenerArray = listeners[ type ];
		if ( listenerArray !== undefined ) {
			var index = listenerArray.indexOf( listener );
			if ( index !== - 1 ) {
				listenerArray.splice( index, 1 );
			}
		}
	},
	dispatchEvent: function ( event ) {
		if ( this._listeners === undefined ) return;
		var listeners = this._listeners;
		var listenerArray = listeners[ event.type ];
		if ( listenerArray !== undefined ) {
			event.target = this;
			var array = listenerArray.slice( 0 );
			for ( var i = 0, l = array.length; i < l; i ++ ) {
				array[ i ].call( this, event );
			}
		}
	}
} );
var REVISION = '88';
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var FrontFaceDirectionCW = 0;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var NoColors = 0;
var FaceColors = 1;
var VertexColors = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var Uncharted2ToneMapping = 3;
var CineonToneMapping = 4;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var SphericalReflectionMapping = 305;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1000;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipMapNearestFilter = 1004;
var NearestMipMapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipMapNearestFilter = 1007;
var LinearMipMapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RGB_S3TC_DXT1_Format = 2001;
var RGBA_S3TC_DXT1_Format = 2002;
var RGBA_S3TC_DXT3_Format = 2003;
var RGBA_S3TC_DXT5_Format = 2004;
var RGB_PVRTC_4BPPV1_Format = 2100;
var RGB_PVRTC_2BPPV1_Format = 2101;
var RGBA_PVRTC_4BPPV1_Format = 2102;
var RGBA_PVRTC_2BPPV1_Format = 2103;
var RGB_ETC1_Format = 2151;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3000;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var _Math = {
	DEG2RAD: Math.PI / 180,
	RAD2DEG: 180 / Math.PI,
	generateUUID: function () {
		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
		var rnd = 0, r;
		return function generateUUID() {
			var uuid = '';
			for ( var i = 0; i < 36; i ++ ) {
				if ( i === 8 || i === 13 || i === 18 || i === 23 ) {
					uuid += '-';
				} else if ( i === 14 ) {
					uuid += '4';
				} else {
					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
					r = rnd & 0xf;
					rnd = rnd >> 4;
					uuid += chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];
				}
			}
			return uuid;
		};
	}(),
	clamp: function ( value, min, max ) {
		return Math.max( min, Math.min( max, value ) );
	},
	euclideanModulo: function ( n, m ) {
		return ( ( n % m ) + m ) % m;
	},
	mapLinear: function ( x, a1, a2, b1, b2 ) {
		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );
	},
	lerp: function ( x, y, t ) {
		return ( 1 - t ) * x + t * y;
	},
	smoothstep: function ( x, min, max ) {
		if ( x <= min ) return 0;
		if ( x >= max ) return 1;
		x = ( x - min ) / ( max - min );
		return x * x * ( 3 - 2 * x );
	},
	smootherstep: function ( x, min, max ) {
		if ( x <= min ) return 0;
		if ( x >= max ) return 1;
		x = ( x - min ) / ( max - min );
		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );
	},
	randInt: function ( low, high ) {
		return low + Math.floor( Math.random() * ( high - low + 1 ) );
	},
	randFloat: function ( low, high ) {
		return low + Math.random() * ( high - low );
	},
	randFloatSpread: function ( range ) {
		return range * ( 0.5 - Math.random() );
	},
	degToRad: function ( degrees ) {
		return degrees * _Math.DEG2RAD;
	},
	radToDeg: function ( radians ) {
		return radians * _Math.RAD2DEG;
	},
	isPowerOfTwo: function ( value ) {
		return ( value & ( value - 1 ) ) === 0 && value !== 0;
	},
	ceilPowerOfTwo: function ( value ) {
		return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );
	},
	floorPowerOfTwo: function ( value ) {
		return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );
	}
};
function Vector2( x, y ) {
	this.x = x || 0;
	this.y = y || 0;
}
Object.defineProperties( Vector2.prototype, {
	"width": {
		get: function () {
			return this.x;
		},
		set: function ( value ) {
			this.x = value;
		}
	},
	"height": {
		get: function () {
			return this.y;
		},
		set: function ( value ) {
			this.y = value;
		}
	}
} );
Object.assign( Vector2.prototype, {
	isVector2: true,
	set: function ( x, y ) {
		this.x = x;
		this.y = y;
		return this;
	},
	setScalar: function ( scalar ) {
		this.x = scalar;
		this.y = scalar;
		return this;
	},
	setX: function ( x ) {
		this.x = x;
		return this;
	},
	setY: function ( y ) {
		this.y = y;
		return this;
	},
	setComponent: function ( index, value ) {
		switch ( index ) {
			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );
		}
		return this;
	},
	getComponent: function ( index ) {
		switch ( index ) {
			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );
		}
	},
	clone: function () {
		return new this.constructor( this.x, this.y );
	},
	copy: function ( v ) {
		this.x = v.x;
		this.y = v.y;
		return this;
	},
	add: function ( v, w ) {
		if ( w !== undefined ) {
			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );
		}
		this.x += v.x;
		this.y += v.y;
		return this;
	},
	addScalar: function ( s ) {
		this.x += s;
		this.y += s;
		return this;
	},
	addVectors: function ( a, b ) {
		this.x = a.x + b.x;
		this.y = a.y + b.y;
		return this;
	},
	addScaledVector: function ( v, s ) {
		this.x += v.x * s;
		this.y += v.y * s;
		return this;
	},
	sub: function ( v, w ) {
		if ( w !== undefined ) {
			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );
		}
		this.x -= v.x;
		this.y -= v.y;
		return this;
	},
	subScalar: function ( s ) {
		this.x -= s;
		this.y -= s;
		return this;
	},
	subVectors: function ( a, b ) {
		this.x = a.x - b.x;
		this.y = a.y - b.y;
		return this;
	},
	multiply: function ( v ) {
		this.x *= v.x;
		this.y *= v.y;
		return this;
	},
	multiplyScalar: function ( scalar ) {
		this.x *= scalar;
		this.y *= scalar;
		return this;
	},
	divide: function ( v ) {
		this.x /= v.x;
		this.y /= v.y;
		return this;
	},
	divideScalar: function ( scalar ) {
		return this.multiplyScalar( 1 / scalar );
	},
	applyMatrix3: function ( m ) {
		var x = this.x, y = this.y;
		var e = m.elements;
		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];
		return this;
	},
	min: function ( v ) {
		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		return this;
	},
	max: function ( v ) {
		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		return this;
	},
	clamp: function ( min, max ) {
		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		return this;
	},
	clampScalar: function () {
		var min = new Vector2();
		var max = new Vector2();
		return function clampScalar( minVal, maxVal ) {
			min.set( minVal, minVal );
			max.set( maxVal, maxVal );
			return this.clamp( min, max );
		};
	}(),
	clampLength: function ( min, max ) {
		var length = this.length();
		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
	},
	floor: function () {
		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		return this;
	},
	ceil: function () {
		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		return this;
	},
	round: function () {
		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		return this;
	},
	roundToZero: function () {
		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		return this;
	},
	negate: function () {
		this.x = - this.x;
		this.y = - this.y;
		return this;
	},
	dot: function ( v ) {
		return this.x * v.x + this.y * v.y;
	},
	lengthSq: function () {
		return this.x * this.x + this.y * this.y;
	},
	length: function () {
		return Math.sqrt( this.x * this.x + this.y * this.y );
	},
	manhattanLength: function () {
		return Math.abs( this.x ) + Math.abs( this.y );
	},
	normalize: function () {
		return this.divideScalar( this.length() || 1 );
	},
	angle: function () {
		var angle = Math.atan2( this.y, this.x );
		if ( angle < 0 ) angle += 2 * Math.PI;
		return angle;
	},
	distanceTo: function ( v ) {
		return Math.sqrt( this.distanceToSquared( v ) );
	},
	distanceToSquared: function ( v ) {
		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;
	},
	manhattanDistanceTo: function ( v ) {
		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );
	},
	setLength: function ( length ) {
		return this.normalize().multiplyScalar( length );
	},
	lerp: function ( v, alpha ) {
		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		return this;
	},
	lerpVectors: function ( v1, v2, alpha ) {
		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	},
	equals: function ( v ) {
		return ( ( v.x === this.x ) && ( v.y === this.y ) );
	},
	fromArray: function ( array, offset ) {
		if ( offset === undefined ) offset = 0;
		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		return this;
	},
	toArray: function ( array, offset ) {
		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;
		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		return array;
	},
	fromBufferAttribute: function ( attribute, index, offset ) {
		if ( offset !== undefined ) {
			console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );
		}
		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		return this;
	},
	rotateAround: function ( center, angle ) {
		var c = Math.cos( angle ), s = Math.sin( angle );
		var x = this.x - center.x;
		var y = this.y - center.y;
		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;
		return this;
	}
} );
function Matrix4() {
	this.elements = [
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1
	];
	if ( arguments.length > 0 ) {
		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );
	}
}
Object.assign( Matrix4.prototype, {
	isMatrix4: true,
	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
		var te = this.elements;
		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;
		return this;
	},
	identity: function () {
		this.set(
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1
		);
		return this;
	},
	clone: function () {
		return new Matrix4().fromArray( this.elements );
	},
	copy: function ( m ) {
		var te = this.elements;
		var me = m.elements;
		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];
		return this;
	},
	copyPosition: function ( m ) {
		var te = this.elements, me = m.elements;
		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];
		return this;
	},
	extractBasis: function ( xAxis, yAxis, zAxis ) {
		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );
		return this;
	},
	makeBasis: function ( xAxis, yAxis, zAxis ) {
		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);
		return this;
	},
	extractRotation: function () {
		var v1 = new Vector3();
		return function extractRotation( m ) {
			var te = this.elements;
			var me = m.elements;
			var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
			var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
			var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();
			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;
			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;
			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;
			return this;
		};
	}(),
	makeRotationFromEuler: function ( euler ) {
		if ( ! ( euler && euler.isEuler ) ) {
			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
		}
		var te = this.elements;
		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );
		if ( euler.order === 'XYZ' ) {
			var ae = a * e, af = a * f, be = b * e, bf = b * f;
			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;
			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;
			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;
		} else if ( euler.order === 'YXZ' ) {
			var ce = c * e, cf = c * f, de = d * e, df = d * f;
			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;
			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;
			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;
		} else if ( euler.order === 'ZXY' ) {
			var ce = c * e, cf = c * f, de = d * e, df = d * f;
			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;
			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;
			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;
		} else if ( euler.order === 'ZYX' ) {
			var ae = a * e, af = a * f, be = b * e, bf = b * f;
			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;
			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;
			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;
		} else if ( euler.order === 'YZX' ) {
			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;
			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;
			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;
		} else if ( euler.order === 'XZY' ) {
			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;
			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;
			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;
		}
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;
		return this;
	},
	makeRotationFromQuaternion: function ( q ) {
		var te = this.elements;
		var x = q._x, y = q._y, z = q._z, w = q._w;
		var x2 = x + x, y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;
		te[ 0 ] = 1 - ( yy + zz );
		te[ 4 ] = xy - wz;
		te[ 8 ] = xz + wy;
		te[ 1 ] = xy + wz;
		te[ 5 ] = 1 - ( xx + zz );
		te[ 9 ] = yz - wx;
		te[ 2 ] = xz - wy;
		te[ 6 ] = yz + wx;
		te[ 10 ] = 1 - ( xx + yy );
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;
		return this;
	},
	lookAt: function () {
		var x = new Vector3();
		var y = new Vector3();
		var z = new Vector3();
		return function lookAt( eye, target, up ) {
			var te = this.elements;
			z.subVectors( eye, target );
			if ( z.lengthSq() === 0 ) {
				z.z = 1;
			}
			z.normalize();
			x.crossVectors( up, z );
			if ( x.lengthSq() === 0 ) {
				if ( Math.abs( up.z ) === 1 ) {
					z.x += 0.0001;
				} else {
					z.z += 0.0001;
				}
				z.normalize();
				x.crossVectors( up, z );
			}
			x.normalize();
			y.crossVectors( z, x );
			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;
			return this;
		};
	}(),
	multiply: function ( m, n ) {
		if ( n !== undefined ) {
			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );
		}
		return this.multiplyMatrices( this, m );
	},
	premultiply: function ( m ) {
		return this.multiplyMatrices( m, this );
	},
	multiplyMatrices: function ( a, b ) {
		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;
		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];
		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];
		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
		return this;
	},
	multiplyScalar: function ( s ) {
		var te = this.elements;
		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;
		return this;
	},
	applyToBufferAttribute: function () {
		var v1 = new Vector3();
		return function applyToBufferAttribute( attribute ) {
			for ( var i = 0, l = attribute.count; i < l; i ++ ) {
				v1.x = attribute.getX( i );
				v1.y = attribute.getY( i );
				v1.z = attribute.getZ( i );
				v1.applyMatrix4( this );
				attribute.setXYZ( i, v1.x, v1.y, v1.z );
			}
			return attribute;
		};
	}(),
	determinant: function () {
		var te = this.elements;
		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];
		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)
		);
	},
	transpose: function () {
		var te = this.elements;
		var tmp;
		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;
		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;
		return this;
	},
	setPosition: function ( v ) {
		var te = this.elements;
		te[ 12 ] = v.x;
		te[ 13 ] = v.y;
		te[ 14 ] = v.z;
		return this;
	},
	getInverse: function ( m, throwOnDegenerate ) {
		var te = this.elements,
			me = m.elements,
			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
			n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
			n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
			n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],
			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
		if ( det === 0 ) {
			var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
			if ( throwOnDegenerate === true ) {
				throw new Error( msg );
			} else {
				console.warn( msg );
			}
			return this.identity();
		}
		var detInv = 1 / det;
		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;
		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;
		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;
		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;
		return this;
	},
	scale: function ( v ) {
		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;
		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;
		return this;
	},
	getMaxScaleOnAxis: function () {
		var te = this.elements;
		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];
		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );
	},
	makeTranslation: function ( x, y, z ) {
		this.set(
			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1
		);
		return this;
	},
	makeRotationX: function ( theta ) {
		var c = Math.cos( theta ), s = Math.sin( theta );
		this.set(
			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1
		);
		return this;
	},
	makeRotationY: function ( theta ) {
		var c = Math.cos( theta ), s = Math.sin( theta );
		this.set(
			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1
		);
		return this;
	},
	makeRotationZ: function ( theta ) {
		var c = Math.cos( theta ), s = Math.sin( theta );
		this.set(
			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1
		);
		return this;
	},
	makeRotationAxis: function ( axis, angle ) {
		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;
		this.set(
			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1
		);
		 return this;
	},
	makeScale: function ( x, y, z ) {
		this.set(
			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1
		);
		return this;
	},
	makeShear: function ( x, y, z ) {
		this.set(
			1, y, z, 0,
			x, 1, z, 0,
			x, y, 1, 0,
			0, 0, 0, 1
		);
		return this;
	},
	compose: function ( position, quaternion, scale ) {
		this.makeRotationFromQuaternion( quaternion );
		this.scale( scale );
		this.setPosition( position );
		return this;
	},
	decompose: function () {
		var vector = new Vector3();
		var matrix = new Matrix4();
		return function decompose( position, quaternion, scale ) {
			var te = this.elements;
			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();
			var det = this.determinant();
			if ( det < 0 ) sx = - sx;
			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];
			matrix.copy( this );
			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;
			matrix.elements[ 0 ] *= invSX;
			matrix.elements[ 1 ] *= invSX;
			matrix.elements[ 2 ] *= invSX;
			matrix.elements[ 4 ] *= invSY;
			matrix.elements[ 5 ] *= invSY;
			matrix.elements[ 6 ] *= invSY;
			matrix.elements[ 8 ] *= invSZ;
			matrix.elements[ 9 ] *= invSZ;
			matrix.elements[ 10 ] *= invSZ;
			quaternion.setFromRotationMatrix( matrix );
			scale.x = sx;
			scale.y = sy;
			scale.z = sz;
			return this;
		};
	}(),
	makePerspective: function ( left, right, top, bottom, near, far ) {
		if ( far === undefined ) {
			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );
		}
		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );
		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );
		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;
		return this;
	},
	makeOrthographic: function ( left, right, top, bottom, near, far ) {
		var te = this.elements;
		var w = 1.0 / ( right - left );
		var h = 1.0 / ( top - bottom );
		var p = 1.0 / ( far - near );
		var x = ( right + left ) * w;
		var y = ( top + bottom ) * h;
		var z = ( far + near ) * p;
		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;
		return this;
	},
	equals: function ( matrix ) {
		var te = this.elements;
		var me = matrix.elements;
		for ( var i = 0; i < 16; i ++ ) {
			if ( te[ i ] !== me[ i ] ) return false;
		}
		return true;
	},
	fromArray: function ( array, offset ) {
		if ( offset === undefined ) offset = 0;
		for ( var i = 0; i < 16; i ++ ) {
			this.elements[ i ] = array[ i + offset ];
		}
		return this;
	},
	toArray: function ( array, offset ) {
		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;
		var te = this.elements;
		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];
		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];
		return array;
	}
} );
function Quaternion( x, y, z, w ) {
	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;
}
Object.assign( Quaternion, {
	slerp: function ( qa, qb, qm, t ) {
		return qm.copy( qa ).slerp( qb, t );
	},
	slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {
		var x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ],
			x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];
		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {
			var s = 1 - t,
				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;
			if ( sqrSin > Number.EPSILON ) {
				var sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );
				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;
			}
			var tDir = t * dir;
			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;
			if ( s === 1 - t ) {
				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );
				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;
			}
		}
		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;
	}
} );
Object.defineProperties( Quaternion.prototype, {
	x: {
		get: function () {
			return this._x;
		},
		set: function ( value ) {
			this._x = value;
			this.onChangeCallback();
		}
	},
	y: {
		get: function () {
			return this._y;
		},
		set: function ( value ) {
			this._y = value;
			this.onChangeCallback();
		}
	},
	z: {
		get: function () {
			return this._z;
		},
		set: function ( value ) {
			this._z = value;
			this.onChangeCallback();
		}
	},
	w: {
		get: function () {
			return this._w;
		},
		set: function ( value ) {
			this._w = value;
			this.onChangeCallback();
		}
	}
} );
Object.assign( Quaternion.prototype, {
	set: function ( x, y, z, w ) {
		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;
		this.onChangeCallback();
		return this;
	},
	clone: function () {
		return new this.constructor( this._x, this._y, this._z, this._w );
	},
	copy: function ( quaternion ) {
		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;
		this.onChangeCallback();
		return this;
	},
	setFromEuler: function ( euler, update ) {
		if ( ! ( euler && euler.isEuler ) ) {
			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );
		}
		var x = euler._x, y = euler._y, z = euler._z, order = euler.order;
		var cos = Math.cos;
		var sin = Math.sin;
		var c1 = cos( x / 2 );
		var c2 = cos( y / 2 );
		var c3 = cos( z / 2 );
		var s1 = sin( x / 2 );
		var s2 = sin( y / 2 );
		var s3 = sin( z / 2 );
		if ( order === 'XYZ' ) {
			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;
		} else if ( order === 'YXZ' ) {
			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;
		} else if ( order === 'ZXY' ) {
			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;
		} else if ( order === 'ZYX' ) {
			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;
		} else if ( order === 'YZX' ) {
			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;
		} else if ( order === 'XZY' ) {
			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;
		}
		if ( update !== false ) this.onChangeCallback();
		return this;
	},
	setFromAxisAngle: function ( axis, angle ) {
		var halfAngle = angle / 2, s = Math.sin( halfAngle );
		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );
		this.onChangeCallback();
		return this;
	},
	setFromRotationMatrix: function ( m ) {
		var te = m.elements,
			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],
			trace = m11 + m22 + m33,
			s;
		if ( trace > 0 ) {
			s = 0.5 / Math.sqrt( trace + 1.0 );
			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;
		} else if ( m11 > m22 && m11 > m33 ) {
			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;
		} else if ( m22 > m33 ) {
			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;
		} else {
			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;
		}
		this.onChangeCallback();
		return this;
	},
	setFromUnitVectors: function () {
		var v1 = new Vector3();
		var r;
		var EPS = 0.000001;
		return function setFromUnitVectors( vFrom, vTo ) {
			if ( v1 === undefined ) v1 = new Vector3();
			r = vFrom.dot( vTo ) + 1;
			if ( r < EPS ) {
				r = 0;
				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
					v1.set( - vFrom.y, vFrom.x, 0 );
				} else {
					v1.set( 0, - vFrom.z, vFrom.y );
				}
			} else {
				v1.crossVectors( vFrom, vTo );
			}
			this._x = v1.x;
			this._y = v1.y;
			this._z = v1.z;
			this._w = r;
			return this.normalize();
		};
	}(),
	inverse: function () {
		return this.conjugate().normalize();
	},
	conjugate: function () {
		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;
		this.onChangeCallback();
		return this;
	},
	dot: function ( v ) {
		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
	},
	lengthSq: function () {
		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	},
	length: function () {
		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );
	},
	normalize: function () {
		var l = this.length();
		if ( l === 0 ) {
			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;
		} else {
			l = 1 / l;
			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;
		}
		this.onChangeCallback();
		return this;
	},
	multiply: function ( q, p ) {
		if ( p !== undefined ) {
			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );
		}
		return this.multiplyQuaternions( this, q );
	},
	premultiply: function ( q ) {
		return this.multiplyQuaternions( q, this );
	},
	multiplyQuaternions: function ( a, b ) {
		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
		this.onChangeCallback();
		return this;
	},
	slerp: function ( qb, t ) {
		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );
		var x = this._x, y = this._y, z = this._z, w = this._w;
		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
		if ( cosHalfTheta < 0 ) {
			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;
			cosHalfTheta = - cosHalfTheta;
		} else {
			this.copy( qb );
		}
		if ( cosHalfTheta >= 1.0 ) {
			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;
			return this;
		}
		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );
		if ( Math.abs( sinHalfTheta ) < 0.001 ) {
			this._w = 0.5 * ( w + this._w );
			this._x = 0.5 * ( x + this._x );
			this._y = 0.5 * ( y + this._y );
			this._z = 0.5 * ( z + this._z );
			return this;
		}
		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;
		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );
		this.onChangeCallback();
		return this;
	},
	equals: function ( quaternion ) {
		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );
	},
	fromArray: function ( array, offset ) {
		if ( offset === undefined ) offset = 0;
		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];
		this.onChangeCallback();
		return this;
	},
	toArray: function ( array, offset ) {
		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;
		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;
		return array;
	},
	onChange: function ( callback ) {
		this.onChangeCallback = callback;
		return this;
	},
	onChangeCallback: function () {}
} );
function Vector3( x, y, z ) {
	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
}
Object.assign( Vector3.prototype, {
	isVector3: true,
	set: function ( x, y, z ) {
		this.x = x;
		this.y = y;
		this.z = z;
		return this;
	},
	setScalar: function ( scalar ) {
		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		return this;
	},
	setX: function ( x ) {
		this.x = x;
		return this;
	},
	setY: function ( y ) {
		this.y = y;
		return this;
	},
	setZ: function ( z ) {
		this.z = z;
		return this;
	},
	setComponent: function ( index, value ) {
		switch ( index ) {
			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );
		}
		return this;
	},
	getComponent: function ( index ) {
		switch ( index ) {
			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );
		}
	},
	clone: function () {
		return new this.constructor( this.x, this.y, this.z );
	},
	copy: function ( v ) {
		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		return this;
	},
	add: function ( v, w ) {
		if ( w !== undefined ) {
			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );
		}
		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		return this;
	},
	addScalar: function ( s ) {
		this.x += s;
		this.y += s;
		this.z += s;
		return this;
	},
	addVectors: function ( a, b ) {
		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		return this;
	},
	addScaledVector: function ( v, s ) {
		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		return this;
	},
	sub: function ( v, w ) {
		if ( w !== undefined ) {
			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );
		}
		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		return this;
	},
	subScalar: function ( s ) {
		this.x -= s;
		this.y -= s;
		this.z -= s;
		return this;
	},
	subVectors: function ( a, b ) {
		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		return this;
	},
	multiply: function ( v, w ) {
		if ( w !== undefined ) {
			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );
		}
		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		return this;
	},
	multiplyScalar: function ( scalar ) {
		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		return this;
	},
	multiplyVectors: function ( a, b ) {
		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;
		return this;
	},
	applyEuler: function () {
		var quaternion = new Quaternion();
		return function applyEuler( euler ) {
			if ( ! ( euler && euler.isEuler ) ) {
				console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );
			}
			return this.applyQuaternion( quaternion.setFromEuler( euler ) );
		};
	}(),
	applyAxisAngle: function () {
		var quaternion = new Quaternion();
		return function applyAxisAngle( axis, angle ) {
			return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );
		};
	}(),
	applyMatrix3: function ( m ) {
		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;
		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;
		return this;
	},
	applyMatrix4: function ( m ) {
		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;
		var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );
		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;
		return this;
	},
	applyQuaternion: function ( q ) {
		var x = this.x, y = this.y, z = this.z;
		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
		var ix = qw * x + qy * z - qz * y;
		var iy = qw * y + qz * x - qx * z;
		var iz = qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;
		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;
		return this;
	},
	project: function () {
		var matrix = new Matrix4();
		return function project( camera ) {
			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
			return this.applyMatrix4( matrix );
		};
	}(),
	unproject: function () {
		var matrix = new Matrix4();
		return function unproject( camera ) {
			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
			return this.applyMatrix4( matrix );
		};
	}(),
	transformDirection: function ( m ) {
		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;
		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;
		return this.normalize();
	},
	divide: function ( v ) {
		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;
		return this;
	},
	divideScalar: function ( scalar ) {
		return this.multiplyScalar( 1 / scalar );
	},
	min: function ( v ) {
		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		return this;
	},
	max: function ( v ) {
		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		return this;
	},
	clamp: function ( min, max ) {
		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		return this;
	},
	clampScalar: function () {
		var min = new Vector3();
		var max = new Vector3();
		return function clampScalar( minVal, maxVal ) {
			min.set( minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal );
			return this.clamp( min, max );
		};
	}(),
	clampLength: function ( min, max ) {
		var length = this.length();
		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
	},
	floor: function () {
		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		return this;
	},
	ceil: function () {
		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		return this;
	},
	round: function () {
		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		return this;
	},
	roundToZero: function () {
		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		return this;
	},
	negate: function () {
		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		return this;
	},
	dot: function ( v ) {
		return this.x * v.x + this.y * v.y + this.z * v.z;
	},
	lengthSq: function () {
		return this.x * this.x + this.y * this.y + this.z * this.z;
	},
	length: function () {
		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
	},
	manhattanLength: function () {
		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );
	},
	normalize: function () {
		return this.divideScalar( this.length() || 1 );
	},
	setLength: function ( length ) {
		return this.normalize().multiplyScalar( length );
	},
	lerp: function ( v, alpha ) {
		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		return this;
	},
	lerpVectors: function ( v1, v2, alpha ) {
		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	},
	cross: function ( v, w ) {
		if ( w !== undefined ) {
			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );
		}
		return this.crossVectors( this, v );
	},
	crossVectors: function ( a, b ) {
		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;
		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;
		return this;
	},
	projectOnVector: function ( vector ) {
		var scalar = vector.dot( this ) / vector.lengthSq();
		return this.copy( vector ).multiplyScalar( scalar );
	},
	projectOnPlane: function () {
		var v1 = new Vector3();
		return function projectOnPlane( planeNormal ) {
			v1.copy( this ).projectOnVector( planeNormal );
			return this.sub( v1 );
		};
	}(),
	reflect: function () {
		var v1 = new Vector3();
		return function reflect( normal ) {
			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );
		};
	}(),
	angleTo: function ( v ) {
		var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );
		return Math.acos( _Math.clamp( theta, - 1, 1 ) );
	},
	distanceTo: function ( v ) {
		return Math.sqrt( this.distanceToSquared( v ) );
	},
	distanceToSquared: function ( v ) {
		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
		return dx * dx + dy * dy + dz * dz;
	},
	manhattanDistanceTo: function ( v ) {
		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );
	},
	setFromSpherical: function ( s ) {
		var sinPhiRadius = Math.sin( s.phi ) * s.radius;
		this.x = sinPhiRadius * Math.sin( s.theta );
		this.y = Math.cos( s.phi ) * s.radius;
		this.z = sinPhiRadius * Math.cos( s.theta );
		return this;
	},
	setFromCylindrical: function ( c ) {
		this.x = c.radius * Math.sin( c.theta );
		this.y = c.y;
		this.z = c.radius * Math.cos( c.theta );
		return this;
	},
	setFromMatrixPosition: function ( m ) {
		var e = m.elements;
		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];
		return this;
	},
	setFromMatrixScale: function ( m ) {
		var sx = this.setFromMatrixColumn( m, 0 ).length();
		var sy = this.setFromMatrixColumn( m, 1 ).length();
		var sz = this.setFromMatrixColumn( m, 2 ).length();
		this.x = sx;
		this.y = sy;
		this.z = sz;
		return this;
	},
	setFromMatrixColumn: function ( m, index ) {
		return this.fromArray( m.elements, index * 4 );
	},
	equals: function ( v ) {
		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );
	},
	fromArray: function ( array, offset ) {
		if ( offset === undefined ) offset = 0;
		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		return this;
	},
	toArray: function ( array, offset ) {
		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;
		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		return array;
	},
	fromBufferAttribute: function ( attribute, index, offset ) {
		if ( offset !== undefined ) {
			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );
		}
		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		return this;
	}
} );
function Matrix3() {
	this.elements = [
		1, 0, 0,
		0, 1, 0,
		0, 0, 1
	];
	if ( arguments.length > 0 ) {
		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );
	}
}
Object.assign( Matrix3.prototype, {
	isMatrix3: true,
	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {
		var te = this.elements;
		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;
		return this;
	},
	identity: function () {
		this.set(
			1, 0, 0,
			0, 1, 0,
			0, 0, 1
		);
		return this;
	},
	clone: function () {
		return new this.constructor().fromArray( this.elements );
	},
	copy: function ( m ) {
		var te = this.elements;
		var me = m.elements;
		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];
		return this;
	},
	setFromMatrix4: function ( m ) {
		var me = m.elements;
		this.set(
			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]
		);
		return this;
	},
	applyToBufferAttribute: function () {
		var v1 = new Vector3();
		return function applyToBufferAttribute( attribute ) {
			for ( var i = 0, l = attribute.count; i < l; i ++ ) {
				v1.x = attribute.getX( i );
				v1.y = attribute.getY( i );
				v1.z = attribute.getZ( i );
				v1.applyMatrix3( this );
				attribute.setXYZ( i, v1.x, v1.y, v1.z );
			}
			return attribute;
		};
	}(),
	multiply: function ( m ) {
		return this.multiplyMatrices( this, m );
	},
	premultiply: function ( m ) {
		return this.multiplyMatrices( m, this );
	},
	multiplyMatrices: function ( a, b ) {
		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;
		var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];
		var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];
		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;
		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;
		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;
		return this;
	},
	multiplyScalar: function ( s ) {
		var te = this.elements;
		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;
		return this;
	},
	determinant: function () {
		var te = this.elements;
		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];
		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
	},
	getInverse: function ( matrix, throwOnDegenerate ) {
		if ( matrix && matrix.isMatrix4 ) {
			console.error( "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument." );
		}
		var me = matrix.elements,
			te = this.elements,
			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],
			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,
			det = n11 * t11 + n21 * t12 + n31 * t13;
		if ( det === 0 ) {
			var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
			if ( throwOnDegenerate === true ) {
				throw new Error( msg );
			} else {
				console.warn( msg );
			}
			return this.identity();
		}
		var detInv = 1 / det;
		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;
		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;
		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;
		return this;
	},
	transpose: function () {
		var tmp, m = this.elements;
		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;
		return this;
	},
	getNormalMatrix: function ( matrix4 ) {
		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();
	},
	transposeIntoArray: function ( r ) {
		var m = this.elements;
		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];
		return this;
	},
	setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {
		var c = Math.cos( rotation );
		var s = Math.sin( rotation );
		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);
	},
	scale: function ( sx, sy ) {
		var te = this.elements;
		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;
		return this;
	},
	rotate: function ( theta ) {
		var c = Math.cos( theta );
		var s = Math.sin( theta );
		var te = this.elements;
		var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
		var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];
		te[ 0 ] = c * a11 + s * a21;
		te[ 3 ] = c * a12 + s * a22;
		te[ 6 ] = c * a13 + s * a23;
		te[ 1 ] = - s * a11 + c * a21;
		te[ 4 ] = - s * a12 + c * a22;
		te[ 7 ] = - s * a13 + c * a23;
		return this;
	},
	translate: function ( tx, ty ) {
		var te = this.elements;
		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];
		return this;
	},
	equals: function ( matrix ) {
		var te = this.elements;
		var me = matrix.elements;
		for ( var i = 0; i < 9; i ++ ) {
			if ( te[ i ] !== me[ i ] ) return false;
		}
		return true;
	},
	fromArray: function ( array, offset ) {
		if ( offset === undefined ) offset = 0;
		for ( var i = 0; i < 9; i ++ ) {
			this.elements[ i ] = array[ i + offset ];
		}
		return this;
	},
	toArray: function ( array, offset ) {
		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;
		var te = this.elements;
		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];
		return array;
	}
} );
var textureId = 0;
function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {
	Object.defineProperty( this, 'id', { value: textureId ++ } );
	this.uuid = _Math.generateUUID();
	this.name = '';
	this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
	this.mipmaps = [];
	this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
	this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
	this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;
	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
	this.format = format !== undefined ? format : RGBAFormat;
	this.type = type !== undefined ? type : UnsignedByteType;
	this.offset = new Vector2( 0, 0 );
	this.repeat = new Vector2( 1, 1 );
	this.center = new Vector2( 0, 0 );
	this.rotation = 0;
	this.matrixAutoUpdate = true;
	this.matrix = new Matrix3();
	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4;
	this.encoding = encoding !== undefined ? encoding : LinearEncoding;
	this.version = 0;
	this.onUpdate = null;
}
Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;
Object.defineProperty( Texture.prototype, "needsUpdate", {
	set: function ( value ) {
		if ( value === true ) this.version ++;
	}
} );
Object.assign( Texture.prototype, EventDispatcher.prototype, {
	constructor: Texture,
	isTexture: true,
	clone: function () {
		return new this.constructor().copy( this );
	},
	copy: function ( source ) {
		this.name = source.name;
		this.image = source.image;
		this.mipmaps = source.mipmaps.slice( 0 );
		this.mapping = source.mapping;
		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;
		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;
		this.anisotropy = source.anisotropy;
		this.format = source.format;
		this.type = source.type;
		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );
		this.center.copy( source.center );
		this.rotation = source.rotation;
		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy( source.matrix );
		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;
		return this;
	},
	toJSON: function ( meta ) {
		var isRootObject = ( meta === undefined || typeof meta === 'string' );
		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {
			return meta.textures[ this.uuid ];
		}
		function getDataURL( image ) {
			var canvas;
			if ( image instanceof HTMLCanvasElement ) {
				canvas = image;
			} else {
				canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = image.width;
				canvas.height = image.height;
				var context = canvas.getContext( '2d' );
				if ( image instanceof ImageData ) {
					context.putImageData( image, 0, 0 );
				} else {
					context.drawImage( image, 0, 0, image.width, image.height );
				}
			}
			if ( canvas.width > 2048 || canvas.height > 2048 ) {
				return canvas.toDataURL( 'image/jpeg', 0.6 );
			} else {
				return canvas.toDataURL( 'image/png' );
			}
		}
		var output = {
			metadata: {
				version: 4.5,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},
			uuid: this.uuid,
			name: this.name,
			mapping: this.mapping,
			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			center: [ this.center.x, this.center.y ],
			rotation: this.rotation,
			wrap: [ this.wrapS, this.wrapT ],
			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,
			flipY: this.flipY
		};
		if ( this.image !== undefined ) {
			var image = this.image;
			if ( image.uuid === undefined ) {
				image.uuid = _Math.generateUUID();
			}
			if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {
				meta.images[ image.uuid ] = {
					uuid: image.uuid,
					url: getDataURL( image )
				};
			}
			output.image = image.uuid;
		}
		if ( ! isRootObject ) {
			meta.textures[ this.uuid ] = output;
		}
		return output;
	},
	dispose: function () {
		this.dispatchEvent( { type: 'dispose' } );
	},
	transformUv: function ( uv ) {
		if ( this.mapping !== UVMapping ) return;
		uv.applyMatrix3( this.matrix );
		if ( uv.x < 0 || uv.x > 1 ) {
			switch ( this.wrapS ) {
				case RepeatWrapping:
					uv.x = uv.x - Math.floor( uv.x );
					break;
				case ClampToEdgeWrapping:
					uv.x = uv.x < 0 ? 0 : 1;
					break;
				case MirroredRepeatWrapping:
					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {
						uv.x = Math.ceil( uv.x ) - uv.x;
					} else {
						uv.x = uv.x - Math.floor( uv.x );
					}
					break;
			}
		}
		if ( uv.y < 0 || uv.y > 1 ) {
			switch ( this.wrapT ) {
				case RepeatWrapping:
					uv.y = uv.y - Math.floor( uv.y );
					break;
				case ClampToEdgeWrapping:
					uv.y = uv.y < 0 ? 0 : 1;
					break;
				case MirroredRepeatWrapping:
					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {
						uv.y = Math.ceil( uv.y ) - uv.y;
					} else {
						uv.y = uv.y - Math.floor( uv.y );
					}
					break;
			}
		}
		if ( this.flipY ) {
			uv.y = 1 - uv.y;
		}
	}
} );
function Vector4( x, y, z, w ) {
	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;
}
Object.assign( Vector4.prototype, {
	isVector4: true,
	set: function ( x, y, z, w ) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
		return this;
	},
	setScalar: function ( scalar ) {
		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;
		return this;
	},
	setX: function ( x ) {
		this.x = x;
		return this;
	},
	setY: function ( y ) {
		this.y = y;
		return this;
	},
	setZ: function ( z ) {
		this.z = z;
		return this;
	},
	setW: function ( w ) {
		this.w = w;
		return this;
	},
	setComponent: function ( index, value ) {
		switch ( index ) {
			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );
		}
		return this;
	},
	getComponent: function ( index ) {
		switch ( index ) {
			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );
		}
	},
	clone: function () {
		return new this.constructor( this.x, this.y, this.z, this.w );
	},
	copy: function ( v ) {
		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;
		return this;
	},
	add: function ( v, w ) {
		if ( w !== undefined ) {
			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );
		}
		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;
		return this;
	},
	addScalar: function ( s ) {
		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;
		return this;
	},
	addVectors: function ( a, b ) {
		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;
		return this;
	},
	addScaledVector: function ( v, s ) {
		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;
		return this;
	},
	sub: function ( v, w ) {
		if ( w !== undefined ) {
			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );
		}
		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;
		return this;
	},
	subScalar: function ( s ) {
		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;
		return this;
	},
	subVectors: function ( a, b ) {
		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;
		return this;
	},
	multiplyScalar: function ( scalar ) {
		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;
		return this;
	},
	applyMatrix4: function ( m ) {
		var x = this.x, y = this.y, z = this.z, w = this.w;
		var e = m.elements;
		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;
		return this;
	},
	divideScalar: function ( scalar ) {
		return this.multiplyScalar( 1 / scalar );
	},
	setAxisAngleFromQuaternion: function ( q ) {
		this.w = 2 * Math.acos( q.w );
		var s = Math.sqrt( 1 - q.w * q.w );
		if ( s < 0.0001 ) {
			this.x = 1;
			this.y = 0;
			this.z = 0;
		} else {
			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;
		}
		return this;
	},
	setAxisAngleFromRotationMatrix: function ( m ) {
		var angle, x, y, z,
			epsilon = 0.01,
			epsilon2 = 0.1,
			te = m.elements,
			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {
			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {
				this.set( 1, 0, 0, 0 );
				return this;
			}
			angle = Math.PI;
			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;
			if ( ( xx > yy ) && ( xx > zz ) ) {
				if ( xx < epsilon ) {
					x = 0;
					y = 0.707106781;
					z = 0.707106781;
				} else {
					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;
				}
			} else if ( yy > zz ) {
				if ( yy < epsilon ) {
					x = 0.707106781;
					y = 0;
					z = 0.707106781;
				} else {
					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;
				}
			} else {
				if ( zz < epsilon ) {
					x = 0.707106781;
					y = 0.707106781;
					z = 0;
				} else {
					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;
				}
			}
			this.set( x, y, z, angle );
			return this;
		}
		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
		                   ( m13 - m31 ) * ( m13 - m31 ) +
		                   ( m21 - m12 ) * ( m21 - m12 ) );
		if ( Math.abs( s ) < 0.001 ) s = 1;
		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );
		return this;
	},
	min: function ( v ) {
		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );
		return this;
	},
	max: function ( v ) {
		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );
		return this;
	},
	clamp: function ( min, max ) {
		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );
		return this;
	},
	clampScalar: function () {
		var min, max;
		return function clampScalar( minVal, maxVal ) {
			if ( min === undefined ) {
				min = new Vector4();
				max = new Vector4();
			}
			min.set( minVal, minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal, maxVal );
			return this.clamp( min, max );
		};
	}(),
	clampLength: function ( min, max ) {
		var length = this.length();
		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
	},
	floor: function () {
		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );
		return this;
	},
	ceil: function () {
		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );
		return this;
	},
	round: function () {
		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );
		return this;
	},
	roundToZero: function () {
		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );
		return this;
	},
	negate: function () {
		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;
		return this;
	},
	dot: function ( v ) {
		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	},
	lengthSq: function () {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	},
	length: function () {
		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );
	},
	manhattanLength: function () {
		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );
	},
	normalize: function () {
		return this.divideScalar( this.length() || 1 );
	},
	setLength: function ( length ) {
		return this.normalize().multiplyScalar( length );
	},
	lerp: function ( v, alpha ) {
		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;
		return this;
	},
	lerpVectors: function ( v1, v2, alpha ) {
		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	},
	equals: function ( v ) {
		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );
	},
	fromArray: function ( array, offset ) {
		if ( offset === undefined ) offset = 0;
		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];
		return this;
	},
	toArray: function ( array, offset ) {
		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;
		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;
		return array;
	},
	fromBufferAttribute: function ( attribute, index, offset ) {
		if ( offset !== undefined ) {
			console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );
		}
		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );
		return this;
	}
} );
function WebGLRenderTarget( width, height, options ) {
	this.uuid = _Math.generateUUID();
	this.width = width;
	this.height = height;
	this.scissor = new Vector4( 0, 0, width, height );
	this.scissorTest = false;
	this.viewport = new Vector4( 0, 0, width, height );
	options = options || {};
	if ( options.minFilter === undefined ) options.minFilter = LinearFilter;
	this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );
	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
	this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
}
Object.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {
	isWebGLRenderTarget: true,
	setSize: function ( width, height ) {
		if ( this.width !== width || this.height !== height ) {
			this.width = width;
			this.height = height;
			this.dispose();
		}
		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );
	},
	clone: function () {
		return new this.constructor().copy( this );
	},
	copy: function ( source ) {
		this.width = source.width;
		this.height = source.height;
		this.viewport.copy( source.viewport );
		this.texture = source.texture.clone();
		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		this.depthTexture = source.depthTexture;
		return this;
	},
	dispose: function () {
		this.dispatchEvent( { type: 'dispose' } );
	}
} );
function WebGLRenderTargetCube( width, height, options ) {
	WebGLRenderTarget.call( this, width, height, options );
	this.activeCubeFace = 0;
	this.activeMipMapLevel = 0;
}
WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;
WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;
function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {
	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	this.image = { data: data, width: width, height: height };
	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
	this.generateMipmaps = false;
	this.flipY = false;
	this.unpackAlignment = 1;
}
DataTexture.prototype = Object.create( Texture.prototype );
DataTexture.prototype.constructor = DataTexture;
DataTexture.prototype.isDataTexture = true;
function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {
	images = images !== undefined ? images : [];
	mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
	Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	this.flipY = false;
}
CubeTexture.prototype = Object.create( Texture.prototype );
CubeTexture.prototype.constructor = CubeTexture;
CubeTexture.prototype.isCubeTexture = true;
Object.defineProperty( CubeTexture.prototype, 'images', {
	get: function () {
		return this.image;
	},
	set: function ( value ) {
		this.image = value;
	}
} );
var emptyTexture = new Texture();
var emptyCubeTexture = new CubeTexture();
function UniformContainer() {
	this.seq = [];
	this.map = {};
}
var arrayCacheF32 = [];
var arrayCacheI32 = [];
var mat4array = new Float32Array( 16 );
var mat3array = new Float32Array( 9 );
function flatten( array, nBlocks, blockSize ) {
	var firstElem = array[ 0 ];
	if ( firstElem <= 0 || firstElem > 0 ) return array;
	var n = nBlocks * blockSize,
		r = arrayCacheF32[ n ];
	if ( r === undefined ) {
		r = new Float32Array( n );
		arrayCacheF32[ n ] = r;
	}
	if ( nBlocks !== 0 ) {
		firstElem.toArray( r, 0 );
		for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {
			offset += blockSize;
			array[ i ].toArray( r, offset );
		}
	}
	return r;
}
function allocTexUnits( renderer, n ) {
	var r = arrayCacheI32[ n ];
	if ( r === undefined ) {
		r = new Int32Array( n );
		arrayCacheI32[ n ] = r;
	}
	for ( var i = 0; i !== n; ++ i )
		r[ i ] = renderer.allocTextureUnit();
	return r;
}
function setValue1f( gl, v ) {
	gl.uniform1f( this.addr, v );
}
function setValue1i( gl, v ) {
	gl.uniform1i( this.addr, v );
}
function setValue2fv( gl, v ) {
	if ( v.x === undefined ) {
		gl.uniform2fv( this.addr, v );
	} else {
		gl.uniform2f( this.addr, v.x, v.y );
	}
}
function setValue3fv( gl, v ) {
	if ( v.x !== undefined ) {
		gl.uniform3f( this.addr, v.x, v.y, v.z );
	} else if ( v.r !== undefined ) {
		gl.uniform3f( this.addr, v.r, v.g, v.b );
	} else {
		gl.uniform3fv( this.addr, v );
	}
}
function setValue4fv( gl, v ) {
	if ( v.x === undefined ) {
		gl.uniform4fv( this.addr, v );
	} else {
		 gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );
	}
}
function setValue2fm( gl, v ) {
	gl.uniformMatrix2fv( this.addr, false, v.elements || v );
}
function setValue3fm( gl, v ) {
	if ( v.elements === undefined ) {
		gl.uniformMatrix3fv( this.addr, false, v );
	} else {
		mat3array.set( v.elements );
		gl.uniformMatrix3fv( this.addr, false, mat3array );
	}
}
function setValue4fm( gl, v ) {
	if ( v.elements === undefined ) {
		gl.uniformMatrix4fv( this.addr, false, v );
	} else {
		mat4array.set( v.elements );
		gl.uniformMatrix4fv( this.addr, false, mat4array );
	}
}
function setValueT1( gl, v, renderer ) {
	var unit = renderer.allocTextureUnit();
	gl.uniform1i( this.addr, unit );
	renderer.setTexture2D( v || emptyTexture, unit );
}
function setValueT6( gl, v, renderer ) {
	var unit = renderer.allocTextureUnit();
	gl.uniform1i( this.addr, unit );
	renderer.setTextureCube( v || emptyCubeTexture, unit );
}
function setValue2iv( gl, v ) {
	gl.uniform2iv( this.addr, v );
}
function setValue3iv( gl, v ) {
	gl.uniform3iv( this.addr, v );
}
function setValue4iv( gl, v ) {
	gl.uniform4iv( this.addr, v );
}
function getSingularSetter( type ) {
	switch ( type ) {
		case 0x1406: return setValue1f;
		case 0x8b50: return setValue2fv;
		case 0x8b51: return setValue3fv;
		case 0x8b52: return setValue4fv;
		case 0x8b5a: return setValue2fm;
		case 0x8b5b: return setValue3fm;
		case 0x8b5c: return setValue4fm;
		case 0x8b5e: case 0x8d66: return setValueT1;
		case 0x8b60: return setValueT6;
		case 0x1404: case 0x8b56: return setValue1i;
		case 0x8b53: case 0x8b57: return setValue2iv;
		case 0x8b54: case 0x8b58: return setValue3iv;
		case 0x8b55: case 0x8b59: return setValue4iv;
	}
}
function setValue1fv( gl, v ) {
	gl.uniform1fv( this.addr, v );
}
function setValue1iv( gl, v ) {
	gl.uniform1iv( this.addr, v );
}
function setValueV2a( gl, v ) {
	gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );
}
function setValueV3a( gl, v ) {
	gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );
}
function setValueV4a( gl, v ) {
	gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );
}
function setValueM2a( gl, v ) {
	gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );
}
function setValueM3a( gl, v ) {
	gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );
}
function setValueM4a( gl, v ) {
	gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );
}
function setValueT1a( gl, v, renderer ) {
	var n = v.length,
		units = allocTexUnits( renderer, n );
	gl.uniform1iv( this.addr, units );
	for ( var i = 0; i !== n; ++ i ) {
		renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );
	}
}
function setValueT6a( gl, v, renderer ) {
	var n = v.length,
		units = allocTexUnits( renderer, n );
	gl.uniform1iv( this.addr, units );
	for ( var i = 0; i !== n; ++ i ) {
		renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );
	}
}
function getPureArraySetter( type ) {
	switch ( type ) {
		case 0x1406: return setValue1fv;
		case 0x8b50: return setValueV2a;
		case 0x8b51: return setValueV3a;
		case 0x8b52: return setValueV4a;
		case 0x8b5a: return setValueM2a;
		case 0x8b5b: return setValueM3a;
		case 0x8b5c: return setValueM4a;
		case 0x8b5e: return setValueT1a;
		case 0x8b60: return setValueT6a;
		case 0x1404: case 0x8b56: return setValue1iv;
		case 0x8b53: case 0x8b57: return setValue2iv;
		case 0x8b54: case 0x8b58: return setValue3iv;
		case 0x8b55: case 0x8b59: return setValue4iv;
	}
}
function SingleUniform( id, activeInfo, addr ) {
	this.id = id;
	this.addr = addr;
	this.setValue = getSingularSetter( activeInfo.type );
}
function PureArrayUniform( id, activeInfo, addr ) {
	this.id = id;
	this.addr = addr;
	this.size = activeInfo.size;
	this.setValue = getPureArraySetter( activeInfo.type );
}
function StructuredUniform( id ) {
	this.id = id;
	UniformContainer.call( this );
}
StructuredUniform.prototype.setValue = function ( gl, value ) {
	var seq = this.seq;
	for ( var i = 0, n = seq.length; i !== n; ++ i ) {
		var u = seq[ i ];
		u.setValue( gl, value[ u.id ] );
	}
};
var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
function addUniform( container, uniformObject ) {
	container.seq.push( uniformObject );
	container.map[ uniformObject.id ] = uniformObject;
}
function parseUniform( activeInfo, addr, container ) {
	var path = activeInfo.name,
		pathLength = path.length;
	RePathPart.lastIndex = 0;
	for ( ; ; ) {
		var match = RePathPart.exec( path ),
			matchEnd = RePathPart.lastIndex,
			id = match[ 1 ],
			idIsIndex = match[ 2 ] === ']',
			subscript = match[ 3 ];
		if ( idIsIndex ) id = id | 0;
		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {
			addUniform( container, subscript === undefined ?
				new SingleUniform( id, activeInfo, addr ) :
				new PureArrayUniform( id, activeInfo, addr ) );
			break;
		} else {
			var map = container.map, next = map[ id ];
			if ( next === undefined ) {
				next = new StructuredUniform( id );
				addUniform( container, next );
			}
			container = next;
		}
	}
}
function WebGLUniforms( gl, program, renderer ) {
	UniformContainer.call( this );
	this.renderer = renderer;
	var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );
	for ( var i = 0; i < n; ++ i ) {
		var info = gl.getActiveUniform( program, i ),
			path = info.name,
			addr = gl.getUniformLocation( program, path );
		parseUniform( info, addr, this );
	}
}
WebGLUniforms.prototype.setValue = function ( gl, name, value ) {
	var u = this.map[ name ];
	if ( u !== undefined ) u.setValue( gl, value, this.renderer );
};
WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {
	var v = object[ name ];
	if ( v !== undefined ) this.setValue( gl, name, v );
};
WebGLUniforms.upload = function ( gl, seq, values, renderer ) {
	for ( var i = 0, n = seq.length; i !== n; ++ i ) {
		var u = seq[ i ],
			v = values[ u.id ];
		if ( v.needsUpdate !== false ) {
			u.setValue( gl, v.value, renderer );
		}
	}
};
WebGLUniforms.seqWithValue = function ( seq, values ) {
	var r = [];
	for ( var i = 0, n = seq.length; i !== n; ++ i ) {
		var u = seq[ i ];
		if ( u.id in values ) r.push( u );
	}
	return r;
};
var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };
function Color( r, g, b ) {
	if ( g === undefined && b === undefined ) {
		return this.set( r );
	}
	return this.setRGB( r, g, b );
}
Object.assign( Color.prototype, {
	isColor: true,
	r: 1, g: 1, b: 1,
	set: function ( value ) {
		if ( value && value.isColor ) {
			this.copy( value );
		} else if ( typeof value === 'number' ) {
			this.setHex( value );
		} else if ( typeof value === 'string' ) {
			this.setStyle( value );
		}
		return this;
	},
	setScalar: function ( scalar ) {
		this.r = scalar;
		this.g = scalar;
		this.b = scalar;
		return this;
	},
	setHex: function ( hex ) {
		hex = Math.floor( hex );
		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;
		return this;
	},
	setRGB: function ( r, g, b ) {
		this.r = r;
		this.g = g;
		this.b = b;
		return this;
	},
	setHSL: function () {
		function hue2rgb( p, q, t ) {
			if ( t < 0 ) t += 1;
			if ( t > 1 ) t -= 1;
			if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
			if ( t < 1 / 2 ) return q;
			if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
			return p;
		}
		return function setHSL( h, s, l ) {
			h = _Math.euclideanModulo( h, 1 );
			s = _Math.clamp( s, 0, 1 );
			l = _Math.clamp( l, 0, 1 );
			if ( s === 0 ) {
				this.r = this.g = this.b = l;
			} else {
				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				var q = ( 2 * l ) - p;
				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );
			}
			return this;
		};
	}(),
	setStyle: function ( style ) {
		function handleAlpha( string ) {
			if ( string === undefined ) return;
			if ( parseFloat( string ) < 1 ) {
				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );
			}
		}
		var m;
		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {
			var color;
			var name = m[ 1 ];
			var components = m[ 2 ];
			switch ( name ) {
				case 'rgb':
				case 'rgba':
					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
						handleAlpha( color[ 5 ] );
						return this;
					}
					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
						handleAlpha( color[ 5 ] );
						return this;
					}
					break;
				case 'hsl':
				case 'hsla':
					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
						var h = parseFloat( color[ 1 ] ) / 360;
						var s = parseInt( color[ 2 ], 10 ) / 100;
						var l = parseInt( color[ 3 ], 10 ) / 100;
						handleAlpha( color[ 5 ] );
						return this.setHSL( h, s, l );
					}
					break;
			}
		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {
			var hex = m[ 1 ];
			var size = hex.length;
			if ( size === 3 ) {
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;
				return this;
			} else if ( size === 6 ) {
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;
				return this;
			}
		}
		if ( style && style.length > 0 ) {
			var hex = ColorKeywords[ style ];
			if ( hex !== undefined ) {
				this.setHex( hex );
			} else {
				console.warn( 'THREE.Color: Unknown color ' + style );
			}
		}
		return this;
	},
	clone: function () {
		return new this.constructor( this.r, this.g, this.b );
	},
	copy: function ( color ) {
		this.r = color.r;
		this.g = color.g;
		this.b = color.b;
		return this;
	},
	copyGammaToLinear: function ( color, gammaFactor ) {
		if ( gammaFactor === undefined ) gammaFactor = 2.0;
		this.r = Math.pow( color.r, gammaFactor );
		this.g = Math.pow( color.g, gammaFactor );
		this.b = Math.pow( color.b, gammaFactor );
		return this;
	},
	copyLinearToGamma: function ( color, gammaFactor ) {
		if ( gammaFactor === undefined ) gammaFactor = 2.0;
		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;
		this.r = Math.pow( color.r, safeInverse );
		this.g = Math.pow( color.g, safeInverse );
		this.b = Math.pow( color.b, safeInverse );
		return this;
	},
	convertGammaToLinear: function () {
		var r = this.r, g = this.g, b = this.b;
		this.r = r * r;
		this.g = g * g;
		this.b = b * b;
		return this;
	},
	convertLinearToGamma: function () {
		this.r = Math.sqrt( this.r );
		this.g = Math.sqrt( this.g );
		this.b = Math.sqrt( this.b );
		return this;
	},
	getHex: function () {
		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;
	},
	getHexString: function () {
		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );
	},
	getHSL: function ( optionalTarget ) {
		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };
		var r = this.r, g = this.g, b = this.b;
		var max = Math.max( r, g, b );
		var min = Math.min( r, g, b );
		var hue, saturation;
		var lightness = ( min + max ) / 2.0;
		if ( min === max ) {
			hue = 0;
			saturation = 0;
		} else {
			var delta = max - min;
			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );
			switch ( max ) {
				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;
			}
			hue /= 6;
		}
		hsl.h = hue;
		hsl.s = saturation;
		hsl.l = lightness;
		return hsl;
	},
	getStyle: function () {
		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';
	},
	offsetHSL: function ( h, s, l ) {
		var hsl = this.getHSL();
		hsl.h += h; hsl.s += s; hsl.l += l;
		this.setHSL( hsl.h, hsl.s, hsl.l );
		return this;
	},
	add: function ( color ) {
		this.r += color.r;
		this.g += color.g;
		this.b += color.b;
		return this;
	},
	addColors: function ( color1, color2 ) {
		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;
		return this;
	},
	addScalar: function ( s ) {
		this.r += s;
		this.g += s;
		this.b += s;
		return this;
	},
	sub: function ( color ) {
		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );
		return this;
	},
	multiply: function ( color ) {
		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;
		return this;
	},
	multiplyScalar: function ( s ) {
		this.r *= s;
		this.g *= s;
		this.b *= s;
		return this;
	},
	lerp: function ( color, alpha ) {
		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;
		return this;
	},
	equals: function ( c ) {
		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );
	},
	fromArray: function ( array, offset ) {
		if ( offset === undefined ) offset = 0;
		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];
		return this;
	},
	toArray: function ( array, offset ) {
		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;
		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;
		return array;
	},
	toJSON: function () {
		return this.getHex();
	}
} );
var UniformsLib = {
	common: {
		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },
		map: { value: null },
		uvTransform: { value: new Matrix3() },
		alphaMap: { value: null },
	},
	specularmap: {
		specularMap: { value: null },
	},
	envmap: {
		envMap: { value: null },
		flipEnvMap: { value: - 1 },
		reflectivity: { value: 1.0 },
		refractionRatio: { value: 0.98 }
	},
	aomap: {
		aoMap: { value: null },
		aoMapIntensity: { value: 1 }
	},
	lightmap: {
		lightMap: { value: null },
		lightMapIntensity: { value: 1 }
	},
	emissivemap: {
		emissiveMap: { value: null }
	},
	bumpmap: {
		bumpMap: { value: null },
		bumpScale: { value: 1 }
	},
	normalmap: {
		normalMap: { value: null },
		normalScale: { value: new Vector2( 1, 1 ) }
	},
	displacementmap: {
		displacementMap: { value: null },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }
	},
	roughnessmap: {
		roughnessMap: { value: null }
	},
	metalnessmap: {
		metalnessMap: { value: null }
	},
	gradientmap: {
		gradientMap: { value: null }
	},
	fog: {
		fogDensity: { value: 0.00025 },
		fogNear: { value: 1 },
		fogFar: { value: 2000 },
		fogColor: { value: new Color( 0xffffff ) }
	},
	lights: {
		ambientLightColor: { value: [] },
		directionalLights: { value: [], properties: {
			direction: {},
			color: {},
			shadow: {},
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },
		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },
		spotLights: { value: [], properties: {
			color: {},
			position: {},
			direction: {},
			distance: {},
			coneCos: {},
			penumbraCos: {},
			decay: {},
			shadow: {},
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },
		spotShadowMap: { value: [] },
		spotShadowMatrix: { value: [] },
		pointLights: { value: [], properties: {
			color: {},
			position: {},
			decay: {},
			distance: {},
			shadow: {},
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {},
			shadowCameraNear: {},
			shadowCameraFar: {}
		} },
		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },
		hemisphereLights: { value: [], properties: {
			direction: {},
			skyColor: {},
			groundColor: {}
		} },
		rectAreaLights: { value: [], properties: {
			color: {},
			position: {},
			width: {},
			height: {}
		} }
	},
	points: {
		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },
		size: { value: 1.0 },
		scale: { value: 1.0 },
		map: { value: null },
		uvTransform: { value: new Matrix3() }
	}
};
var UniformsUtils = {
	merge: function ( uniforms ) {
		var merged = {};
		for ( var u = 0; u < uniforms.length; u ++ ) {
			var tmp = this.clone( uniforms[ u ] );
			for ( var p in tmp ) {
				merged[ p ] = tmp[ p ];
			}
		}
		return merged;
	},
	clone: function ( uniforms_src ) {
		var uniforms_dst = {};
		for ( var u in uniforms_src ) {
			uniforms_dst[ u ] = {};
			for ( var p in uniforms_src[ u ] ) {
				var parameter_src = uniforms_src[ u ][ p ];
				if ( parameter_src && ( parameter_src.isColor ||
					parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
					parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
					parameter_src.isTexture ) ) {
					uniforms_dst[ u ][ p ] = parameter_src.clone();
				} else if ( Array.isArray( parameter_src ) ) {
					uniforms_dst[ u ][ p ] = parameter_src.slice();
				} else {
					uniforms_dst[ u ][ p ] = parameter_src;
				}
			}
		}
		return uniforms_dst;
	}
};
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";
var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";
var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
var begin_vertex = "\nvec3 transformed = vec3( position );\n";
var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";
var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";
var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";
var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";
var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";
var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";
var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";
var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";
var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";
var fog_vertex = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";
var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";
var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";
var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";
var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";
var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n";
var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";
var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";
var map_particle_fragment = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";
var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";
var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";
var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n";
var dithering_fragment = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";
var dithering_pars_fragment = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";
var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";
var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";
var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n";
var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";
var tonemapping_pars_fragment = "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";
var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";
var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n";
var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n";
var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";
var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n";
var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";
var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";
var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n";
var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n";
var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";
var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";
var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";
var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";
var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";
var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";
var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";
var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";
var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";
var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n";
var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
var ShaderChunk = {
	alphamap_fragment: alphamap_fragment,
	alphamap_pars_fragment: alphamap_pars_fragment,
	alphatest_fragment: alphatest_fragment,
	aomap_fragment: aomap_fragment,
	aomap_pars_fragment: aomap_pars_fragment,
	begin_vertex: begin_vertex,
	beginnormal_vertex: beginnormal_vertex,
	bsdfs: bsdfs,
	bumpmap_pars_fragment: bumpmap_pars_fragment,
	clipping_planes_fragment: clipping_planes_fragment,
	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	clipping_planes_vertex: clipping_planes_vertex,
	color_fragment: color_fragment,
	color_pars_fragment: color_pars_fragment,
	color_pars_vertex: color_pars_vertex,
	color_vertex: color_vertex,
	common: common,
	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	defaultnormal_vertex: defaultnormal_vertex,
	displacementmap_pars_vertex: displacementmap_pars_vertex,
	displacementmap_vertex: displacementmap_vertex,
	emissivemap_fragment: emissivemap_fragment,
	emissivemap_pars_fragment: emissivemap_pars_fragment,
	encodings_fragment: encodings_fragment,
	encodings_pars_fragment: encodings_pars_fragment,
	envmap_fragment: envmap_fragment,
	envmap_pars_fragment: envmap_pars_fragment,
	envmap_pars_vertex: envmap_pars_vertex,
	envmap_vertex: envmap_vertex,
	fog_vertex: fog_vertex,
	fog_pars_vertex: fog_pars_vertex,
	fog_fragment: fog_fragment,
	fog_pars_fragment: fog_pars_fragment,
	gradientmap_pars_fragment: gradientmap_pars_fragment,
	lightmap_fragment: lightmap_fragment,
	lightmap_pars_fragment: lightmap_pars_fragment,
	lights_lambert_vertex: lights_lambert_vertex,
	lights_pars: lights_pars,
	lights_phong_fragment: lights_phong_fragment,
	lights_phong_pars_fragment: lights_phong_pars_fragment,
	lights_physical_fragment: lights_physical_fragment,
	lights_physical_pars_fragment: lights_physical_pars_fragment,
	lights_template: lights_template,
	logdepthbuf_fragment: logdepthbuf_fragment,
	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	logdepthbuf_vertex: logdepthbuf_vertex,
	map_fragment: map_fragment,
	map_pars_fragment: map_pars_fragment,
	map_particle_fragment: map_particle_fragment,
	map_particle_pars_fragment: map_particle_pars_fragment,
	metalnessmap_fragment: metalnessmap_fragment,
	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	morphnormal_vertex: morphnormal_vertex,
	morphtarget_pars_vertex: morphtarget_pars_vertex,
	morphtarget_vertex: morphtarget_vertex,
	normal_fragment: normal_fragment,
	normalmap_pars_fragment: normalmap_pars_fragment,
	packing: packing,
	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	project_vertex: project_vertex,
	dithering_fragment: dithering_fragment,
	dithering_pars_fragment: dithering_pars_fragment,
	roughnessmap_fragment: roughnessmap_fragment,
	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	shadowmap_pars_fragment: shadowmap_pars_fragment,
	shadowmap_pars_vertex: shadowmap_pars_vertex,
	shadowmap_vertex: shadowmap_vertex,
	shadowmask_pars_fragment: shadowmask_pars_fragment,
	skinbase_vertex: skinbase_vertex,
	skinning_pars_vertex: skinning_pars_vertex,
	skinning_vertex: skinning_vertex,
	skinnormal_vertex: skinnormal_vertex,
	specularmap_fragment: specularmap_fragment,
	specularmap_pars_fragment: specularmap_pars_fragment,
	tonemapping_fragment: tonemapping_fragment,
	tonemapping_pars_fragment: tonemapping_pars_fragment,
	uv_pars_fragment: uv_pars_fragment,
	uv_pars_vertex: uv_pars_vertex,
	uv_vertex: uv_vertex,
	uv2_pars_fragment: uv2_pars_fragment,
	uv2_pars_vertex: uv2_pars_vertex,
	uv2_vertex: uv2_vertex,
	worldpos_vertex: worldpos_vertex,
	cube_frag: cube_frag,
	cube_vert: cube_vert,
	depth_frag: depth_frag,
	depth_vert: depth_vert,
	distanceRGBA_frag: distanceRGBA_frag,
	distanceRGBA_vert: distanceRGBA_vert,
	equirect_frag: equirect_frag,
	equirect_vert: equirect_vert,
	linedashed_frag: linedashed_frag,
	linedashed_vert: linedashed_vert,
	meshbasic_frag: meshbasic_frag,
	meshbasic_vert: meshbasic_vert,
	meshlambert_frag: meshlambert_frag,
	meshlambert_vert: meshlambert_vert,
	meshphong_frag: meshphong_frag,
	meshphong_vert: meshphong_vert,
	meshphysical_frag: meshphysical_frag,
	meshphysical_vert: meshphysical_vert,
	normal_frag: normal_frag,
	normal_vert: normal_vert,
	points_frag: points_frag,
	points_vert: points_vert,
	shadow_frag: shadow_frag,
	shadow_vert: shadow_vert
};
var ShaderLib = {
	basic: {
		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.fog
		] ),
		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag
	},
	lambert: {
		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) }
			}
		] ),
		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag
	},
	phong: {
		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.gradientmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				specular: { value: new Color( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),
		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag
	},
	standard: {
		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.roughnessmap,
			UniformsLib.metalnessmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				roughness: { value: 0.5 },
				metalness: { value: 0.5 },
				envMapIntensity: { value: 1 }
			}
		] ),
		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag
	},
	points: {
		uniforms: UniformsUtils.merge( [
			UniformsLib.points,
			UniformsLib.fog
		] ),
		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag
	},
	dashed: {
		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.fog,
			{
				scale: { value: 1 },
				dashSize: { value: 1 },
				totalSize: { value: 2 }
			}
		] ),
		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag
	},
	depth: {
		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.displacementmap
		] ),
		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag
	},
	normal: {
		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			{
				opacity: { value: 1.0 }
			}
		] ),
		vertexShader: ShaderChunk.normal_vert,
		fragmentShader: ShaderChunk.normal_frag
	},
	cube: {
		uniforms: {
			tCube: { value: null },
			tFlip: { value: - 1 },
			opacity: { value: 1.0 }
		},
		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag
	},
	equirect: {
		uniforms: {
			tEquirect: { value: null },
		},
		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag
	},
	distanceRGBA: {
		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.displacementmap,
			{
				referencePosition: { value: new Vector3() },
				nearDistance: { value: 1 },
				farDistance: { value: 1000 }
			}
		] ),
		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag
	},
	shadow: {
		uniforms: UniformsUtils.merge( [
			UniformsLib.lights,
			UniformsLib.fog,
			{
				color: { value: new Color( 0x00000 ) },
				opacity: { value: 1.0 }
			},
		] ),
		vertexShader: ShaderChunk.shadow_vert,
		fragmentShader: ShaderChunk.shadow_frag
	}
};
ShaderLib.physical = {
	uniforms: UniformsUtils.merge( [
		ShaderLib.standard.uniforms,
		{
			clearCoat: { value: 0 },
			clearCoatRoughness: { value: 0 }
		}
	] ),
	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag
};
function Box2( min, max ) {
	this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
	this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );
}
Object.assign( Box2.prototype, {
	set: function ( min, max ) {
		this.min.copy( min );
		this.max.copy( max );
		return this;
	},
	setFromPoints: function ( points ) {
		this.makeEmpty();
		for ( var i = 0, il = points.length; i < il; i ++ ) {
			this.expandByPoint( points[ i ] );
		}
		return this;
	},
	setFromCenterAndSize: function () {
		var v1 = new Vector2();
		return function setFromCenterAndSize( center, size ) {
			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );
			return this;
		};
	}(),
	clone: function () {
		return new this.constructor().copy( this );
	},
	copy: function ( box ) {
		this.min.copy( box.min );
		this.max.copy( box.max );
		return this;
	},
	makeEmpty: function () {
		this.min.x = this.min.y = + Infinity;
		this.max.x = this.max.y = - Infinity;
		return this;
	},
	isEmpty: function () {
		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );
	},
	getCenter: function ( optionalTarget ) {
		var result = optionalTarget || new Vector2();
		return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	},
	getSize: function ( optionalTarget ) {
		var result = optionalTarget || new Vector2();
		return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );
	},
	expandByPoint: function ( point ) {
		this.min.min( point );
		this.max.max( point );
		return this;
	},
	expandByVector: function ( vector ) {
		this.min.sub( vector );
		this.max.add( vector );
		return this;
	},
	expandByScalar: function ( scalar ) {
		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );
		return this;
	},
	containsPoint: function ( point ) {
		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ? false : true;
	},
	containsBox: function ( box ) {
		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y;
	},
	getParameter: function ( point, optionalTarget ) {
		var result = optionalTarget || new Vector2();
		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);
	},
	intersectsBox: function ( box ) {
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
	},
	clampPoint: function ( point, optionalTarget ) {
		var result = optionalTarget || new Vector2();
		return result.copy( point ).clamp( this.min, this.max );
	},
	distanceToPoint: function () {
		var v1 = new Vector2();
		return function distanceToPoint( point ) {
			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();
		};
	}(),
	intersect: function ( box ) {
		this.min.max( box.min );
		this.max.min( box.max );
		return this;
	},
	union: function ( box ) {
		this.min.min( box.min );
		this.max.max( box.max );
		return this;
	},
	translate: function ( offset ) {
		this.min.add( offset );
		this.max.add( offset );
		return this;
	},
	equals: function ( box ) {
		return box.min.equals( this.min ) && box.max.equals( this.max );
	}
} );
function WebGLFlareRenderer( renderer, gl, state, textures, capabilities ) {
	var vertexBuffer, elementBuffer;
	var shader, program, attributes, uniforms;
	var tempTexture, occlusionTexture;
	function init() {
		var vertices = new Float32Array( [
			- 1, - 1, 0, 0,
			  1, - 1, 1, 0,
			  1, 1, 1, 1,
			- 1, 1, 0, 1
		] );
		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );
		vertexBuffer = gl.createBuffer();
		elementBuffer = gl.createBuffer();
		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );
		tempTexture = gl.createTexture();
		occlusionTexture = gl.createTexture();
		state.bindTexture( gl.TEXTURE_2D, tempTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
		state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
		shader = {
			vertexShader: [
				'uniform lowp int renderType;',
				'uniform vec3 screenPosition;',
				'uniform vec2 scale;',
				'uniform float rotation;',
				'uniform sampler2D occlusionMap;',
				'attribute vec2 position;',
				'attribute vec2 uv;',
				'varying vec2 vUV;',
				'varying float vVisibility;',
				'void main() {',
				'	vUV = uv;',
				'	vec2 pos = position;',
				'	if ( renderType == 2 ) {',
				'		vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',
				'		visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',
				'		visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',
				'		visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',
				'		visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',
				'		visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',
				'		visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',
				'		visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',
				'		visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',
				'		vVisibility =        visibility.r / 9.0;',
				'		vVisibility *= 1.0 - visibility.g / 9.0;',
				'		vVisibility *=       visibility.b / 9.0;',
				'		vVisibility *= 1.0 - visibility.a / 9.0;',
				'		pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;',
				'		pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;',
				'	}',
				'	gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',
				'}'
			].join( '\n' ),
			fragmentShader: [
				'uniform lowp int renderType;',
				'uniform sampler2D map;',
				'uniform float opacity;',
				'uniform vec3 color;',
				'varying vec2 vUV;',
				'varying float vVisibility;',
				'void main() {',
				'	if ( renderType == 0 ) {',
				'		gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );',
				'	} else if ( renderType == 1 ) {',
				'		gl_FragColor = texture2D( map, vUV );',
				'	} else {',
				'		vec4 texture = texture2D( map, vUV );',
				'		texture.a *= opacity * vVisibility;',
				'		gl_FragColor = texture;',
				'		gl_FragColor.rgb *= color;',
				'	}',
				'}'
			].join( '\n' )
		};
		program = createProgram( shader );
		attributes = {
			vertex: gl.getAttribLocation( program, 'position' ),
			uv: gl.getAttribLocation( program, 'uv' )
		};
		uniforms = {
			renderType: gl.getUniformLocation( program, 'renderType' ),
			map: gl.getUniformLocation( program, 'map' ),
			occlusionMap: gl.getUniformLocation( program, 'occlusionMap' ),
			opacity: gl.getUniformLocation( program, 'opacity' ),
			color: gl.getUniformLocation( program, 'color' ),
			scale: gl.getUniformLocation( program, 'scale' ),
			rotation: gl.getUniformLocation( program, 'rotation' ),
			screenPosition: gl.getUniformLocation( program, 'screenPosition' )
		};
	}
	this.render = function ( flares, scene, camera, viewport ) {
		if ( flares.length === 0 ) return;
		var tempPosition = new Vector3();
		var invAspect = viewport.w / viewport.z,
			halfViewportWidth = viewport.z * 0.5,
			halfViewportHeight = viewport.w * 0.5;
		var size = 16 / viewport.w,
			scale = new Vector2( size * invAspect, size );
		var screenPosition = new Vector3( 1, 1, 0 ),
			screenPositionPixels = new Vector2( 1, 1 );
		var validArea = new Box2();
		validArea.min.set( viewport.x, viewport.y );
		validArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );
		if ( program === undefined ) {
			init();
		}
		state.useProgram( program );
		state.initAttributes();
		state.enableAttribute( attributes.vertex );
		state.enableAttribute( attributes.uv );
		state.disableUnusedAttributes();
		gl.uniform1i( uniforms.occlusionMap, 0 );
		gl.uniform1i( uniforms.map, 1 );
		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );
		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		state.disable( gl.CULL_FACE );
		state.buffers.depth.setMask( false );
		for ( var i = 0, l = flares.length; i < l; i ++ ) {
			size = 16 / viewport.w;
			scale.set( size * invAspect, size );
			var flare = flares[ i ];
			tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );
			tempPosition.applyMatrix4( camera.matrixWorldInverse );
			tempPosition.applyMatrix4( camera.projectionMatrix );
			screenPosition.copy( tempPosition );
			screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
			screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;
			if ( validArea.containsPoint( screenPositionPixels ) === true ) {
				state.activeTexture( gl.TEXTURE0 );
				state.bindTexture( gl.TEXTURE_2D, null );
				state.activeTexture( gl.TEXTURE1 );
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );
				gl.uniform1i( uniforms.renderType, 0 );
				gl.uniform2f( uniforms.scale, scale.x, scale.y );
				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
				state.disable( gl.BLEND );
				state.enable( gl.DEPTH_TEST );
				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
				state.activeTexture( gl.TEXTURE0 );
				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );
				gl.uniform1i( uniforms.renderType, 1 );
				state.disable( gl.DEPTH_TEST );
				state.activeTexture( gl.TEXTURE1 );
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
				flare.positionScreen.copy( screenPosition );
				if ( flare.customUpdateCallback ) {
					flare.customUpdateCallback( flare );
				} else {
					flare.updateLensFlares();
				}
				gl.uniform1i( uniforms.renderType, 2 );
				state.enable( gl.BLEND );
				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {
					var sprite = flare.lensFlares[ j ];
					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {
						screenPosition.x = sprite.x;
						screenPosition.y = sprite.y;
						screenPosition.z = sprite.z;
						size = sprite.size * sprite.scale / viewport.w;
						scale.x = size * invAspect;
						scale.y = size;
						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
						gl.uniform2f( uniforms.scale, scale.x, scale.y );
						gl.uniform1f( uniforms.rotation, sprite.rotation );
						gl.uniform1f( uniforms.opacity, sprite.opacity );
						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );
						state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
						textures.setTexture2D( sprite.texture, 1 );
						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
					}
				}
			}
		}
		state.enable( gl.CULL_FACE );
		state.enable( gl.DEPTH_TEST );
		state.buffers.depth.setMask( true );
		state.reset();
	};
	function createProgram( shader ) {
		var program = gl.createProgram();
		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
		var prefix = 'precision ' + capabilities.precision + ' float;\n';
		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
		gl.shaderSource( vertexShader, prefix + shader.vertexShader );
		gl.compileShader( fragmentShader );
		gl.compileShader( vertexShader );
		gl.attachShader( program, fragmentShader );
		gl.attachShader( program, vertexShader );
		gl.linkProgram( program );
		return program;
	}
}
function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	this.needsUpdate = true;
}
CanvasTexture.prototype = Object.create( Texture.prototype );
CanvasTexture.prototype.constructor = CanvasTexture;
function WebGLSpriteRenderer( renderer, gl, state, textures, capabilities ) {
	var vertexBuffer, elementBuffer;
	var program, attributes, uniforms;
	var texture;
	var spritePosition = new Vector3();
	var spriteRotation = new Quaternion();
	var spriteScale = new Vector3();
	function init() {
		var vertices = new Float32Array( [
			- 0.5, - 0.5, 0, 0,
			  0.5, - 0.5, 1, 0,
			  0.5, 0.5, 1, 1,
			- 0.5, 0.5, 0, 1
		] );
		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );
		vertexBuffer = gl.createBuffer();
		elementBuffer = gl.createBuffer();
		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );
		program = createProgram();
		attributes = {
			position: gl.getAttribLocation( program, 'position' ),
			uv: gl.getAttribLocation( program, 'uv' )
		};
		uniforms = {
			uvOffset: gl.getUniformLocation( program, 'uvOffset' ),
			uvScale: gl.getUniformLocation( program, 'uvScale' ),
			rotation: gl.getUniformLocation( program, 'rotation' ),
			scale: gl.getUniformLocation( program, 'scale' ),
			color: gl.getUniformLocation( program, 'color' ),
			map: gl.getUniformLocation( program, 'map' ),
			opacity: gl.getUniformLocation( program, 'opacity' ),
			modelViewMatrix: gl.getUniformLocation( program, 'modelViewMatrix' ),
			projectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),
			fogType: gl.getUniformLocation( program, 'fogType' ),
			fogDensity: gl.getUniformLocation( program, 'fogDensity' ),
			fogNear: gl.getUniformLocation( program, 'fogNear' ),
			fogFar: gl.getUniformLocation( program, 'fogFar' ),
			fogColor: gl.getUniformLocation( program, 'fogColor' ),
			fogDepth: gl.getUniformLocation( program, 'fogDepth' ),
			alphaTest: gl.getUniformLocation( program, 'alphaTest' )
		};
		var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
		canvas.width = 8;
		canvas.height = 8;
		var context = canvas.getContext( '2d' );
		context.fillStyle = 'white';
		context.fillRect( 0, 0, 8, 8 );
		texture = new CanvasTexture( canvas );
	}
	this.render = function ( sprites, scene, camera ) {
		if ( sprites.length === 0 ) return;
		if ( program === undefined ) {
			init();
		}
		state.useProgram( program );
		state.initAttributes();
		state.enableAttribute( attributes.position );
		state.enableAttribute( attributes.uv );
		state.disableUnusedAttributes();
		state.disable( gl.CULL_FACE );
		state.enable( gl.BLEND );
		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );
		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );
		state.activeTexture( gl.TEXTURE0 );
		gl.uniform1i( uniforms.map, 0 );
		var oldFogType = 0;
		var sceneFogType = 0;
		var fog = scene.fog;
		if ( fog ) {
			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );
			if ( fog.isFog ) {
				gl.uniform1f( uniforms.fogNear, fog.near );
				gl.uniform1f( uniforms.fogFar, fog.far );
				gl.uniform1i( uniforms.fogType, 1 );
				oldFogType = 1;
				sceneFogType = 1;
			} else if ( fog.isFogExp2 ) {
				gl.uniform1f( uniforms.fogDensity, fog.density );
				gl.uniform1i( uniforms.fogType, 2 );
				oldFogType = 2;
				sceneFogType = 2;
			}
		} else {
			gl.uniform1i( uniforms.fogType, 0 );
			oldFogType = 0;
			sceneFogType = 0;
		}
		for ( var i = 0, l = sprites.length; i < l; i ++ ) {
			var sprite = sprites[ i ];
			sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
			sprite.z = - sprite.modelViewMatrix.elements[ 14 ];
		}
		sprites.sort( painterSortStable );
		var scale = [];
		for ( var i = 0, l = sprites.length; i < l; i ++ ) {
			var sprite = sprites[ i ];
			var material = sprite.material;
			if ( material.visible === false ) continue;
			sprite.onBeforeRender( renderer, scene, camera, undefined, material, undefined );
			gl.uniform1f( uniforms.alphaTest, material.alphaTest );
			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );
			sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );
			scale[ 0 ] = spriteScale.x;
			scale[ 1 ] = spriteScale.y;
			var fogType = 0;
			if ( scene.fog && material.fog ) {
				fogType = sceneFogType;
			}
			if ( oldFogType !== fogType ) {
				gl.uniform1i( uniforms.fogType, fogType );
				oldFogType = fogType;
			}
			if ( material.map !== null ) {
				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );
			} else {
				gl.uniform2f( uniforms.uvOffset, 0, 0 );
				gl.uniform2f( uniforms.uvScale, 1, 1 );
			}
			gl.uniform1f( uniforms.opacity, material.opacity );
			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );
			gl.uniform1f( uniforms.rotation, material.rotation );
			gl.uniform2fv( uniforms.scale, scale );
			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );
			state.buffers.depth.setTest( material.depthTest );
			state.buffers.depth.setMask( material.depthWrite );
			state.buffers.color.setMask( material.colorWrite );
			textures.setTexture2D( material.map || texture, 0 );
			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
			sprite.onAfterRender( renderer, scene, camera, undefined, material, undefined );
		}
		state.enable( gl.CULL_FACE );
		state.reset();
	};
	function createProgram() {
		var program = gl.createProgram();
		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
		gl.shaderSource( vertexShader, [
			'precision ' + capabilities.precision + ' float;',
			'#define SHADER_NAME ' + 'SpriteMaterial',
			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform float rotation;',
			'uniform vec2 scale;',
			'uniform vec2 uvOffset;',
			'uniform vec2 uvScale;',
			'attribute vec2 position;',
			'attribute vec2 uv;',
			'varying vec2 vUV;',
			'varying float fogDepth;',
			'void main() {',
			'	vUV = uvOffset + uv * uvScale;',
			'	vec2 alignedPosition = position * scale;',
			'	vec2 rotatedPosition;',
			'	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
			'	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',
			'	vec4 mvPosition;',
			'	mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
			'	mvPosition.xy += rotatedPosition;',
			'	gl_Position = projectionMatrix * mvPosition;',
			'	fogDepth = - mvPosition.z;',
			'}'
		].join( '\n' ) );
		gl.shaderSource( fragmentShader, [
			'precision ' + capabilities.precision + ' float;',
			'#define SHADER_NAME ' + 'SpriteMaterial',
			'uniform vec3 color;',
			'uniform sampler2D map;',
			'uniform float opacity;',
			'uniform int fogType;',
			'uniform vec3 fogColor;',
			'uniform float fogDensity;',
			'uniform float fogNear;',
			'uniform float fogFar;',
			'uniform float alphaTest;',
			'varying vec2 vUV;',
			'varying float fogDepth;',
			'void main() {',
			'	vec4 texture = texture2D( map, vUV );',
			'	gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',
			'	if ( gl_FragColor.a < alphaTest ) discard;',
			'	if ( fogType > 0 ) {',
			'		float fogFactor = 0.0;',
			'		if ( fogType == 1 ) {',
			'			fogFactor = smoothstep( fogNear, fogFar, fogDepth );',
			'		} else {',
			'			const float LOG2 = 1.442695;',
			'			fogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );',
			'			fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
			'		}',
			'		gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );',
			'	}',
			'}'
		].join( '\n' ) );
		gl.compileShader( vertexShader );
		gl.compileShader( fragmentShader );
		gl.attachShader( program, vertexShader );
		gl.attachShader( program, fragmentShader );
		gl.linkProgram( program );
		return program;
	}
	function painterSortStable( a, b ) {
		if ( a.renderOrder !== b.renderOrder ) {
			return a.renderOrder - b.renderOrder;
		} else if ( a.z !== b.z ) {
			return b.z - a.z;
		} else {
			return b.id - a.id;
		}
	}
}
var materialId = 0;
function Material() {
	Object.defineProperty( this, 'id', { value: materialId ++ } );
	this.uuid = _Math.generateUUID();
	this.name = '';
	this.type = 'Material';
	this.fog = true;
	this.lights = true;
	this.blending = NormalBlending;
	this.side = FrontSide;
	this.flatShading = false;
	this.vertexColors = NoColors;
	this.opacity = 1;
	this.transparent = false;
	this.blendSrc = SrcAlphaFactor;
	this.blendDst = OneMinusSrcAlphaFactor;
	this.blendEquation = AddEquation;
	this.blendSrcAlpha = null;
	this.blendDstAlpha = null;
	this.blendEquationAlpha = null;
	this.depthFunc = LessEqualDepth;
	this.depthTest = true;
	this.depthWrite = true;
	this.clippingPlanes = null;
	this.clipIntersection = false;
	this.clipShadows = false;
	this.colorWrite = true;
	this.precision = null;
	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;
	this.dithering = false;
	this.alphaTest = 0;
	this.premultipliedAlpha = false;
	this.overdraw = 0;
	this.visible = true;
	this.userData = {};
	this.needsUpdate = true;
}
Object.assign( Material.prototype, EventDispatcher.prototype, {
	isMaterial: true,
	onBeforeCompile: function () {},
	setValues: function ( values ) {
		if ( values === undefined ) return;
		for ( var key in values ) {
			var newValue = values[ key ];
			if ( newValue === undefined ) {
				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
				continue;
			}
			if ( key === 'shading' ) {
				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( newValue === FlatShading ) ? true : false;
				continue;
			}
			var currentValue = this[ key ];
			if ( currentValue === undefined ) {
				console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
				continue;
			}
			if ( currentValue && currentValue.isColor ) {
				currentValue.set( newValue );
			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {
				currentValue.copy( newValue );
			} else if ( key === 'overdraw' ) {
				this[ key ] = Number( newValue );
			} else {
				this[ key ] = newValue;
			}
		}
	},
	toJSON: function ( meta ) {
		var isRoot = ( meta === undefined || typeof meta === 'string' );
		if ( isRoot ) {
			meta = {
				textures: {},
				images: {}
			};
		}
		var data = {
			metadata: {
				version: 4.5,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};
		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;
		if ( this.color && this.color.isColor ) data.color = this.color.getHex();
		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;
		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;
		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;
		if ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;
		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
		if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
		if ( this.bumpMap && this.bumpMap.isTexture ) {
			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;
		}
		if ( this.normalMap && this.normalMap.isTexture ) {
			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalScale = this.normalScale.toArray();
		}
		if ( this.displacementMap && this.displacementMap.isTexture ) {
			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;
		}
		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;
		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
		if ( this.envMap && this.envMap.isTexture ) {
			data.envMap = this.envMap.toJSON( meta ).uuid;
			data.reflectivity = this.reflectivity;
		}
		if ( this.gradientMap && this.gradientMap.isTexture ) {
			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;
		}
		if ( this.size !== undefined ) data.size = this.size;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;
		if ( this.blending !== NormalBlending ) data.blending = this.blending;
		if ( this.flatShading === true ) data.flatShading = this.flatShading;
		if ( this.side !== FrontSide ) data.side = this.side;
		if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;
		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = this.transparent;
		data.depthFunc = this.depthFunc;
		data.depthTest = this.depthTest;
		data.depthWrite = this.depthWrite;
		if ( this.rotation !== 0 ) data.rotation = this.rotation;
		if ( this.linewidth !== 1 ) data.linewidth = this.linewidth;
		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
		if ( this.scale !== undefined ) data.scale = this.scale;
		if ( this.dithering === true ) data.dithering = true;
		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;
		if ( this.morphTargets === true ) data.morphTargets = true;
		if ( this.skinning === true ) data.skinning = true;
		if ( this.visible === false ) data.visible = false;
		if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;
		function extractFromCache( cache ) {
			var values = [];
			for ( var key in cache ) {
				var data = cache[ key ];
				delete data.metadata;
				values.push( data );
			}
			return values;
		}
		if ( isRoot ) {
			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );
			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;
		}
		return data;
	},
	clone: function () {
		return new this.constructor().copy( this );
	},
	copy: function ( source ) {
		this.name = source.name;
		this.fog = source.fog;
		this.lights = source.lights;
		this.blending = source.blending;
		this.side = source.side;
		this.flatShading = source.flatShading;
		this.vertexColors = source.vertexColors;
		this.opacity = source.opacity;
		this.transparent = source.transparent;
		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;
		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;
		this.colorWrite = source.colorWrite;
		this.precision = source.precision;
		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;
		this.dithering = source.dithering;
		this.alphaTest = source.alphaTest;
		this.premultipliedAlpha = source.premultipliedAlpha;
		this.overdraw = source.overdraw;
		this.visible = source.visible;
		this.userData = JSON.parse( JSON.stringify( source.userData ) );
		this.clipShadows = source.clipShadows;
		this.clipIntersection = source.clipIntersection;
		var srcPlanes = source.clippingPlanes,
			dstPlanes = null;
		if ( srcPlanes !== null ) {
			var n = srcPlanes.length;
			dstPlanes = new Array( n );
			for ( var i = 0; i !== n; ++ i )
				dstPlanes[ i ] = srcPlanes[ i ].clone();
		}
		this.clippingPlanes = dstPlanes;
		return this;
	},
	dispose: function () {
		this.dispatchEvent( { type: 'dispose' } );
	}
} );
function MeshDepthMaterial( parameters ) {
	Material.call( this );
	this.type = 'MeshDepthMaterial';
	this.depthPacking = BasicDepthPacking;
	this.skinning = false;
	this.morphTargets = false;
	this.map = null;
	this.alphaMap = null;
	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;
	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.fog = false;
	this.lights = false;
	this.setValues( parameters );
}
MeshDepthMaterial.prototype = Object.create( Material.prototype );
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
MeshDepthMaterial.prototype.copy = function ( source ) {
	Material.prototype.copy.call( this, source );
	this.depthPacking = source.depthPacking;
	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.map = source.map;
	this.alphaMap = source.alphaMap;
	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;
	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	return this;
};
function MeshDistanceMaterial( parameters ) {
	Material.call( this );
	this.type = 'MeshDistanceMaterial';
	this.referencePosition = new Vector3();
	this.nearDistance = 1;
	this.farDistance = 1000;
	this.skinning = false;
	this.morphTargets = false;
	this.map = null;
	this.alphaMap = null;
	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;
	this.fog = false;
	this.lights = false;
	this.setValues( parameters );
}
MeshDistanceMaterial.prototype = Object.create( Material.prototype );
MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
MeshDistanceMaterial.prototype.copy = function ( source ) {
	Material.prototype.copy.call( this, source );
	this.referencePosition.copy( source.referencePosition );
	this.nearDistance = source.nearDistance;
	this.farDistance = source.farDistance;
	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.map = source.map;
	this.alphaMap = source.alphaMap;
	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;
	return this;
};
function Box3( min, max ) {
	this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
	this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );
}
Object.assign( Box3.prototype, {
	isBox3: true,
	set: function ( min, max ) {
		this.min.copy( min );
		this.max.copy( max );
		return this;
	},
	setFromArray: function ( array ) {
		var minX = + Infinity;
		var minY = + Infinity;
		var minZ = + Infinity;
		var maxX = - Infinity;
		var maxY = - Infinity;
		var maxZ = - Infinity;
		for ( var i = 0, l = array.length; i < l; i += 3 ) {
			var x = array[ i ];
			var y = array[ i + 1 ];
			var z = array[ i + 2 ];
			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;
			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;
		}
		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );
		return this;
	},
	setFromBufferAttribute: function ( attribute ) {
		var minX = + Infinity;
		var minY = + Infinity;
		var minZ = + Infinity;
		var maxX = - Infinity;
		var maxY = - Infinity;
		var maxZ = - Infinity;
		for ( var i = 0, l = attribute.count; i < l; i ++ ) {
			var x = attribute.getX( i );
			var y = attribute.getY( i );
			var z = attribute.getZ( i );
			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;
			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;
		}
		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );
		return this;
	},
	setFromPoints: function ( points ) {
		this.makeEmpty();
		for ( var i = 0, il = points.length; i < il; i ++ ) {
			this.expandByPoint( points[ i ] );
		}
		return this;
	},
	setFromCenterAndSize: function () {
		var v1 = new Vector3();
		return function setFromCenterAndSize( center, size ) {
			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );
			return this;
		};
	}(),
	setFromObject: function ( object ) {
		this.makeEmpty();
		return this.expandByObject( object );
	},
	clone: function () {
		return new this.constructor().copy( this );
	},
	copy: function ( box ) {
		this.min.copy( box.min );
		this.max.copy( box.max );
		return this;
	},
	makeEmpty: function () {
		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;
		return this;
	},
	isEmpty: function () {
		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );
	},
	getCenter: function ( optionalTarget ) {
		var result = optionalTarget || new Vector3();
		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	},
	getSize: function ( optionalTarget ) {
		var result = optionalTarget || new Vector3();
		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );
	},
	expandByPoint: function ( point ) {
		this.min.min( point );
		this.max.max( point );
		return this;
	},
	expandByVector: function ( vector ) {
		this.min.sub( vector );
		this.max.add( vector );
		return this;
	},
	expandByScalar: function ( scalar ) {
		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );
		return this;
	},
	expandByObject: function () {
		var scope, i, l;
		var v1 = new Vector3();
		function traverse( node ) {
			var geometry = node.geometry;
			if ( geometry !== undefined ) {
				if ( geometry.isGeometry ) {
					var vertices = geometry.vertices;
					for ( i = 0, l = vertices.length; i < l; i ++ ) {
						v1.copy( vertices[ i ] );
						v1.applyMatrix4( node.matrixWorld );
						scope.expandByPoint( v1 );
					}
				} else if ( geometry.isBufferGeometry ) {
					var attribute = geometry.attributes.position;
					if ( attribute !== undefined ) {
						for ( i = 0, l = attribute.count; i < l; i ++ ) {
							v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );
							scope.expandByPoint( v1 );
						}
					}
				}
			}
		}
		return function expandByObject( object ) {
			scope = this;
			object.updateMatrixWorld( true );
			object.traverse( traverse );
			return this;
		};
	}(),
	containsPoint: function ( point ) {
		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ||
			point.z < this.min.z || point.z > this.max.z ? false : true;
	},
	containsBox: function ( box ) {
		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;
	},
	getParameter: function ( point, optionalTarget ) {
		var result = optionalTarget || new Vector3();
		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);
	},
	intersectsBox: function ( box ) {
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ||
			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
	},
	intersectsSphere: ( function () {
		var closestPoint = new Vector3();
		return function intersectsSphere( sphere ) {
			this.clampPoint( sphere.center, closestPoint );
			return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );
		};
	} )(),
	intersectsPlane: function ( plane ) {
		var min, max;
		if ( plane.normal.x > 0 ) {
			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;
		} else {
			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;
		}
		if ( plane.normal.y > 0 ) {
			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;
		} else {
			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;
		}
		if ( plane.normal.z > 0 ) {
			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;
		} else {
			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;
		}
		return ( min <= plane.constant && max >= plane.constant );
	},
	clampPoint: function ( point, optionalTarget ) {
		var result = optionalTarget || new Vector3();
		return result.copy( point ).clamp( this.min, this.max );
	},
	distanceToPoint: function () {
		var v1 = new Vector3();
		return function distanceToPoint( point ) {
			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();
		};
	}(),
	getBoundingSphere: function () {
		var v1 = new Vector3();
		return function getBoundingSphere( optionalTarget ) {
			var result = optionalTarget || new Sphere();
			this.getCenter( result.center );
			result.radius = this.getSize( v1 ).length() * 0.5;
			return result;
		};
	}(),
	intersect: function ( box ) {
		this.min.max( box.min );
		this.max.min( box.max );
		if ( this.isEmpty() ) this.makeEmpty();
		return this;
	},
	union: function ( box ) {
		this.min.min( box.min );
		this.max.max( box.max );
		return this;
	},
	applyMatrix4: function () {
		var points = [
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3()
		];
		return function applyMatrix4( matrix ) {
			if ( this.isEmpty() ) return this;
			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix );
			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix );
			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix );
			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix );
			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix );
			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix );
			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix );
			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );
			this.setFromPoints( points );
			return this;
		};
	}(),
	translate: function ( offset ) {
		this.min.add( offset );
		this.max.add( offset );
		return this;
	},
	equals: function ( box ) {
		return box.min.equals( this.min ) && box.max.equals( this.max );
	}
} );
function Sphere( center, radius ) {
	this.center = ( center !== undefined ) ? center : new Vector3();
	this.radius = ( radius !== undefined ) ? radius : 0;
}
Object.assign( Sphere.prototype, {
	set: function ( center, radius ) {
		this.center.copy( center );
		this.radius = radius;
		return this;
	},
	setFromPoints: function () {
		var box = new Box3();
		return function setFromPoints( points, optionalCenter ) {
			var center = this.center;
			if ( optionalCenter !== undefined ) {
				center.copy( optionalCenter );
			} else {
				box.setFromPoints( points ).getCenter( center );
			}
			var maxRadiusSq = 0;
			for ( var i = 0, il = points.length; i < il; i ++ ) {
				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );
			}
			this.radius = Math.sqrt( maxRadiusSq );
			return this;
		};
	}(),
	clone: function () {
		return new this.constructor().copy( this );
	},
	copy: function ( sphere ) {
		this.center.copy( sphere.center );
		this.radius = sphere.radius;
		return this;
	},
	empty: function () {
		return ( this.radius <= 0 );
	},
	containsPoint: function ( point ) {
		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );
	},
	distanceToPoint: function ( point ) {
		return ( point.distanceTo( this.center ) - this.radius );
	},
	intersectsSphere: function ( sphere ) {
		var radiusSum = this.radius + sphere.radius;
		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );
	},
	intersectsBox: function ( box ) {
		return box.intersectsSphere( this );
	},
	intersectsPlane: function ( plane ) {
		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;
	},
	clampPoint: function ( point, optionalTarget ) {
		var deltaLengthSq = this.center.distanceToSquared( point );
		var result = optionalTarget || new Vector3();
		result.copy( point );
		if ( deltaLengthSq > ( this.radius * this.radius ) ) {
			result.sub( this.center ).normalize();
			result.multiplyScalar( this.radius ).add( this.center );
		}
		return result;
	},
	getBoundingBox: function ( optionalTarget ) {
		var box = optionalTarget || new Box3();
		box.set( this.center, this.center );
		box.expandByScalar( this.radius );
		return box;
	},
	applyMatrix4: function ( matrix ) {
		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();
		return this;
	},
	translate: function ( offset ) {
		this.center.add( offset );
		return this;
	},
	equals: function ( sphere ) {
		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );
	}
} );
function Plane( normal, constant ) {
	this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;
}
Object.assign( Plane.prototype, {
	set: function ( normal, constant ) {
		this.normal.copy( normal );
		this.constant = constant;
		return this;
	},
	setComponents: function ( x, y, z, w ) {
		this.normal.set( x, y, z );
		this.constant = w;
		return this;
	},
	setFromNormalAndCoplanarPoint: function ( normal, point ) {
		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );
		return this;
	},
	setFromCoplanarPoints: function () {
		var v1 = new Vector3();
		var v2 = new Vector3();
		return function setFromCoplanarPoints( a, b, c ) {
			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();
			this.setFromNormalAndCoplanarPoint( normal, a );
			return this;
		};
	}(),
	clone: function () {
		return new this.constructor().copy( this );
	},
	copy: function ( plane ) {
		this.normal.copy( plane.normal );
		this.constant = plane.constant;
		return this;
	},
	normalize: function () {
		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;
		return this;
	},
	negate: function () {
		this.constant *= - 1;
		this.normal.negate();
		return this;
	},
	distanceToPoint: function ( point ) {
		return this.normal.dot( point ) + this.constant;
	},
	distanceToSphere: function ( sphere ) {
		return this.distanceToPoint( sphere.center ) - sphere.radius;
	},
	projectPoint: function ( point, optionalTarget ) {
		var result = optionalTarget || new Vector3();
		return result.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );
	},
	intersectLine: function () {
		var v1 = new Vector3();
		return function intersectLine( line, optionalTarget ) {
			var result = optionalTarget || new Vector3();
			var direction = line.delta( v1 );
			var denominator = this.normal.dot( direction );
			if ( denominator === 0 ) {
				if ( this.distanceToPoint( line.start ) === 0 ) {
					return result.copy( line.start );
				}
				return undefined;
			}
			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;
			if ( t < 0 || t > 1 ) {
				return undefined;
			}
			return result.copy( direction ).multiplyScalar( t ).add( line.start );
		};
	}(),
	intersectsLine: function ( line ) {
		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );
		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );
	},
	intersectsBox: function ( box ) {
		return box.intersectsPlane( this );
	},
	intersectsSphere: function ( sphere ) {
		return sphere.intersectsPlane( this );
	},
	coplanarPoint: function ( optionalTarget ) {
		var result = optionalTarget || new Vector3();
		return result.copy( this.normal ).multiplyScalar( - this.constant );
	},
	applyMatrix4: function () {
		var v1 = new Vector3();
		var m1 = new Matrix3();
		return function applyMatrix4( matrix, optionalNormalMatrix ) {
			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
			var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );
			var normal = this.normal.applyMatrix3( normalMatrix ).normalize();
			this.constant = - referencePoint.dot( normal );
			return this;
		};
	}(),
	translate: function ( offset ) {
		this.constant -= offset.dot( this.normal );
		return this;
	},
	equals: function ( plane ) {
		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );
	}
} );
function Frustum( p0, p1, p2, p3, p4, p5 ) {
	this.planes = [
		( p0 !== undefined ) ? p0 : new Plane(),
		( p1 !== undefined ) ? p1 : new Plane(),
		( p2 !== undefined ) ? p2 : new Plane(),
		( p3 !== undefined ) ? p3 : new Plane(),
		( p4 !== undefined ) ? p4 : new Plane(),
		( p5 !== undefined ) ? p5 : new Plane()
	];
}
Object.assign( Frustum.prototype, {
	set: function ( p0, p1, p2, p3, p4, p5 ) {
		var planes = this.planes;
		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );
		return this;
	},
	clone: function () {
		return new this.constructor().copy( this );
	},
	copy: function ( frustum ) {
		var planes = this.planes;
		for ( var i = 0; i < 6; i ++ ) {
			planes[ i ].copy( frustum.planes[ i ] );
		}
		return this;
	},
	setFromMatrix: function ( m ) {
		var planes = this.planes;
		var me = m.elements;
		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];
		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();
		return this;
	},
	intersectsObject: function () {
		var sphere = new Sphere();
		return function intersectsObject( object ) {
			var geometry = object.geometry;
			if ( geometry.boundingSphere === null )
				geometry.computeBoundingSphere();
			sphere.copy( geometry.boundingSphere )
				.applyMatrix4( object.matrixWorld );
			return this.intersectsSphere( sphere );
		};
	}(),
	intersectsSprite: function () {
		var sphere = new Sphere();
		return function intersectsSprite( sprite ) {
			sphere.center.set( 0, 0, 0 );
			sphere.radius = 0.7071067811865476;
			sphere.applyMatrix4( sprite.matrixWorld );
			return this.intersectsSphere( sphere );
		};
	}(),
	intersectsSphere: function ( sphere ) {
		var planes = this.planes;
		var center = sphere.center;
		var negRadius = - sphere.radius;
		for ( var i = 0; i < 6; i ++ ) {
			var distance = planes[ i ].distanceToPoint( center );
			if ( distance < negRadius ) {
				return false;
			}
		}
		return true;
	},
	intersectsBox: function () {
		var p1 = new Vector3(),
			p2 = new Vector3();
		return function intersectsBox( box ) {
			var planes = this.planes;
			for ( var i = 0; i < 6; i ++ ) {
				var plane = planes[ i ];
				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
				var d1 = plane.distanceToPoint( p1 );
				var d2 = plane.distanceToPoint( p2 );
				if ( d1 < 0 && d2 < 0 ) {
					return false;
				}
			}
			return true;
		};
	}(),
	containsPoint: function ( point ) {
		var planes = this.planes;
		for ( var i = 0; i < 6; i ++ ) {
			if ( planes[ i ].distanceToPoint( point ) < 0 ) {
				return false;
			}
		}
		return true;
	}
} );
function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {
	var _frustum = new Frustum(),
		_projScreenMatrix = new Matrix4(),
		_shadowMapSize = new Vector2(),
		_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),
		_lookTarget = new Vector3(),
		_lightPositionWorld = new Vector3(),
		_MorphingFlag = 1,
		_SkinningFlag = 2,
		_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,
		_depthMaterials = new Array( _NumberOfMaterialVariants ),
		_distanceMaterials = new Array( _NumberOfMaterialVariants ),
		_materialCache = {};
	var cubeDirections = [
		new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
		new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
	];
	var cubeUps = [
		new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
		new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
	];
	var cube2DViewPorts = [
		new Vector4(), new Vector4(), new Vector4(),
		new Vector4(), new Vector4(), new Vector4()
	];
	for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {
		var useMorphing = ( i & _MorphingFlag ) !== 0;
		var useSkinning = ( i & _SkinningFlag ) !== 0;
		var depthMaterial = new MeshDepthMaterial( {
			depthPacking: RGBADepthPacking,
			morphTargets: useMorphing,
			skinning: useSkinning
		} );
		_depthMaterials[ i ] = depthMaterial;
		var distanceMaterial = new MeshDistanceMaterial( {
			morphTargets: useMorphing,
			skinning: useSkinning
		} );
		_distanceMaterials[ i ] = distanceMaterial;
	}
	var scope = this;
	this.enabled = false;
	this.autoUpdate = true;
	this.needsUpdate = false;
	this.type = PCFShadowMap;
	this.renderReverseSided = true;
	this.renderSingleSided = true;
	this.render = function ( lights, scene, camera ) {
		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;
		if ( lights.length === 0 ) return;
		var _gl = _renderer.context;
		var _state = _renderer.state;
		_state.disable( _gl.BLEND );
		_state.buffers.color.setClear( 1, 1, 1, 1 );
		_state.buffers.depth.setTest( true );
		_state.setScissorTest( false );
		var faceCount;
		for ( var i = 0, il = lights.length; i < il; i ++ ) {
			var light = lights[ i ];
			var shadow = light.shadow;
			var isPointLight = light && light.isPointLight;
			if ( shadow === undefined ) {
				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
				continue;
			}
			var shadowCamera = shadow.camera;
			_shadowMapSize.copy( shadow.mapSize );
			_shadowMapSize.min( _maxShadowMapSize );
			if ( isPointLight ) {
				var vpWidth = _shadowMapSize.x;
				var vpHeight = _shadowMapSize.y;
				cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
				cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
				cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
				cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
				cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
				cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );
				_shadowMapSize.x *= 4.0;
				_shadowMapSize.y *= 2.0;
			}
			if ( shadow.map === null ) {
				var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + ".shadowMap";
				shadowCamera.updateProjectionMatrix();
			}
			if ( shadow.isSpotLightShadow ) {
				shadow.update( light );
			}
			var shadowMap = shadow.map;
			var shadowMatrix = shadow.matrix;
			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
			shadowCamera.position.copy( _lightPositionWorld );
			if ( isPointLight ) {
				faceCount = 6;
				shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );
			} else {
				faceCount = 1;
				_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
				shadowCamera.lookAt( _lookTarget );
				shadowCamera.updateMatrixWorld();
				shadowMatrix.set(
					0.5, 0.0, 0.0, 0.5,
					0.0, 0.5, 0.0, 0.5,
					0.0, 0.0, 0.5, 0.5,
					0.0, 0.0, 0.0, 1.0
				);
				shadowMatrix.multiply( shadowCamera.projectionMatrix );
				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );
			}
			_renderer.setRenderTarget( shadowMap );
			_renderer.clear();
			for ( var face = 0; face < faceCount; face ++ ) {
				if ( isPointLight ) {
					_lookTarget.copy( shadowCamera.position );
					_lookTarget.add( cubeDirections[ face ] );
					shadowCamera.up.copy( cubeUps[ face ] );
					shadowCamera.lookAt( _lookTarget );
					shadowCamera.updateMatrixWorld();
					var vpDimensions = cube2DViewPorts[ face ];
					_state.viewport( vpDimensions );
				}
				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );
				renderObject( scene, camera, shadowCamera, isPointLight );
			}
		}
		scope.needsUpdate = false;
	};
	function getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {
		var geometry = object.geometry;
		var result = null;
		var materialVariants = _depthMaterials;
		var customMaterial = object.customDepthMaterial;
		if ( isPointLight ) {
			materialVariants = _distanceMaterials;
			customMaterial = object.customDistanceMaterial;
		}
		if ( ! customMaterial ) {
			var useMorphing = false;
			if ( material.morphTargets ) {
				if ( geometry && geometry.isBufferGeometry ) {
					useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
				} else if ( geometry && geometry.isGeometry ) {
					useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
				}
			}
			if ( object.isSkinnedMesh && material.skinning === false ) {
				console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );
			}
			var useSkinning = object.isSkinnedMesh && material.skinning;
			var variantIndex = 0;
			if ( useMorphing ) variantIndex |= _MorphingFlag;
			if ( useSkinning ) variantIndex |= _SkinningFlag;
			result = materialVariants[ variantIndex ];
		} else {
			result = customMaterial;
		}
		if ( _renderer.localClippingEnabled &&
				material.clipShadows === true &&
				material.clippingPlanes.length !== 0 ) {
			var keyA = result.uuid, keyB = material.uuid;
			var materialsForVariant = _materialCache[ keyA ];
			if ( materialsForVariant === undefined ) {
				materialsForVariant = {};
				_materialCache[ keyA ] = materialsForVariant;
			}
			var cachedMaterial = materialsForVariant[ keyB ];
			if ( cachedMaterial === undefined ) {
				cachedMaterial = result.clone();
				materialsForVariant[ keyB ] = cachedMaterial;
			}
			result = cachedMaterial;
		}
		result.visible = material.visible;
		result.wireframe = material.wireframe;
		var side = material.side;
		if ( scope.renderSingleSided && side == DoubleSide ) {
			side = FrontSide;
		}
		if ( scope.renderReverseSided ) {
			if ( side === FrontSide ) side = BackSide;
			else if ( side === BackSide ) side = FrontSide;
		}
		result.side = side;
		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;
		result.clipIntersection = material.clipIntersection;
		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;
		if ( isPointLight && result.isMeshDistanceMaterial ) {
			result.referencePosition.copy( lightPositionWorld );
			result.nearDistance = shadowCameraNear;
			result.farDistance = shadowCameraFar;
		}
		return result;
	}
	function renderObject( object, camera, shadowCamera, isPointLight ) {
		if ( object.visible === false ) return;
		var visible = object.layers.test( camera.layers );
		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {
			if ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {
				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
				var geometry = _objects.update( object );
				var material = object.material;
				if ( Array.isArray( material ) ) {
					var groups = geometry.groups;
					for ( var k = 0, kl = groups.length; k < kl; k ++ ) {
						var group = groups[ k ];
						var groupMaterial = material[ group.materialIndex ];
						if ( groupMaterial && groupMaterial.visible ) {
							var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );
						}
					}
				} else if ( material.visible ) {
					var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
					_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );
				}
			}
		}
		var children = object.children;
		for ( var i = 0, l = children.length; i < l; i ++ ) {
			renderObject( children[ i ], camera, shadowCamera, isPointLight );
		}
	}
}
function WebGLAttributes( gl ) {
	var buffers = {};
	function createBuffer( attribute, bufferType ) {
		var array = attribute.array;
		var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
		var buffer = gl.createBuffer();
		gl.bindBuffer( bufferType, buffer );
		gl.bufferData( bufferType, array, usage );
		attribute.onUploadCallback();
		var type = gl.FLOAT;
		if ( array instanceof Float32Array ) {
			type = gl.FLOAT;
		} else if ( array instanceof Float64Array ) {
			console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );
		} else if ( array instanceof Uint16Array ) {
			type = gl.UNSIGNED_SHORT;
		} else if ( array instanceof Int16Array ) {
			type = gl.SHORT;
		} else if ( array instanceof Uint32Array ) {
			type = gl.UNSIGNED_INT;
		} else if ( array instanceof Int32Array ) {
			type = gl.INT;
		} else if ( array instanceof Int8Array ) {
			type = gl.BYTE;
		} else if ( array instanceof Uint8Array ) {
			type = gl.UNSIGNED_BYTE;
		}
		return {
			buffer: buffer,
			type: type,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version
		};
	}
	function updateBuffer( buffer, attribute, bufferType ) {
		var array = attribute.array;
		var updateRange = attribute.updateRange;
		gl.bindBuffer( bufferType, buffer );
		if ( attribute.dynamic === false ) {
			gl.bufferData( bufferType, array, gl.STATIC_DRAW );
		} else if ( updateRange.count === - 1 ) {
			gl.bufferSubData( bufferType, 0, array );
		} else if ( updateRange.count === 0 ) {
			console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );
		} else {
			gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
				array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );
			updateRange.count = - 1;
		}
	}
	function get( attribute ) {
		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;
		return buffers[ attribute.uuid ];
	}
	function remove( attribute ) {
		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;
		var data = buffers[ attribute.uuid ];
		if ( data ) {
			gl.deleteBuffer( data.buffer );
			delete buffers[ attribute.uuid ];
		}
	}
	function update( attribute, bufferType ) {
		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;
		var data = buffers[ attribute.uuid ];
		if ( data === undefined ) {
			buffers[ attribute.uuid ] = createBuffer( attribute, bufferType );
		} else if ( data.version < attribute.version ) {
			updateBuffer( data.buffer, attribute, bufferType );
			data.version = attribute.version;
		}
	}
	return {
		get: get,
		remove: remove,
		update: update
	};
}
function Euler( x, y, z, order ) {
	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || Euler.DefaultOrder;
}
Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];
Euler.DefaultOrder = 'XYZ';
Object.defineProperties( Euler.prototype, {
	x: {
		get: function () {
			return this._x;
		},
		set: function ( value ) {
			this._x = value;
			this.onChangeCallback();
		}
	},
	y: {
		get: function () {
			return this._y;
		},
		set: function ( value ) {
			this._y = value;
			this.onChangeCallback();
		}
	},
	z: {
		get: function () {
			return this._z;
		},
		set: function ( value ) {
			this._z = value;
			this.onChangeCallback();
		}
	},
	order: {
		get: function () {
			return this._order;
		},
		set: function ( value ) {
			this._order = value;
			this.onChangeCallback();
		}
	}
} );
Object.assign( Euler.prototype, {
	isEuler: true,
	set: function ( x, y, z, order ) {
		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;
		this.onChangeCallback();
		return this;
	},
	clone: function () {
		return new this.constructor( this._x, this._y, this._z, this._order );
	},
	copy: function ( euler ) {
		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;
		this.onChangeCallback();
		return this;
	},
	setFromRotationMatrix: function ( m, order, update ) {
		var clamp = _Math.clamp;
		var te = m.elements;
		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
		order = order || this._order;
		if ( order === 'XYZ' ) {
			this._y = Math.asin( clamp( m13, - 1, 1 ) );
			if ( Math.abs( m13 ) < 0.99999 ) {
				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );
			} else {
				this._x = Math.atan2( m32, m22 );
				this._z = 0;
			}
		} else if ( order === 'YXZ' ) {
			this._x = Math.asin( - clamp( m23, - 1, 1 ) );
			if ( Math.abs( m23 ) < 0.99999 ) {
				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );
			} else {
				this._y = Math.atan2( - m31, m11 );
				this._z = 0;
			}
		} else if ( order === 'ZXY' ) {
			this._x = Math.asin( clamp( m32, - 1, 1 ) );
			if ( Math.abs( m32 ) < 0.99999 ) {
				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );
			} else {
				this._y = 0;
				this._z = Math.atan2( m21, m11 );
			}
		} else if ( order === 'ZYX' ) {
			this._y = Math.asin( - clamp( m31, - 1, 1 ) );
			if ( Math.abs( m31 ) < 0.99999 ) {
				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );
			} else {
				this._x = 0;
				this._z = Math.atan2( - m12, m22 );
			}
		} else if ( order === 'YZX' ) {
			this._z = Math.asin( clamp( m21, - 1, 1 ) );
			if ( Math.abs( m21 ) < 0.99999 ) {
				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );
			} else {
				this._x = 0;
				this._y = Math.atan2( m13, m33 );
			}
		} else if ( order === 'XZY' ) {
			this._z = Math.asin( - clamp( m12, - 1, 1 ) );
			if ( Math.abs( m12 ) < 0.99999 ) {
				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );
			} else {
				this._x = Math.atan2( - m23, m33 );
				this._y = 0;
			}
		} else {
			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );
		}
		this._order = order;
		if ( update !== false ) this.onChangeCallback();
		return this;
	},
	setFromQuaternion: function () {
		var matrix = new Matrix4();
		return function setFromQuaternion( q, order, update ) {
			matrix.makeRotationFromQuaternion( q );
			return this.setFromRotationMatrix( matrix, order, update );
		};
	}(),
	setFromVector3: function ( v, order ) {
		return this.set( v.x, v.y, v.z, order || this._order );
	},
	reorder: function () {
		var q = new Quaternion();
		return function reorder( newOrder ) {
			q.setFromEuler( this );
			return this.setFromQuaternion( q, newOrder );
		};
	}(),
	equals: function ( euler ) {
		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );
	},
	fromArray: function ( array ) {
		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];
		this.onChangeCallback();
		return this;
	},
	toArray: function ( array, offset ) {
		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;
		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;
		return array;
	},
	toVector3: function ( optionalResult ) {
		if ( optionalResult ) {
			return optionalResult.set( this._x, this._y, this._z );
		} else {
			return new Vector3( this._x, this._y, this._z );
		}
	},
	onChange: function ( callback ) {
		this.onChangeCallback = callback;
		return this;
	},
	onChangeCallback: function () {}
} );
function Layers() {
	this.mask = 1 | 0;
}
Object.assign( Layers.prototype, {
	set: function ( channel ) {
		this.mask = 1 << channel | 0;
	},
	enable: function ( channel ) {
		this.mask |= 1 << channel | 0;
	},
	toggle: function ( channel ) {
		this.mask ^= 1 << channel | 0;
	},
	disable: function ( channel ) {
		this.mask &= ~ ( 1 << channel | 0 );
	},
	test: function ( layers ) {
		return ( this.mask & layers.mask ) !== 0;
	}
} );
var object3DId = 0;
function Object3D() {
	Object.defineProperty( this, 'id', { value: object3DId ++ } );
	this.uuid = _Math.generateUUID();
	this.name = '';
	this.type = 'Object3D';
	this.parent = null;
	this.children = [];
	this.up = Object3D.DefaultUp.clone();
	var position = new Vector3();
	var rotation = new Euler();
	var quaternion = new Quaternion();
	var scale = new Vector3( 1, 1, 1 );
	function onRotationChange() {
		quaternion.setFromEuler( rotation, false );
	}
	function onQuaternionChange() {
		rotation.setFromQuaternion( quaternion, undefined, false );
	}
	rotation.onChange( onRotationChange );
	quaternion.onChange( onQuaternionChange );
	Object.defineProperties( this, {
		position: {
			enumerable: true,
			value: position
		},
		rotation: {
			enumerable: true,
			value: rotation
		},
		quaternion: {
			enumerable: true,
			value: quaternion
		},
		scale: {
			enumerable: true,
			value: scale
		},
		modelViewMatrix: {
			value: new Matrix4()
		},
		normalMatrix: {
			value: new Matrix3()
		}
	} );
	this.matrix = new Matrix4();
	this.matrixWorld = new Matrix4();
	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = false;
	this.layers = new Layers();
	this.visible = true;
	this.castShadow = false;
	this.receiveShadow = false;
	this.frustumCulled = true;
	this.renderOrder = 0;
	this.userData = {};
}
Object3D.DefaultUp = new Vector3( 0, 1, 0 );
Object3D.DefaultMatrixAutoUpdate = true;
Object.assign( Object3D.prototype, EventDispatcher.prototype, {
	isObject3D: true,
	onBeforeRender: function () {},
	onAfterRender: function () {},
	applyMatrix: function ( matrix ) {
		this.matrix.multiplyMatrices( matrix, this.matrix );
		this.matrix.decompose( this.position, this.quaternion, this.scale );
	},
	applyQuaternion: function ( q ) {
		this.quaternion.premultiply( q );
		return this;
	},
	setRotationFromAxisAngle: function ( axis, angle ) {
		this.quaternion.setFromAxisAngle( axis, angle );
	},
	setRotationFromEuler: function ( euler ) {
		this.quaternion.setFromEuler( euler, true );
	},
	setRotationFromMatrix: function ( m ) {
		this.quaternion.setFromRotationMatrix( m );
	},
	setRotationFromQuaternion: function ( q ) {
		this.quaternion.copy( q );
	},
	rotateOnAxis: function () {
		var q1 = new Quaternion();
		return function rotateOnAxis( axis, angle ) {
			q1.setFromAxisAngle( axis, angle );
			this.quaternion.multiply( q1 );
			return this;
		};
	}(),
	rotateOnWorldAxis: function () {
		var q1 = new Quaternion();
		return function rotateOnWorldAxis( axis, angle ) {
			q1.setFromAxisAngle( axis, angle );
			this.quaternion.premultiply( q1 );
			return this;
		};
	}(),
	rotateX: function () {
		var v1 = new Vector3( 1, 0, 0 );
		return function rotateX( angle ) {
			return this.rotateOnAxis( v1, angle );
		};
	}(),
	rotateY: function () {
		var v1 = new Vector3( 0, 1, 0 );
		return function rotateY( angle ) {
			return this.rotateOnAxis( v1, angle );
		};
	}(),
	rotateZ: function () {
		var v1 = new Vector3( 0, 0, 1 );
		return function rotateZ( angle ) {
			return this.rotateOnAxis( v1, angle );
		};
	}(),
	translateOnAxis: function () {
		var v1 = new Vector3();
		return function translateOnAxis( axis, distance ) {
			v1.copy( axis ).applyQuaternion( this.quaternion );
			this.position.add( v1.multiplyScalar( distance ) );
			return this;
		};
	}(),
	translateX: function () {
		var v1 = new Vector3( 1, 0, 0 );
		return function translateX( distance ) {
			return this.translateOnAxis( v1, distance );
		};
	}(),
	translateY: function () {
		var v1 = new Vector3( 0, 1, 0 );
		return function translateY( distance ) {
			return this.translateOnAxis( v1, distance );
		};
	}(),
	translateZ: function () {
		var v1 = new Vector3( 0, 0, 1 );
		return function translateZ( distance ) {
			return this.translateOnAxis( v1, distance );
		};
	}(),
	localToWorld: function ( vector ) {
		return vector.applyMatrix4( this.matrixWorld );
	},
	worldToLocal: function () {
		var m1 = new Matrix4();
		return function worldToLocal( vector ) {
			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );
		};
	}(),
	lookAt: function () {
		var m1 = new Matrix4();
		var vector = new Vector3();
		return function lookAt( x, y, z ) {
			if ( x.isVector3 ) {
				vector.copy( x );
			} else {
				vector.set( x, y, z );
			}
			if ( this.isCamera ) {
				m1.lookAt( this.position, vector, this.up );
			} else {
				m1.lookAt( vector, this.position, this.up );
			}
			this.quaternion.setFromRotationMatrix( m1 );
		};
	}(),
	add: function ( object ) {
		if ( arguments.length > 1 ) {
			for ( var i = 0; i < arguments.length; i ++ ) {
				this.add( arguments[ i ] );
			}
			return this;
		}
		if ( object === this ) {
			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
			return this;
		}
		if ( ( object && object.isObject3D ) ) {
			if ( object.parent !== null ) {
				object.parent.remove( object );
			}
			object.parent = this;
			object.dispatchEvent( { type: 'added' } );
			this.children.push( object );
		} else {
			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );
		}
		return this;
	},
	remove: function ( object ) {
		if ( arguments.length > 1 ) {
			for ( var i = 0; i < arguments.length; i ++ ) {
				this.remove( arguments[ i ] );
			}
			return this;
		}
		var index = this.children.indexOf( object );
		if ( index !== - 1 ) {
			object.parent = null;
			object.dispatchEvent( { type: 'removed' } );
			this.children.splice( index, 1 );
		}
		return this;
	},
	getObjectById: function ( id ) {
		return this.getObjectByProperty( 'id', id );
	},
	getObjectByName: function ( name ) {
		return this.getObjectByProperty( 'name', name );
	},
	getObjectByProperty: function ( name, value ) {
		if ( this[ name ] === value ) return this;
		for ( var i = 0, l = this.children.length; i < l; i ++ ) {
			var child = this.children[ i ];
			var object = child.getObjectByProperty( name, value );
			if ( object !== undefined ) {
				return object;
			}
		}
		return undefined;
	},
	getWorldPosition: function ( optionalTarget ) {
		var result = optionalTarget || new Vector3();
		this.updateMatrixWorld( true );
		return result.setFromMatrixPosition( this.matrixWorld );
	},
	getWorldQuaternion: function () {
		var position = new Vector3();
		var scale = new Vector3();
		return function getWorldQuaternion( optionalTarget ) {
			var result = optionalTarget || new Quaternion();
			this.updateMatrixWorld( true );
			this.matrixWorld.decompose( position, result, scale );
			return result;
		};
	}(),
	getWorldRotation: function () {
		var quaternion = new Quaternion();
		return function getWorldRotation( optionalTarget ) {
			var result = optionalTarget || new Euler();
			this.getWorldQuaternion( quaternion );
			return result.setFromQuaternion( quaternion, this.rotation.order, false );
		};
	}(),
	getWorldScale: function () {
		var position = new Vector3();
		var quaternion = new Quaternion();
		return function getWorldScale( optionalTarget ) {
			var result = optionalTarget || new Vector3();
			this.updateMatrixWorld( true );
			this.matrixWorld.decompose( position, quaternion, result );
			return result;
		};
	}(),
	getWorldDirection: function () {
		var quaternion = new Quaternion();
		return function getWorldDirection( optionalTarget ) {
			var result = optionalTarget || new Vector3();
			this.getWorldQuaternion( quaternion );
			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );
		};
	}(),
	raycast: function () {},
	traverse: function ( callback ) {
		callback( this );
		var children = this.children;
		for ( var i = 0, l = children.length; i < l; i ++ ) {
			children[ i ].traverse( callback );
		}
	},
	traverseVisible: function ( callback ) {
		if ( this.visible === false ) return;
		callback( this );
		var children = this.children;
		for ( var i = 0, l = children.length; i < l; i ++ ) {
			children[ i ].traverseVisible( callback );
		}
	},
	traverseAncestors: function ( callback ) {
		var parent = this.parent;
		if ( parent !== null ) {
			callback( parent );
			parent.traverseAncestors( callback );
		}
	},
	updateMatrix: function () {
		this.matrix.compose( this.position, this.quaternion, this.scale );
		this.matrixWorldNeedsUpdate = true;
	},
	updateMatrixWorld: function ( force ) {
		if ( this.matrixAutoUpdate ) this.updateMatrix();
		if ( this.matrixWorldNeedsUpdate || force ) {
			if ( this.parent === null ) {
				this.matrixWorld.copy( this.matrix );
			} else {
				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
			}
			this.matrixWorldNeedsUpdate = false;
			force = true;
		}
		var children = this.children;
		for ( var i = 0, l = children.length; i < l; i ++ ) {
			children[ i ].updateMatrixWorld( force );
		}
	},
	toJSON: function ( meta ) {
		var isRootObject = ( meta === undefined || typeof meta === 'string' );
		var output = {};
		if ( isRootObject ) {
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {}
			};
			output.metadata = {
				version: 4.5,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};
		}
		var object = {};
		object.uuid = this.uuid;
		object.type = this.type;
		if ( this.name !== '' ) object.name = this.name;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
		object.matrix = this.matrix.toArray();
		function serialize( library, element ) {
			if ( library[ element.uuid ] === undefined ) {
				library[ element.uuid ] = element.toJSON( meta );
			}
			return element.uuid;
		}
		if ( this.geometry !== undefined ) {
			object.geometry = serialize( meta.geometries, this.geometry );
		}
		if ( this.material !== undefined ) {
			if ( Array.isArray( this.material ) ) {
				var uuids = [];
				for ( var i = 0, l = this.material.length; i < l; i ++ ) {
					uuids.push( serialize( meta.materials, this.material[ i ] ) );
				}
				object.material = uuids;
			} else {
				object.material = serialize( meta.materials, this.material );
			}
		}
		if ( this.children.length > 0 ) {
			object.children = [];
			for ( var i = 0; i < this.children.length; i ++ ) {
				object.children.push( this.children[ i ].toJSON( meta ).object );
			}
		}
		if ( isRootObject ) {
			var geometries = extractFromCache( meta.geometries );
			var materials = extractFromCache( meta.materials );
			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );
			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;
		}
		output.object = object;
		return output;
		function extractFromCache( cache ) {
			var values = [];
			for ( var key in cache ) {
				var data = cache[ key ];
				delete data.metadata;
				values.push( data );
			}
			return values;
		}
	},
	clone: function ( recursive ) {
		return new this.constructor().copy( this, recursive );
	},
	copy: function ( source, recursive ) {
		if ( recursive === undefined ) recursive = true;
		this.name = source.name;
		this.up.copy( source.up );
		this.position.copy( source.position );
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );
		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );
		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
		this.layers.mask = source.layers.mask;
		this.visible = source.visible;
		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;
		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;
		this.userData = JSON.parse( JSON.stringify( source.userData ) );
		if ( recursive === true ) {
			for ( var i = 0; i < source.children.length; i ++ ) {
				var child = source.children[ i ];
				this.add( child.clone() );
			}
		}
		return this;
	}
} );
function Camera() {
	Object3D.call( this );
	this.type = 'Camera';
	this.matrixWorldInverse = new Matrix4();
	this.projectionMatrix = new Matrix4();
}
Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {
	constructor: Camera,
	isCamera: true,
	copy: function ( source, recursive ) {
		Object3D.prototype.copy.call( this, source, recursive );
		this.matrixWorldInverse.copy( source.matrixWorldInverse );
		this.projectionMatrix.copy( source.projectionMatrix );
		return this;
	},
	getWorldDirection: function () {
		var quaternion = new Quaternion();
		return function getWorldDirection( optionalTarget ) {
			var result = optionalTarget || new Vector3();
			this.getWorldQuaternion( quaternion );
			return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );
		};
	}(),
	updateMatrixWorld: function ( force ) {
		Object3D.prototype.updateMatrixWorld.call( this, force );
		this.matrixWorldInverse.getInverse( this.matrixWorld );
	},
	clone: function () {
		return new this.constructor().copy( this );
	}
} );
function OrthographicCamera( left, right, top, bottom, near, far ) {
	Camera.call( this );
	this.type = 'OrthographicCamera';
	this.zoom = 1;
	this.view = null;
	this.left = left;
	this.right = right;
	this.top = top;
	this.bottom = bottom;
	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;
	this.updateProjectionMatrix();
}
OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {
	constructor: OrthographicCamera,
	isOrthographicCamera: true,
	copy: function ( source, recursive ) {
		Camera.prototype.copy.call( this, source, recursive );
		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;
		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );
		return this;
	},
	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {
		if ( this.view === null ) {
			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};
		}
		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;
		this.updateProjectionMatrix();
	},
	clearViewOffset: function () {
		if ( this.view !== null ) {
			this.view.enabled = false;
		}
		this.updateProjectionMatrix();
	},
	updateProjectionMatrix: function () {
		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		var cx = ( this.right + this.left ) / 2;
		var cy = ( this.top + this.bottom ) / 2;
		var left = cx - dx;
		var right = cx + dx;
		var top = cy + dy;
		var bottom = cy - dy;
		if ( this.view !== null && this.view.enabled ) {
			var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
			var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
			var scaleW = ( this.right - this.left ) / this.view.width;
			var scaleH = ( this.top - this.bottom ) / this.view.height;
			left += scaleW * ( this.view.offsetX / zoomW );
			right = left + scaleW * ( this.view.width / zoomW );
			top -= scaleH * ( this.view.offsetY / zoomH );
			bottom = top - scaleH * ( this.view.height / zoomH );
		}
		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );
	},
	toJSON: function ( meta ) {
		var data = Object3D.prototype.toJSON.call( this, meta );
		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;
		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
		return data;
	}
} );
function Face3( a, b, c, normal, color, materialIndex ) {
	this.a = a;
	this.b = b;
	this.c = c;
	this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
	this.vertexNormals = Array.isArray( normal ) ? normal : [];
	this.color = ( color && color.isColor ) ? color : new Color();
	this.vertexColors = Array.isArray( color ) ? color : [];
	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
}
Object.assign( Face3.prototype, {
	clone: function () {
		return new this.constructor().copy( this );
	},
	copy: function ( source ) {
		this.a = source.a;
		this.b = source.b;
		this.c = source.c;
		this.normal.copy( source.normal );
		this.color.copy( source.color );
		this.materialIndex = source.materialIndex;
		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {
			this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();
		}
		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {
			this.vertexColors[ i ] = source.vertexColors[ i ].clone();
		}
		return this;
	}
} );
var geometryId = 0;
function Geometry() {
	Object.defineProperty( this, 'id', { value: geometryId += 2 } );
	this.uuid = _Math.generateUUID();
	this.name = '';
	this.type = 'Geometry';
	this.vertices = [];
	this.colors = [];
	this.faces = [];
	this.faceVertexUvs = [[]];
	this.morphTargets = [];
	this.morphNormals = [];
	this.skinWeights = [];
	this.skinIndices = [];
	this.lineDistances = [];
	this.boundingBox = null;
	this.boundingSphere = null;
	this.elementsNeedUpdate = false;
	this.verticesNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;
	this.groupsNeedUpdate = false;
}
Object.assign( Geometry.prototype, EventDispatcher.prototype, {
	isGeometry: true,
	applyMatrix: function ( matrix ) {
		var normalMatrix = new Matrix3().getNormalMatrix( matrix );
		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {
			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );
		}
		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {
			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();
			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();
			}
		}
		if ( this.boundingBox !== null ) {
			this.computeBoundingBox();
		}
		if ( this.boundingSphere !== null ) {
			this.computeBoundingSphere();
		}
		this.verticesNeedUpdate = true;
		this.normalsNeedUpdate = true;
		return this;
	},
	rotateX: function () {
		var m1 = new Matrix4();
		return function rotateX( angle ) {
			m1.makeRotationX( angle );
			this.applyMatrix( m1 );
			return this;
		};
	}(),
	rotateY: function () {
		var m1 = new Matrix4();
		return function rotateY( angle ) {
			m1.makeRotationY( angle );
			this.applyMatrix( m1 );
			return this;
		};
	}(),
	rotateZ: function () {
		var m1 = new Matrix4();
		return function rotateZ( angle ) {
			m1.makeRotationZ( angle );
			this.applyMatrix( m1 );
			return this;
		};
	}(),
	translate: function () {
		var m1 = new Matrix4();
		return function translate( x, y, z ) {
			m1.makeTranslation( x, y, z );
			this.applyMatrix( m1 );
			return this;
		};
	}(),
	scale: function () {
		var m1 = new Matrix4();
		return function scale( x, y, z ) {
			m1.makeScale( x, y, z );
			this.applyMatrix( m1 );
			return this;
		};
	}(),
	lookAt: function () {
		var obj = new Object3D();
		return function lookAt( vector ) {
			obj.lookAt( vector );
			obj.updateMatrix();
			this.applyMatrix( obj.matrix );
		};
	}(),
	fromBufferGeometry: function ( geometry ) {
		var scope = this;
		var indices = geometry.index !== null ? geometry.index.array : undefined;
		var attributes = geometry.attributes;
		var positions = attributes.position.array;
		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
		if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];
		var tempNormals = [];
		var tempUVs = [];
		var tempUVs2 = [];
		for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {
			scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );
			if ( normals !== undefined ) {
				tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );
			}
			if ( colors !== undefined ) {
				scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );
			}
			if ( uvs !== undefined ) {
				tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );
			}
			if ( uvs2 !== undefined ) {
				tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );
			}
		}
		function addFace( a, b, c, materialIndex ) {
			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];
			var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );
			scope.faces.push( face );
			if ( uvs !== undefined ) {
				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );
			}
			if ( uvs2 !== undefined ) {
				scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );
			}
		}
		var groups = geometry.groups;
		if ( groups.length > 0 ) {
			for ( var i = 0; i < groups.length; i ++ ) {
				var group = groups[ i ];
				var start = group.start;
				var count = group.count;
				for ( var j = start, jl = start + count; j < jl; j += 3 ) {
					if ( indices !== undefined ) {
						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );
					} else {
						addFace( j, j + 1, j + 2, group.materialIndex );
					}
				}
			}
		} else {
			if ( indices !== undefined ) {
				for ( var i = 0; i < indices.length; i += 3 ) {
					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );
				}
			} else {
				for ( var i = 0; i < positions.length / 3; i += 3 ) {
					addFace( i, i + 1, i + 2 );
				}
			}
		}
		this.computeFaceNormals();
		if ( geometry.boundingBox !== null ) {
			this.boundingBox = geometry.boundingBox.clone();
		}
		if ( geometry.boundingSphere !== null ) {
			this.boundingSphere = geometry.boundingSphere.clone();
		}
		return this;
	},
	center: function () {
		this.computeBoundingBox();
		var offset = this.boundingBox.getCenter().negate();
		this.translate( offset.x, offset.y, offset.z );
		return offset;
	},
	normalize: function () {
		this.computeBoundingSphere();
		var center = this.boundingSphere.center;
		var radius = this.boundingSphere.radius;
		var s = radius === 0 ? 1 : 1.0 / radius;
		var matrix = new Matrix4();
		matrix.set(
			s, 0, 0, - s * center.x,
			0, s, 0, - s * center.y,
			0, 0, s, - s * center.z,
			0, 0, 0, 1
		);
		this.applyMatrix( matrix );
		return this;
	},
	computeFaceNormals: function () {
		var cb = new Vector3(), ab = new Vector3();
		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {
			var face = this.faces[ f ];
			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];
			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );
			cb.normalize();
			face.normal.copy( cb );
		}
	},
	computeVertexNormals: function ( areaWeighted ) {
		if ( areaWeighted === undefined ) areaWeighted = true;
		var v, vl, f, fl, face, vertices;
		vertices = new Array( this.vertices.length );
		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
			vertices[ v ] = new Vector3();
		}
		if ( areaWeighted ) {
			var vA, vB, vC;
			var cb = new Vector3(), ab = new Vector3();
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
				face = this.faces[ f ];
				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];
				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );
				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );
			}
		} else {
			this.computeFaceNormals();
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
				face = this.faces[ f ];
				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );
			}
		}
		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
			vertices[ v ].normalize();
		}
		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
			face = this.faces[ f ];
			var vertexNormals = face.vertexNormals;
			if ( vertexNormals.length === 3 ) {
				vertexNormals[ 0 ].copy( vertices[ face.a ] );
				vertexNormals[ 1 ].copy( vertices[ face.b ] );
				vertexNormals[ 2 ].copy( vertices[ face.c ] );
			} else {
				vertexNormals[ 0 ] = vertices[ face.a ].clone();
				vertexNormals[ 1 ] = vertices[ face.b ].clone();
				vertexNormals[ 2 ] = vertices[ face.c ].clone();
			}
		}
		if ( this.faces.length > 0 ) {
			this.normalsNeedUpdate = true;
		}
	},
	computeFlatVertexNormals: function () {
		var f, fl, face;
		this.computeFaceNormals();
		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
			face = this.faces[ f ];
			var vertexNormals = face.vertexNormals;
			if ( vertexNormals.length === 3 ) {
				vertexNormals[ 0 ].copy( face.normal );
				vertexNormals[ 1 ].copy( face.normal );
				vertexNormals[ 2 ].copy( face.normal );
			} else {
				vertexNormals[ 0 ] = face.normal.clone();
				vertexNormals[ 1 ] = face.normal.clone();
				vertexNormals[ 2 ] = face.normal.clone();
			}
		}
		if ( this.faces.length > 0 ) {
			this.normalsNeedUpdate = true;
		}
	},
	computeMorphNormals: function () {
		var i, il, f, fl, face;
		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
			face = this.faces[ f ];
			if ( ! face.__originalFaceNormal ) {
				face.__originalFaceNormal = face.normal.clone();
			} else {
				face.__originalFaceNormal.copy( face.normal );
			}
			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];
			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {
				if ( ! face.__originalVertexNormals[ i ] ) {
					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();
				} else {
					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );
				}
			}
		}
		var tmpGeo = new Geometry();
		tmpGeo.faces = this.faces;
		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {
			if ( ! this.morphNormals[ i ] ) {
				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];
				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;
				var faceNormal, vertexNormals;
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
					faceNormal = new Vector3();
					vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };
					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );
				}
			}
			var morphNormals = this.morphNormals[ i ];
			tmpGeo.vertices = this.morphTargets[ i ].vertices;
			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();
			var faceNormal, vertexNormals;
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
				face = this.faces[ f ];
				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];
				faceNormal.copy( face.normal );
				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );
			}
		}
		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
			face = this.faces[ f ];
			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;
		}
	},
	computeLineDistances: function () {
		var d = 0;
		var vertices = this.vertices;
		for ( var i = 0, il = vertices.length; i < il; i ++ ) {
			if ( i > 0 ) {
				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );
			}
			this.lineDistances[ i ] = d;
		}
	},
	computeBoundingBox: function () {
		if ( this.boundingBox === null ) {
			this.boundingBox = new Box3();
		}
		this.boundingBox.setFromPoints( this.vertices );
	},
	computeBoundingSphere: function () {
		if ( this.boundingSphere === null ) {
			this.boundingSphere = new Sphere();
		}
		this.boundingSphere.setFromPoints( this.vertices );
	},
	merge: function ( geometry, matrix, materialIndexOffset ) {
		if ( ! ( geometry && geometry.isGeometry ) ) {
			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
			return;
		}
		var normalMatrix,
			vertexOffset = this.vertices.length,
			vertices1 = this.vertices,
			vertices2 = geometry.vertices,
			faces1 = this.faces,
			faces2 = geometry.faces,
			uvs1 = this.faceVertexUvs[ 0 ],
			uvs2 = geometry.faceVertexUvs[ 0 ],
			colors1 = this.colors,
			colors2 = geometry.colors;
		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;
		if ( matrix !== undefined ) {
			normalMatrix = new Matrix3().getNormalMatrix( matrix );
		}
		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {
			var vertex = vertices2[ i ];
			var vertexCopy = vertex.clone();
			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );
			vertices1.push( vertexCopy );
		}
		for ( var i = 0, il = colors2.length; i < il; i ++ ) {
			colors1.push( colors2[ i ].clone() );
		}
		for ( i = 0, il = faces2.length; i < il; i ++ ) {
			var face = faces2[ i ], faceCopy, normal, color,
				faceVertexNormals = face.vertexNormals,
				faceVertexColors = face.vertexColors;
			faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );
			if ( normalMatrix !== undefined ) {
				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();
			}
			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {
				normal = faceVertexNormals[ j ].clone();
				if ( normalMatrix !== undefined ) {
					normal.applyMatrix3( normalMatrix ).normalize();
				}
				faceCopy.vertexNormals.push( normal );
			}
			faceCopy.color.copy( face.color );
			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {
				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );
			}
			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
			faces1.push( faceCopy );
		}
		for ( i = 0, il = uvs2.length; i < il; i ++ ) {
			var uv = uvs2[ i ], uvCopy = [];
			if ( uv === undefined ) {
				continue;
			}
			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {
				uvCopy.push( uv[ j ].clone() );
			}
			uvs1.push( uvCopy );
		}
	},
	mergeMesh: function ( mesh ) {
		if ( ! ( mesh && mesh.isMesh ) ) {
			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
			return;
		}
		mesh.matrixAutoUpdate && mesh.updateMatrix();
		this.merge( mesh.geometry, mesh.matrix );
	},
	mergeVertices: function () {
		var verticesMap = {};
		var unique = [], changes = [];
		var v, key;
		var precisionPoints = 4;
		var precision = Math.pow( 10, precisionPoints );
		var i, il, face;
		var indices, j, jl;
		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {
			v = this.vertices[ i ];
			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );
			if ( verticesMap[ key ] === undefined ) {
				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;
			} else {
				changes[ i ] = changes[ verticesMap[ key ] ];
			}
		}
		var faceIndicesToRemove = [];
		for ( i = 0, il = this.faces.length; i < il; i ++ ) {
			face = this.faces[ i ];
			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];
			indices = [ face.a, face.b, face.c ];
			for ( var n = 0; n < 3; n ++ ) {
				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {
					faceIndicesToRemove.push( i );
					break;
				}
			}
		}
		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
			var idx = faceIndicesToRemove[ i ];
			this.faces.splice( idx, 1 );
			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {
				this.faceVertexUvs[ j ].splice( idx, 1 );
			}
		}
		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;
	},
	setFromPoints: function ( points ) {
		this.vertices = [];
		for ( var i = 0, l = points.length; i < l; i ++ ) {
			var point = points[ i ];
			this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );
		}
		return this;
	},
	sortFacesByMaterialIndex: function () {
		var faces = this.faces;
		var length = faces.length;
		for ( var i = 0; i < length; i ++ ) {
			faces[ i ]._id = i;
		}
		function materialIndexSort( a, b ) {
			return a.materialIndex - b.materialIndex;
		}
		faces.sort( materialIndexSort );
		var uvs1 = this.faceVertexUvs[ 0 ];
		var uvs2 = this.faceVertexUvs[ 1 ];
		var newUvs1, newUvs2;
		if ( uvs1 && uvs1.length === length ) newUvs1 = [];
		if ( uvs2 && uvs2.length === length ) newUvs2 = [];
		for ( var i = 0; i < length; i ++ ) {
			var id = faces[ i ]._id;
			if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
			if ( newUvs2 ) newUvs2.push( uvs2[ id ] );
		}
		if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
		if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;
	},
	toJSON: function () {
		var data = {
			metadata: {
				version: 4.5,
				type: 'Geometry',
				generator: 'Geometry.toJSON'
			}
		};
		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;
		if ( this.parameters !== undefined ) {
			var parameters = this.parameters;
			for ( var key in parameters ) {
				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
			}
			return data;
		}
		var vertices = [];
		for ( var i = 0; i < this.vertices.length; i ++ ) {
			var vertex = this.vertices[ i ];
			vertices.push( vertex.x, vertex.y, vertex.z );
		}
		var faces = [];
		var normals = [];
		var normalsHash = {};
		var colors = [];
		var colorsHash = {};
		var uvs = [];
		var uvsHash = {};
		for ( var i = 0; i < this.faces.length; i ++ ) {
			var face = this.faces[ i ];
			var hasMaterial = true;
			var hasFaceUv = false;
			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
			var hasFaceNormal = face.normal.length() > 0;
			var hasFaceVertexNormal = face.vertexNormals.length > 0;
			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
			var hasFaceVertexColor = face.vertexColors.length > 0;
			var faceType = 0;
			faceType = setBit( faceType, 0, 0 );
			faceType = setBit( faceType, 1, hasMaterial );
			faceType = setBit( faceType, 2, hasFaceUv );
			faceType = setBit( faceType, 3, hasFaceVertexUv );
			faceType = setBit( faceType, 4, hasFaceNormal );
			faceType = setBit( faceType, 5, hasFaceVertexNormal );
			faceType = setBit( faceType, 6, hasFaceColor );
			faceType = setBit( faceType, 7, hasFaceVertexColor );
			faces.push( faceType );
			faces.push( face.a, face.b, face.c );
			faces.push( face.materialIndex );
			if ( hasFaceVertexUv ) {
				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];
				faces.push(
					getUvIndex( faceVertexUvs[ 0 ] ),
					getUvIndex( faceVertexUvs[ 1 ] ),
					getUvIndex( faceVertexUvs[ 2 ] )
				);
			}
			if ( hasFaceNormal ) {
				faces.push( getNormalIndex( face.normal ) );
			}
			if ( hasFaceVertexNormal ) {
				var vertexNormals = face.vertexNormals;
				faces.push(
					getNormalIndex( vertexNormals[ 0 ] ),
					getNormalIndex( vertexNormals[ 1 ] ),
					getNormalIndex( vertexNormals[ 2 ] )
				);
			}
			if ( hasFaceColor ) {
				faces.push( getColorIndex( face.color ) );
			}
			if ( hasFaceVertexColor ) {
				var vertexColors = face.vertexColors;
				faces.push(
					getColorIndex( vertexColors[ 0 ] ),
					getColorIndex( vertexColors[ 1 ] ),
					getColorIndex( vertexColors[ 2 ] )
				);
			}
		}
		function setBit( value, position, enabled ) {
			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );
		}
		function getNormalIndex( normal ) {
			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
			if ( normalsHash[ hash ] !== undefined ) {
				return normalsHash[ hash ];
			}
			normalsHash[ hash ] = normals.length / 3;
			normals.push( normal.x, normal.y, normal.z );
			return normalsHash[ hash ];
		}
		function getColorIndex( color ) {
			var hash = color.r.toString() + color.g.toString() + color.b.toString();
			if ( colorsHash[ hash ] !== undefined ) {
				return colorsHash[ hash ];
			}
			colorsHash[ hash ] = colors.length;
			colors.push( color.getHex() );
			return colorsHash[ hash ];
		}
		function getUvIndex( uv ) {
			var hash = uv.x.toString() + uv.y.toString();
			if ( uvsHash[ hash ] !== undefined ) {
				return uvsHash[ hash ];
			}
			uvsHash[ hash ] = uvs.length / 2;
			uvs.push( uv.x, uv.y );
			return uvsHash[ hash ];
		}
		data.data = {};
		data.data.vertices = vertices;
		data.data.normals = normals;
		if ( colors.length > 0 ) data.data.colors = colors;
		if ( uvs.length > 0 ) data.data.uvs = [ uvs ];
		data.data.faces = faces;
		return data;
	},
	clone: function () {
		return new Geometry().copy( this );
	},
	copy: function ( source ) {
		var i, il, j, jl, k, kl;
		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [[]];
		this.morphTargets = [];
		this.morphNormals = [];
		this.skinWeights = [];
		this.skinIndices = [];
		this.lineDistances = [];
		this.boundingBox = null;
		this.boundingSphere = null;
		this.name = source.name;
		var vertices = source.vertices;
		for ( i = 0, il = vertices.length; i < il; i ++ ) {
			this.vertices.push( vertices[ i ].clone() );
		}
		var colors = source.colors;
		for ( i = 0, il = colors.length; i < il; i ++ ) {
			this.colors.push( colors[ i ].clone() );
		}
		var faces = source.faces;
		for ( i = 0, il = faces.length; i < il; i ++ ) {
			this.faces.push( faces[ i ].clone() );
		}
		for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {
			var faceVertexUvs = source.faceVertexUvs[ i ];
			if ( this.faceVertexUvs[ i ] === undefined ) {
				this.faceVertexUvs[ i ] = [];
			}
			for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {
				var uvs = faceVertexUvs[ j ], uvsCopy = [];
				for ( k = 0, kl = uvs.length; k < kl; k ++ ) {
					var uv = uvs[ k ];
					uvsCopy.push( uv.clone() );
				}
				this.faceVertexUvs[ i ].push( uvsCopy );
			}
		}
		var morphTargets = source.morphTargets;
		for ( i = 0, il = morphTargets.length; i < il; i ++ ) {
			var morphTarget = {};
			morphTarget.name = morphTargets[ i ].name;
			if ( morphTargets[ i ].vertices !== undefined ) {
				morphTarget.vertices = [];
				for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {
					morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );
				}
			}
			if ( morphTargets[ i ].normals !== undefined ) {
				morphTarget.normals = [];
				for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {
					morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );
				}
			}
			this.morphTargets.push( morphTarget );
		}
		var morphNormals = source.morphNormals;
		for ( i = 0, il = morphNormals.length; i < il; i ++ ) {
			var morphNormal = {};
			if ( morphNormals[ i ].vertexNormals !== undefined ) {
				morphNormal.vertexNormals = [];
				for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {
					var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
					var destVertexNormal = {};
					destVertexNormal.a = srcVertexNormal.a.clone();
					destVertexNormal.b = srcVertexNormal.b.clone();
					destVertexNormal.c = srcVertexNormal.c.clone();
					morphNormal.vertexNormals.push( destVertexNormal );
				}
			}
			if ( morphNormals[ i ].faceNormals !== undefined ) {
				morphNormal.faceNormals = [];
				for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {
					morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );
				}
			}
			this.morphNormals.push( morphNormal );
		}
		var skinWeights = source.skinWeights;
		for ( i = 0, il = skinWeights.length; i < il; i ++ ) {
			this.skinWeights.push( skinWeights[ i ].clone() );
		}
		var skinIndices = source.skinIndices;
		for ( i = 0, il = skinIndices.length; i < il; i ++ ) {
			this.skinIndices.push( skinIndices[ i ].clone() );
		}
		var lineDistances = source.lineDistances;
		for ( i = 0, il = lineDistances.length; i < il; i ++ ) {
			this.lineDistances.push( lineDistances[ i ] );
		}
		var boundingBox = source.boundingBox;
		if ( boundingBox !== null ) {
			this.boundingBox = boundingBox.clone();
		}
		var boundingSphere = source.boundingSphere;
		if ( boundingSphere !== null ) {
			this.boundingSphere = boundingSphere.clone();
		}
		this.elementsNeedUpdate = source.elementsNeedUpdate;
		this.verticesNeedUpdate = source.verticesNeedUpdate;
		this.uvsNeedUpdate = source.uvsNeedUpdate;
		this.normalsNeedUpdate = source.normalsNeedUpdate;
		this.colorsNeedUpdate = source.colorsNeedUpdate;
		this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
		this.groupsNeedUpdate = source.groupsNeedUpdate;
		return this;
	},
	dispose: function () {
		this.dispatchEvent( { type: 'dispose' } );
	}
} );
function BufferAttribute( array, itemSize, normalized ) {
	if ( Array.isArray( array ) ) {
		throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
	}
	this.uuid = _Math.generateUUID();
	this.name = '';
	this.array = array;
	this.itemSize = itemSize;
	this.count = array !== undefined ? array.length / itemSize : 0;
	this.normalized = normalized === true;
	this.dynamic = false;
	this.updateRange = { offset: 0, count: - 1 };
	this.onUploadCallback = function () {};
	this.version = 0;
}
Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {
	set: function ( value ) {
		if ( value === true ) this.version ++;
	}
} );
Object.assign( BufferAttribute.prototype, {
	isBufferAttribute: true,
	setArray: function ( array ) {
		if ( Array.isArray( array ) ) {
			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
		}
		this.count = array !== undefined ? array.length / this.itemSize : 0;
		this.array = array;
	},
	setDynamic: function ( value ) {
		this.dynamic = value;
		return this;
	},
	copy: function ( source ) {
		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;
		this.dynamic = source.dynamic;
		return this;
	},
	copyAt: function ( index1, attribute, index2 ) {
		index1 *= this.itemSize;
		index2 *= attribute.itemSize;
		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {
			this.array[ index1 + i ] = attribute.array[ index2 + i ];
		}
		return this;
	},
	copyArray: function ( array ) {
		this.array.set( array );
		return this;
	},
	copyColorsArray: function ( colors ) {
		var array = this.array, offset = 0;
		for ( var i = 0, l = colors.length; i < l; i ++ ) {
			var color = colors[ i ];
			if ( color === undefined ) {
				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				color = new Color();
			}
			array[ offset ++ ] = color.r;
			array[ offset ++ ] = color.g;
			array[ offset ++ ] = color.b;
		}
		return this;
	},
	copyIndicesArray: function ( indices ) {
		var array = this.array, offset = 0;
		for ( var i = 0, l = indices.length; i < l; i ++ ) {
			var index = indices[ i ];
			array[ offset ++ ] = index.a;
			array[ offset ++ ] = index.b;
			array[ offset ++ ] = index.c;
		}
		return this;
	},
	copyVector2sArray: function ( vectors ) {
		var array = this.array, offset = 0;
		for ( var i = 0, l = vectors.length; i < l; i ++ ) {
			var vector = vectors[ i ];
			if ( vector === undefined ) {
				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				vector = new Vector2();
			}
			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
		}
		return this;
	},
	copyVector3sArray: function ( vectors ) {
		var array = this.array, offset = 0;
		for ( var i = 0, l = vectors.length; i < l; i ++ ) {
			var vector = vectors[ i ];
			if ( vector === undefined ) {
				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				vector = new Vector3();
			}
			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
		}
		return this;
	},
	copyVector4sArray: function ( vectors ) {
		var array = this.array, offset = 0;
		for ( var i = 0, l = vectors.length; i < l; i ++ ) {
			var vector = vectors[ i ];
			if ( vector === undefined ) {
				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				vector = new Vector4();
			}
			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
			array[ offset ++ ] = vector.w;
		}
		return this;
	},
	set: function ( value, offset ) {
		if ( offset === undefined ) offset = 0;
		this.array.set( value, offset );
		return this;
	},
	getX: function ( index ) {
		return this.array[ index * this.itemSize ];
	},
	setX: function ( index, x ) {
		this.array[ index * this.itemSize ] = x;
		return this;
	},
	getY: function ( index ) {
		return this.array[ index * this.itemSize + 1 ];
	},
	setY: function ( index, y ) {
		this.array[ index * this.itemSize + 1 ] = y;
		return this;
	},
	getZ: function ( index ) {
		return this.array[ index * this.itemSize + 2 ];
	},
	setZ: function ( index, z ) {
		this.array[ index * this.itemSize + 2 ] = z;
		return this;
	},
	getW: function ( index ) {
		return this.array[ index * this.itemSize + 3 ];
	},
	setW: function ( index, w ) {
		this.array[ index * this.itemSize + 3 ] = w;
		return this;
	},
	setXY: function ( index, x, y ) {
		index *= this.itemSize;
		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		return this;
	},
	setXYZ: function ( index, x, y, z ) {
		index *= this.itemSize;
		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		return this;
	},
	setXYZW: function ( index, x, y, z, w ) {
		index *= this.itemSize;
		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;
		return this;
	},
	onUpload: function ( callback ) {
		this.onUploadCallback = callback;
		return this;
	},
	clone: function () {
		return new this.constructor( this.array, this.itemSize ).copy( this );
	}
} );
function Int8BufferAttribute( array, itemSize, normalized ) {
	BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );
}
Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
function Uint8BufferAttribute( array, itemSize, normalized ) {
	BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );
}
Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {
	BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );
}
Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
function Int16BufferAttribute( array, itemSize, normalized ) {
	BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );
}
Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
function Uint16BufferAttribute( array, itemSize, normalized ) {
	BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );
}
Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
function Int32BufferAttribute( array, itemSize, normalized ) {
	BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );
}
Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
function Uint32BufferAttribute( array, itemSize, normalized ) {
	BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );
}
Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
function Float32BufferAttribute( array, itemSize, normalized ) {
	BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );
}
Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
function Float64BufferAttribute( array, itemSize, normalized ) {
	BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );
}
Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
function DirectGeometry() {
	this.indices = [];
	this.vertices = [];
	this.normals = [];
	this.colors = [];
	this.uvs = [];
	this.uvs2 = [];
	this.groups = [];
	this.morphTargets = {};
	this.skinWeights = [];
	this.skinIndices = [];
	this.boundingBox = null;
	this.boundingSphere = null;
	this.verticesNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.groupsNeedUpdate = false;
}
Object.assign( DirectGeometry.prototype, {
	computeGroups: function ( geometry ) {
		var group;
		var groups = [];
		var materialIndex = undefined;
		var faces = geometry.faces;
		for ( var i = 0; i < faces.length; i ++ ) {
			var face = faces[ i ];
			if ( face.materialIndex !== materialIndex ) {
				materialIndex = face.materialIndex;
				if ( group !== undefined ) {
					group.count = ( i * 3 ) - group.start;
					groups.push( group );
				}
				group = {
					start: i * 3,
					materialIndex: materialIndex
				};
			}
		}
		if ( group !== undefined ) {
			group.count = ( i * 3 ) - group.start;
			groups.push( group );
		}
		this.groups = groups;
	},
	fromGeometry: function ( geometry ) {
		var faces = geometry.faces;
		var vertices = geometry.vertices;
		var faceVertexUvs = geometry.faceVertexUvs;
		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;
		var morphTargets = geometry.morphTargets;
		var morphTargetsLength = morphTargets.length;
		var morphTargetsPosition;
		if ( morphTargetsLength > 0 ) {
			morphTargetsPosition = [];
			for ( var i = 0; i < morphTargetsLength; i ++ ) {
				morphTargetsPosition[ i ] = [];
			}
			this.morphTargets.position = morphTargetsPosition;
		}
		var morphNormals = geometry.morphNormals;
		var morphNormalsLength = morphNormals.length;
		var morphTargetsNormal;
		if ( morphNormalsLength > 0 ) {
			morphTargetsNormal = [];
			for ( var i = 0; i < morphNormalsLength; i ++ ) {
				morphTargetsNormal[ i ] = [];
			}
			this.morphTargets.normal = morphTargetsNormal;
		}
		var skinIndices = geometry.skinIndices;
		var skinWeights = geometry.skinWeights;
		var hasSkinIndices = skinIndices.length === vertices.length;
		var hasSkinWeights = skinWeights.length === vertices.length;
		for ( var i = 0; i < faces.length; i ++ ) {
			var face = faces[ i ];
			this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );
			var vertexNormals = face.vertexNormals;
			if ( vertexNormals.length === 3 ) {
				this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );
			} else {
				var normal = face.normal;
				this.normals.push( normal, normal, normal );
			}
			var vertexColors = face.vertexColors;
			if ( vertexColors.length === 3 ) {
				this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );
			} else {
				var color = face.color;
				this.colors.push( color, color, color );
			}
			if ( hasFaceVertexUv === true ) {
				var vertexUvs = faceVertexUvs[ 0 ][ i ];
				if ( vertexUvs !== undefined ) {
					this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
				} else {
					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );
					this.uvs.push( new Vector2(), new Vector2(), new Vector2() );
				}
			}
			if ( hasFaceVertexUv2 === true ) {
				var vertexUvs = faceVertexUvs[ 1 ][ i ];
				if ( vertexUvs !== undefined ) {
					this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
				} else {
					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );
					this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );
				}
			}
			for ( var j = 0; j < morphTargetsLength; j ++ ) {
				var morphTarget = morphTargets[ j ].vertices;
				morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );
			}
			for ( var j = 0; j < morphNormalsLength; j ++ ) {
				var morphNormal = morphNormals[ j ].vertexNormals[ i ];
				morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );
			}
			if ( hasSkinIndices ) {
				this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );
			}
			if ( hasSkinWeights ) {
				this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );
			}
		}
		this.computeGroups( geometry );
		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
		this.groupsNeedUpdate = geometry.groupsNeedUpdate;
		return this;
	}
} );
function arrayMax( array ) {
	if ( array.length === 0 ) return - Infinity;
	var max = array[ 0 ];
	for ( var i = 1, l = array.length; i < l; ++ i ) {
		if ( array[ i ] > max ) max = array[ i ];
	}
	return max;
}
var bufferGeometryId = 1;
function BufferGeometry() {
	Object.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );
	this.uuid = _Math.generateUUID();
	this.name = '';
	this.type = 'BufferGeometry';
	this.index = null;
	this.attributes = {};
	this.morphAttributes = {};
	this.groups = [];
	this.boundingBox = null;
	this.boundingSphere = null;
	this.drawRange = { start: 0, count: Infinity };
}
Object.assign( BufferGeometry.prototype, EventDispatcher.prototype, {
	isBufferGeometry: true,
	getIndex: function () {
		return this.index;
	},
	setIndex: function ( index ) {
		if ( Array.isArray( index ) ) {
			this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );
		} else {
			this.index = index;
		}
	},
	addAttribute: function ( name, attribute ) {
		if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {
			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );
			this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );
			return;
		}
		if ( name === 'index' ) {
			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
			this.setIndex( attribute );
			return;
		}
		this.attributes[ name ] = attribute;
		return this;
	},
	getAttribute: function ( name ) {
		return this.attributes[ name ];
	},
	removeAttribute: function ( name ) {
		delete this.attributes[ name ];
		return this;
	},
	addGroup: function ( start, count, materialIndex ) {
		this.groups.push( {
			start: start,
			count: count,
			materialIndex: materialIndex !== undefined ? materialIndex : 0
		} );
	},
	clearGroups: function () {
		this.groups = [];
	},
	setDrawRange: function ( start, count ) {
		this.drawRange.start = start;
		this.drawRange.count = count;
	},
	applyMatrix: function ( matrix ) {
		var position = this.attributes.position;
		if ( position !== undefined ) {
			matrix.applyToBufferAttribute( position );
			position.needsUpdate = true;
		}
		var normal = this.attributes.normal;
		if ( normal !== undefined ) {
			var normalMatrix = new Matrix3().getNormalMatrix( matrix );
			normalMatrix.applyToBufferAttribute( normal );
			normal.needsUpdate = true;
		}
		if ( this.boundingBox !== null ) {
			this.computeBoundingBox();
		}
		if ( this.boundingSphere !== null ) {
			this.computeBoundingSphere();
		}
		return this;
	},
	rotateX: function () {
		var m1 = new Matrix4();
		return function rotateX( angle ) {
			m1.makeRotationX( angle );
			this.applyMatrix( m1 );
			return this;
		};
	}(),
	rotateY: function () {
		var m1 = new Matrix4();
		return function rotateY( angle ) {
			m1.makeRotationY( angle );
			this.applyMatrix( m1 );
			return this;
		};
	}(),
	rotateZ: function () {
		var m1 = new Matrix4();
		return function rotateZ( angle ) {
			m1.makeRotationZ( angle );
			this.applyMatrix( m1 );
			return this;
		};
	}(),
	translate: function () {
		var m1 = new Matrix4();
		return function translate( x, y, z ) {
			m1.makeTranslation( x, y, z );
			this.applyMatrix( m1 );
			return this;
		};
	}(),
	scale: function () {
		var m1 = new Matrix4();
		return function scale( x, y, z ) {
			m1.makeScale( x, y, z );
			this.applyMatrix( m1 );
			return this;
		};
	}(),
	lookAt: function () {
		var obj = new Object3D();
		return function lookAt( vector ) {
			obj.lookAt( vector );
			obj.updateMatrix();
			this.applyMatrix( obj.matrix );
		};
	}(),
	center: function () {
		this.computeBoundingBox();
		var offset = this.boundingBox.getCenter().negate();
		this.translate( offset.x, offset.y, offset.z );
		return offset;
	},
	setFromObject: function ( object ) {
		var geometry = object.geometry;
		if ( object.isPoints || object.isLine ) {
			var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
			var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );
			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );
			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {
				var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );
				this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );
			}
			if ( geometry.boundingSphere !== null ) {
				this.boundingSphere = geometry.boundingSphere.clone();
			}
			if ( geometry.boundingBox !== null ) {
				this.boundingBox = geometry.boundingBox.clone();
			}
		} else if ( object.isMesh ) {
			if ( geometry && geometry.isGeometry ) {
				this.fromGeometry( geometry );
			}
		}
		return this;
	},
	setFromPoints: function ( points ) {
		var position = [];
		for ( var i = 0, l = points.length; i < l; i ++ ) {
			var point = points[ i ];
			position.push( point.x, point.y, point.z || 0 );
		}
		this.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );
		return this;
	},
	updateFromObject: function ( object ) {
		var geometry = object.geometry;
		if ( object.isMesh ) {
			var direct = geometry.__directGeometry;
			if ( geometry.elementsNeedUpdate === true ) {
				direct = undefined;
				geometry.elementsNeedUpdate = false;
			}
			if ( direct === undefined ) {
				return this.fromGeometry( geometry );
			}
			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
			geometry.verticesNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.groupsNeedUpdate = false;
			geometry = direct;
		}
		var attribute;
		if ( geometry.verticesNeedUpdate === true ) {
			attribute = this.attributes.position;
			if ( attribute !== undefined ) {
				attribute.copyVector3sArray( geometry.vertices );
				attribute.needsUpdate = true;
			}
			geometry.verticesNeedUpdate = false;
		}
		if ( geometry.normalsNeedUpdate === true ) {
			attribute = this.attributes.normal;
			if ( attribute !== undefined ) {
				attribute.copyVector3sArray( geometry.normals );
				attribute.needsUpdate = true;
			}
			geometry.normalsNeedUpdate = false;
		}
		if ( geometry.colorsNeedUpdate === true ) {
			attribute = this.attributes.color;
			if ( attribute !== undefined ) {
				attribute.copyColorsArray( geometry.colors );
				attribute.needsUpdate = true;
			}
			geometry.colorsNeedUpdate = false;
		}
		if ( geometry.uvsNeedUpdate ) {
			attribute = this.attributes.uv;
			if ( attribute !== undefined ) {
				attribute.copyVector2sArray( geometry.uvs );
				attribute.needsUpdate = true;
			}
			geometry.uvsNeedUpdate = false;
		}
		if ( geometry.lineDistancesNeedUpdate ) {
			attribute = this.attributes.lineDistance;
			if ( attribute !== undefined ) {
				attribute.copyArray( geometry.lineDistances );
				attribute.needsUpdate = true;
			}
			geometry.lineDistancesNeedUpdate = false;
		}
		if ( geometry.groupsNeedUpdate ) {
			geometry.computeGroups( object.geometry );
			this.groups = geometry.groups;
			geometry.groupsNeedUpdate = false;
		}
		return this;
	},
	fromGeometry: function ( geometry ) {
		geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );
		return this.fromDirectGeometry( geometry.__directGeometry );
	},
	fromDirectGeometry: function ( geometry ) {
		var positions = new Float32Array( geometry.vertices.length * 3 );
		this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );
		if ( geometry.normals.length > 0 ) {
			var normals = new Float32Array( geometry.normals.length * 3 );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );
		}
		if ( geometry.colors.length > 0 ) {
			var colors = new Float32Array( geometry.colors.length * 3 );
			this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );
		}
		if ( geometry.uvs.length > 0 ) {
			var uvs = new Float32Array( geometry.uvs.length * 2 );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );
		}
		if ( geometry.uvs2.length > 0 ) {
			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
			this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );
		}
		if ( geometry.indices.length > 0 ) {
			var TypeArray = arrayMax( geometry.indices ) > 65535 ? Uint32Array : Uint16Array;
			var indices = new TypeArray( geometry.indices.length * 3 );
			this.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );
		}
		this.groups = geometry.groups;
		for ( var name in geometry.morphTargets ) {
			var array = [];
			var morphTargets = geometry.morphTargets[ name ];
			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {
				var morphTarget = morphTargets[ i ];
				var attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );
				array.push( attribute.copyVector3sArray( morphTarget ) );
			}
			this.morphAttributes[ name ] = array;
		}
		if ( geometry.skinIndices.length > 0 ) {
			var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );
		}
		if ( geometry.skinWeights.length > 0 ) {
			var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );
		}
		if ( geometry.boundingSphere !== null ) {
			this.boundingSphere = geometry.boundingSphere.clone();
		}
		if ( geometry.boundingBox !== null ) {
			this.boundingBox = geometry.boundingBox.clone();
		}
		return this;
	},
	computeBoundingBox: function () {
		if ( this.boundingBox === null ) {
			this.boundingBox = new Box3();
		}
		var position = this.attributes.position;
		if ( position !== undefined ) {
			this.boundingBox.setFromBufferAttribute( position );
		} else {
			this.boundingBox.makeEmpty();
		}
		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {
			console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );
		}
	},
	computeBoundingSphere: function () {
		var box = new Box3();
		var vector = new Vector3();
		return function computeBoundingSphere() {
			if ( this.boundingSphere === null ) {
				this.boundingSphere = new Sphere();
			}
			var position = this.attributes.position;
			if ( position ) {
				var center = this.boundingSphere.center;
				box.setFromBufferAttribute( position );
				box.getCenter( center );
				var maxRadiusSq = 0;
				for ( var i = 0, il = position.count; i < il; i ++ ) {
					vector.x = position.getX( i );
					vector.y = position.getY( i );
					vector.z = position.getZ( i );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );
				}
				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );
				if ( isNaN( this.boundingSphere.radius ) ) {
					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );
				}
			}
		};
	}(),
	computeFaceNormals: function () {
	},
	computeVertexNormals: function () {
		var index = this.index;
		var attributes = this.attributes;
		var groups = this.groups;
		if ( attributes.position ) {
			var positions = attributes.position.array;
			if ( attributes.normal === undefined ) {
				this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );
			} else {
				var array = attributes.normal.array;
				for ( var i = 0, il = array.length; i < il; i ++ ) {
					array[ i ] = 0;
				}
			}
			var normals = attributes.normal.array;
			var vA, vB, vC;
			var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			var cb = new Vector3(), ab = new Vector3();
			if ( index ) {
				var indices = index.array;
				if ( groups.length === 0 ) {
					this.addGroup( 0, indices.length );
				}
				for ( var j = 0, jl = groups.length; j < jl; ++ j ) {
					var group = groups[ j ];
					var start = group.start;
					var count = group.count;
					for ( var i = start, il = start + count; i < il; i += 3 ) {
						vA = indices[ i + 0 ] * 3;
						vB = indices[ i + 1 ] * 3;
						vC = indices[ i + 2 ] * 3;
						pA.fromArray( positions, vA );
						pB.fromArray( positions, vB );
						pC.fromArray( positions, vC );
						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );
						normals[ vA ] += cb.x;
						normals[ vA + 1 ] += cb.y;
						normals[ vA + 2 ] += cb.z;
						normals[ vB ] += cb.x;
						normals[ vB + 1 ] += cb.y;
						normals[ vB + 2 ] += cb.z;
						normals[ vC ] += cb.x;
						normals[ vC + 1 ] += cb.y;
						normals[ vC + 2 ] += cb.z;
					}
				}
			} else {
				for ( var i = 0, il = positions.length; i < il; i += 9 ) {
					pA.fromArray( positions, i );
					pB.fromArray( positions, i + 3 );
					pC.fromArray( positions, i + 6 );
					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );
					normals[ i ] = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;
					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;
					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;
				}
			}
			this.normalizeNormals();
			attributes.normal.needsUpdate = true;
		}
	},
	merge: function ( geometry, offset ) {
		if ( ! ( geometry && geometry.isBufferGeometry ) ) {
			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			return;
		}
		if ( offset === undefined ) offset = 0;
		var attributes = this.attributes;
		for ( var key in attributes ) {
			if ( geometry.attributes[ key ] === undefined ) continue;
			var attribute1 = attributes[ key ];
			var attributeArray1 = attribute1.array;
			var attribute2 = geometry.attributes[ key ];
			var attributeArray2 = attribute2.array;
			var attributeSize = attribute2.itemSize;
			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {
				attributeArray1[ j ] = attributeArray2[ i ];
			}
		}
		return this;
	},
	normalizeNormals: function () {
		var vector = new Vector3();
		return function normalizeNormals() {
			var normals = this.attributes.normal;
			for ( var i = 0, il = normals.count; i < il; i ++ ) {
				vector.x = normals.getX( i );
				vector.y = normals.getY( i );
				vector.z = normals.getZ( i );
				vector.normalize();
				normals.setXYZ( i, vector.x, vector.y, vector.z );
			}
		};
	}(),
	toNonIndexed: function () {
		if ( this.index === null ) {
			console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
			return this;
		}
		var geometry2 = new BufferGeometry();
		var indices = this.index.array;
		var attributes = this.attributes;
		for ( var name in attributes ) {
			var attribute = attributes[ name ];
			var array = attribute.array;
			var itemSize = attribute.itemSize;
			var array2 = new array.constructor( indices.length * itemSize );
			var index = 0, index2 = 0;
			for ( var i = 0, l = indices.length; i < l; i ++ ) {
				index = indices[ i ] * itemSize;
				for ( var j = 0; j < itemSize; j ++ ) {
					array2[ index2 ++ ] = array[ index ++ ];
				}
			}
			geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );
		}
		return geometry2;
	},
	toJSON: function () {
		var data = {
			metadata: {
				version: 4.5,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};
		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;
		if ( this.parameters !== undefined ) {
			var parameters = this.parameters;
			for ( var key in parameters ) {
				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
			}
			return data;
		}
		data.data = { attributes: {} };
		var index = this.index;
		if ( index !== null ) {
			var array = Array.prototype.slice.call( index.array );
			data.data.index = {
				type: index.array.constructor.name,
				array: array
			};
		}
		var attributes = this.attributes;
		for ( var key in attributes ) {
			var attribute = attributes[ key ];
			var array = Array.prototype.slice.call( attribute.array );
			data.data.attributes[ key ] = {
				itemSize: attribute.itemSize,
				type: attribute.array.constructor.name,
				array: array,
				normalized: attribute.normalized
			};
		}
		var groups = this.groups;
		if ( groups.length > 0 ) {
			data.data.groups = JSON.parse( JSON.stringify( groups ) );
		}
		var boundingSphere = this.boundingSphere;
		if ( boundingSphere !== null ) {
			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};
		}
		return data;
	},
	clone: function () {
		return new BufferGeometry().copy( this );
	},
	copy: function ( source ) {
		var name, i, l;
		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;
		this.name = source.name;
		var index = source.index;
		if ( index !== null ) {
			this.setIndex( index.clone() );
		}
		var attributes = source.attributes;
		for ( name in attributes ) {
			var attribute = attributes[ name ];
			this.addAttribute( name, attribute.clone() );
		}
		var morphAttributes = source.morphAttributes;
		for ( name in morphAttributes ) {
			var array = [];
			var morphAttribute = morphAttributes[ name ];
			for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {
				array.push( morphAttribute[ i ].clone() );
			}
			this.morphAttributes[ name ] = array;
		}
		var groups = source.groups;
		for ( i = 0, l = groups.length; i < l; i ++ ) {
			var group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );
		}
		var boundingBox = source.boundingBox;
		if ( boundingBox !== null ) {
			this.boundingBox = boundingBox.clone();
		}
		var boundingSphere = source.boundingSphere;
		if ( boundingSphere !== null ) {
			this.boundingSphere = boundingSphere.clone();
		}
		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;
		return this;
	},
	dispose: function () {
		this.dispatchEvent( { type: 'dispose' } );
	}
} );
function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	Geometry.call( this );
	this.type = 'BoxGeometry';
	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};
	this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
	this.mergeVertices();
}
BoxGeometry.prototype = Object.create( Geometry.prototype );
BoxGeometry.prototype.constructor = BoxGeometry;
function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	BufferGeometry.call( this );
	this.type = 'BoxBufferGeometry';
	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};
	var scope = this;
	width = width || 1;
	height = height || 1;
	depth = depth || 1;
	widthSegments = Math.floor( widthSegments ) || 1;
	heightSegments = Math.floor( heightSegments ) || 1;
	depthSegments = Math.floor( depthSegments ) || 1;
	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];
	var numberOfVertices = 0;
	var groupStart = 0;
	buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 );
	buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 );
	buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 );
	buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 );
	buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 );
	buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 );
	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {
		var segmentWidth = width / gridX;
		var segmentHeight = height / gridY;
		var widthHalf = width / 2;
		var heightHalf = height / 2;
		var depthHalf = depth / 2;
		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;
		var vertexCounter = 0;
		var groupCount = 0;
		var ix, iy;
		var vector = new Vector3();
		for ( iy = 0; iy < gridY1; iy ++ ) {
			var y = iy * segmentHeight - heightHalf;
			for ( ix = 0; ix < gridX1; ix ++ ) {
				var x = ix * segmentWidth - widthHalf;
				vector[ u ] = x * udir;
				vector[ v ] = y * vdir;
				vector[ w ] = depthHalf;
				vertices.push( vector.x, vector.y, vector.z );
				vector[ u ] = 0;
				vector[ v ] = 0;
				vector[ w ] = depth > 0 ? 1 : - 1;
				normals.push( vector.x, vector.y, vector.z );
				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );
				vertexCounter += 1;
			}
		}
		for ( iy = 0; iy < gridY; iy ++ ) {
			for ( ix = 0; ix < gridX; ix ++ ) {
				var a = numberOfVertices + ix + gridX1 * iy;
				var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
				var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;
				indices.push( a, b, d );
				indices.push( b, c, d );
				groupCount += 6;
			}
		}
		scope.addGroup( groupStart, groupCount, materialIndex );
		groupStart += groupCount;
		numberOfVertices += vertexCounter;
	}
}
BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;
function PlaneGeometry( width, height, widthSegments, heightSegments ) {
	Geometry.call( this );
	this.type = 'PlaneGeometry';
	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};
	this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
	this.mergeVertices();
}
PlaneGeometry.prototype = Object.create( Geometry.prototype );
PlaneGeometry.prototype.constructor = PlaneGeometry;
function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {
	BufferGeometry.call( this );
	this.type = 'PlaneBufferGeometry';
	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};
	width = width || 1;
	height = height || 1;
	var width_half = width / 2;
	var height_half = height / 2;
	var gridX = Math.floor( widthSegments ) || 1;
	var gridY = Math.floor( heightSegments ) || 1;
	var gridX1 = gridX + 1;
	var gridY1 = gridY + 1;
	var segment_width = width / gridX;
	var segment_height = height / gridY;
	var ix, iy;
	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];
	for ( iy = 0; iy < gridY1; iy ++ ) {
		var y = iy * segment_height - height_half;
		for ( ix = 0; ix < gridX1; ix ++ ) {
			var x = ix * segment_width - width_half;
			vertices.push( x, - y, 0 );
			normals.push( 0, 0, 1 );
			uvs.push( ix / gridX );
			uvs.push( 1 - ( iy / gridY ) );
		}
	}
	for ( iy = 0; iy < gridY; iy ++ ) {
		for ( ix = 0; ix < gridX; ix ++ ) {
			var a = ix + gridX1 * iy;
			var b = ix + gridX1 * ( iy + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
			var d = ( ix + 1 ) + gridX1 * iy;
			indices.push( a, b, d );
			indices.push( b, c, d );
		}
	}
	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
}
PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
function MeshBasicMaterial( parameters ) {
	Material.call( this );
	this.type = 'MeshBasicMaterial';
	this.color = new Color( 0xffffff );
	this.map = null;
	this.lightMap = null;
	this.lightMapIntensity = 1.0;
	this.aoMap = null;
	this.aoMapIntensity = 1.0;
	this.specularMap = null;
	this.alphaMap = null;
	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;
	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';
	this.skinning = false;
	this.morphTargets = false;
	this.lights = false;
	this.setValues( parameters );
}
MeshBasicMaterial.prototype = Object.create( Material.prototype );
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
MeshBasicMaterial.prototype.copy = function ( source ) {
	Material.prototype.copy.call( this, source );
	this.color.copy( source.color );
	this.map = source.map;
	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;
	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;
	this.specularMap = source.specularMap;
	this.alphaMap = source.alphaMap;
	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;
	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;
	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	return this;
};
function ShaderMaterial( parameters ) {
	Material.call( this );
	this.type = 'ShaderMaterial';
	this.defines = {};
	this.uniforms = {};
	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
	this.linewidth = 1;
	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.fog = false;
	this.lights = false;
	this.clipping = false;
	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;
	this.extensions = {
		derivatives: false,
		fragDepth: false,
		drawBuffers: false,
		shaderTextureLOD: false
	};
	this.defaultAttributeValues = {
		'color': [ 1, 1, 1 ],
		'uv': [ 0, 0 ],
		'uv2': [ 0, 0 ]
	};
	this.index0AttributeName = undefined;
	if ( parameters !== undefined ) {
		if ( parameters.attributes !== undefined ) {
			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );
		}
		this.setValues( parameters );
	}
}
ShaderMaterial.prototype = Object.create( Material.prototype );
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;
ShaderMaterial.prototype.copy = function ( source ) {
	Material.prototype.copy.call( this, source );
	this.fragmentShader = source.fragmentShader;
	this.vertexShader = source.vertexShader;
	this.uniforms = UniformsUtils.clone( source.uniforms );
	this.defines = source.defines;
	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.lights = source.lights;
	this.clipping = source.clipping;
	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;
	this.extensions = source.extensions;
	return this;
};
ShaderMaterial.prototype.toJSON = function ( meta ) {
	var data = Material.prototype.toJSON.call( this, meta );
	data.uniforms = this.uniforms;
	data.vertexShader = this.vertexShader;
	data.fragmentShader = this.fragmentShader;
	return data;
};
function Ray( origin, direction ) {
	this.origin = ( origin !== undefined ) ? origin : new Vector3();
	this.direction = ( direction !== undefined ) ? direction : new Vector3();
}
Object.assign( Ray.prototype, {
	set: function ( origin, direction ) {
		this.origin.copy( origin );
		this.direction.copy( direction );
		return this;
	},
	clone: function () {
		return new this.constructor().copy( this );
	},
	copy: function ( ray ) {
		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );
		return this;
	},
	at: function ( t, optionalTarget ) {
		var result = optionalTarget || new Vector3();
		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );
	},
	lookAt: function ( v ) {
		this.direction.copy( v ).sub( this.origin ).normalize();
		return this;
	},
	recast: function () {
		var v1 = new Vector3();
		return function recast( t ) {
			this.origin.copy( this.at( t, v1 ) );
			return this;
		};
	}(),
	closestPointToPoint: function ( point, optionalTarget ) {
		var result = optionalTarget || new Vector3();
		result.subVectors( point, this.origin );
		var directionDistance = result.dot( this.direction );
		if ( directionDistance < 0 ) {
			return result.copy( this.origin );
		}
		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	},
	distanceToPoint: function ( point ) {
		return Math.sqrt( this.distanceSqToPoint( point ) );
	},
	distanceSqToPoint: function () {
		var v1 = new Vector3();
		return function distanceSqToPoint( point ) {
			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );
			if ( directionDistance < 0 ) {
				return this.origin.distanceToSquared( point );
			}
			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
			return v1.distanceToSquared( point );
		};
	}(),
	distanceSqToSegment: function () {
		var segCenter = new Vector3();
		var segDir = new Vector3();
		var diff = new Vector3();
		return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {
			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
			segDir.copy( v1 ).sub( v0 ).normalize();
			diff.copy( this.origin ).sub( segCenter );
			var segExtent = v0.distanceTo( v1 ) * 0.5;
			var a01 = - this.direction.dot( segDir );
			var b0 = diff.dot( this.direction );
			var b1 = - diff.dot( segDir );
			var c = diff.lengthSq();
			var det = Math.abs( 1 - a01 * a01 );
			var s0, s1, sqrDist, extDet;
			if ( det > 0 ) {
				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;
				if ( s0 >= 0 ) {
					if ( s1 >= - extDet ) {
						if ( s1 <= extDet ) {
							var invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;
						} else {
							s1 = segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
						}
					} else {
						s1 = - segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
					}
				} else {
					if ( s1 <= - extDet ) {
						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
					} else if ( s1 <= extDet ) {
						s0 = 0;
						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = s1 * ( s1 + 2 * b1 ) + c;
					} else {
						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
					}
				}
			} else {
				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
			}
			if ( optionalPointOnRay ) {
				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );
			}
			if ( optionalPointOnSegment ) {
				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );
			}
			return sqrDist;
		};
	}(),
	intersectSphere: function () {
		var v1 = new Vector3();
		return function intersectSphere( sphere, optionalTarget ) {
			v1.subVectors( sphere.center, this.origin );
			var tca = v1.dot( this.direction );
			var d2 = v1.dot( v1 ) - tca * tca;
			var radius2 = sphere.radius * sphere.radius;
			if ( d2 > radius2 ) return null;
			var thc = Math.sqrt( radius2 - d2 );
			var t0 = tca - thc;
			var t1 = tca + thc;
			if ( t0 < 0 && t1 < 0 ) return null;
			if ( t0 < 0 ) return this.at( t1, optionalTarget );
			return this.at( t0, optionalTarget );
		};
	}(),
	intersectsSphere: function ( sphere ) {
		return this.distanceToPoint( sphere.center ) <= sphere.radius;
	},
	distanceToPlane: function ( plane ) {
		var denominator = plane.normal.dot( this.direction );
		if ( denominator === 0 ) {
			if ( plane.distanceToPoint( this.origin ) === 0 ) {
				return 0;
			}
			return null;
		}
		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;
		return t >= 0 ? t : null;
	},
	intersectPlane: function ( plane, optionalTarget ) {
		var t = this.distanceToPlane( plane );
		if ( t === null ) {
			return null;
		}
		return this.at( t, optionalTarget );
	},
	intersectsPlane: function ( plane ) {
		var distToPoint = plane.distanceToPoint( this.origin );
		if ( distToPoint === 0 ) {
			return true;
		}
		var denominator = plane.normal.dot( this.direction );
		if ( denominator * distToPoint < 0 ) {
			return true;
		}
		return false;
	},
	intersectBox: function ( box, optionalTarget ) {
		var tmin, tmax, tymin, tymax, tzmin, tzmax;
		var invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;
		var origin = this.origin;
		if ( invdirx >= 0 ) {
			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;
		} else {
			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;
		}
		if ( invdiry >= 0 ) {
			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;
		} else {
			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;
		}
		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;
		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;
		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;
		if ( invdirz >= 0 ) {
			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;
		} else {
			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;
		}
		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;
		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;
		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;
		if ( tmax < 0 ) return null;
		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );
	},
	intersectsBox: ( function () {
		var v = new Vector3();
		return function intersectsBox( box ) {
			return this.intersectBox( box, v ) !== null;
		};
	} )(),
	intersectTriangle: function () {
		var diff = new Vector3();
		var edge1 = new Vector3();
		var edge2 = new Vector3();
		var normal = new Vector3();
		return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {
			edge1.subVectors( b, a );
			edge2.subVectors( c, a );
			normal.crossVectors( edge1, edge2 );
			var DdN = this.direction.dot( normal );
			var sign;
			if ( DdN > 0 ) {
				if ( backfaceCulling ) return null;
				sign = 1;
			} else if ( DdN < 0 ) {
				sign = - 1;
				DdN = - DdN;
			} else {
				return null;
			}
			diff.subVectors( this.origin, a );
			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );
			if ( DdQxE2 < 0 ) {
				return null;
			}
			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );
			if ( DdE1xQ < 0 ) {
				return null;
			}
			if ( DdQxE2 + DdE1xQ > DdN ) {
				return null;
			}
			var QdN = - sign * diff.dot( normal );
			if ( QdN < 0 ) {
				return null;
			}
			return this.at( QdN / DdN, optionalTarget );
		};
	}(),
	applyMatrix4: function ( matrix4 ) {
		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );
		return this;
	},
	equals: function ( ray ) {
		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );
	}
} );
function Line3( start, end ) {
	this.start = ( start !== undefined ) ? start : new Vector3();
	this.end = ( end !== undefined ) ? end : new Vector3();
}
Object.assign( Line3.prototype, {
	set: function ( start, end ) {
		this.start.copy( start );
		this.end.copy( end );
		return this;
	},
	clone: function () {
		return new this.constructor().copy( this );
	},
	copy: function ( line ) {
		this.start.copy( line.start );
		this.end.copy( line.end );
		return this;
	},
	getCenter: function ( optionalTarget ) {
		var result = optionalTarget || new Vector3();
		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );
	},
	delta: function ( optionalTarget ) {
		var result = optionalTarget || new Vector3();
		return result.subVectors( this.end, this.start );
	},
	distanceSq: function () {
		return this.start.distanceToSquared( this.end );
	},
	distance: function () {
		return this.start.distanceTo( this.end );
	},
	at: function ( t, optionalTarget ) {
		var result = optionalTarget || new Vector3();
		return this.delta( result ).multiplyScalar( t ).add( this.start );
	},
	closestPointToPointParameter: function () {
		var startP = new Vector3();
		var startEnd = new Vector3();
		return function closestPointToPointParameter( point, clampToLine ) {
			startP.subVectors( point, this.start );
			startEnd.subVectors( this.end, this.start );
			var startEnd2 = startEnd.dot( startEnd );
			var startEnd_startP = startEnd.dot( startP );
			var t = startEnd_startP / startEnd2;
			if ( clampToLine ) {
				t = _Math.clamp( t, 0, 1 );
			}
			return t;
		};
	}(),
	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {
		var t = this.closestPointToPointParameter( point, clampToLine );
		var result = optionalTarget || new Vector3();
		return this.delta( result ).multiplyScalar( t ).add( this.start );
	},
	applyMatrix4: function ( matrix ) {
		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );
		return this;
	},
	equals: function ( line ) {
		return line.start.equals( this.start ) && line.end.equals( this.end );
	}
} );
function Triangle( a, b, c ) {
	this.a = ( a !== undefined ) ? a : new Vector3();
	this.b = ( b !== undefined ) ? b : new Vector3();
	this.c = ( c !== undefined ) ? c : new Vector3();
}
Object.assign( Triangle, {
	normal: function () {
		var v0 = new Vector3();
		return function normal( a, b, c, optionalTarget ) {
			var result = optionalTarget || new Vector3();
			result.subVectors( c, b );
			v0.subVectors( a, b );
			result.cross( v0 );
			var resultLengthSq = result.lengthSq();
			if ( resultLengthSq > 0 ) {
				return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );
			}
			return result.set( 0, 0, 0 );
		};
	}(),
	barycoordFromPoint: function () {
		var v0 = new Vector3();
		var v1 = new Vector3();
		var v2 = new Vector3();
		return function barycoordFromPoint( point, a, b, c, optionalTarget ) {
			v0.subVectors( c, a );
			v1.subVectors( b, a );
			v2.subVectors( point, a );
			var dot00 = v0.dot( v0 );
			var dot01 = v0.dot( v1 );
			var dot02 = v0.dot( v2 );
			var dot11 = v1.dot( v1 );
			var dot12 = v1.dot( v2 );
			var denom = ( dot00 * dot11 - dot01 * dot01 );
			var result = optionalTarget || new Vector3();
			if ( denom === 0 ) {
				return result.set( - 2, - 1, - 1 );
			}
			var invDenom = 1 / denom;
			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;
			return result.set( 1 - u - v, v, u );
		};
	}(),
	containsPoint: function () {
		var v1 = new Vector3();
		return function containsPoint( point, a, b, c ) {
			var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );
			return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );
		};
	}()
} );
Object.assign( Triangle.prototype, {
	set: function ( a, b, c ) {
		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );
		return this;
	},
	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {
		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );
		return this;
	},
	clone: function () {
		return new this.constructor().copy( this );
	},
	copy: function ( triangle ) {
		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );
		return this;
	},
	area: function () {
		var v0 = new Vector3();
		var v1 = new Vector3();
		return function area() {
			v0.subVectors( this.c, this.b );
			v1.subVectors( this.a, this.b );
			return v0.cross( v1 ).length() * 0.5;
		};
	}(),
	midpoint: function ( optionalTarget ) {
		var result = optionalTarget || new Vector3();
		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );
	},
	normal: function ( optionalTarget ) {
		return Triangle.normal( this.a, this.b, this.c, optionalTarget );
	},
	plane: function ( optionalTarget ) {
		var result = optionalTarget || new Plane();
		return result.setFromCoplanarPoints( this.a, this.b, this.c );
	},
	barycoordFromPoint: function ( point, optionalTarget ) {
		return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );
	},
	containsPoint: function ( point ) {
		return Triangle.containsPoint( point, this.a, this.b, this.c );
	},
	closestPointToPoint: function () {
		var plane = new Plane();
		var edgeList = [ new Line3(), new Line3(), new Line3() ];
		var projectedPoint = new Vector3();
		var closestPoint = new Vector3();
		return function closestPointToPoint( point, optionalTarget ) {
			var result = optionalTarget || new Vector3();
			var minDistance = Infinity;
			plane.setFromCoplanarPoints( this.a, this.b, this.c );
			plane.projectPoint( point, projectedPoint );
			if ( this.containsPoint( projectedPoint ) === true ) {
				result.copy( projectedPoint );
			} else {
				edgeList[ 0 ].set( this.a, this.b );
				edgeList[ 1 ].set( this.b, this.c );
				edgeList[ 2 ].set( this.c, this.a );
				for ( var i = 0; i < edgeList.length; i ++ ) {
					edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );
					var distance = projectedPoint.distanceToSquared( closestPoint );
					if ( distance < minDistance ) {
						minDistance = distance;
						result.copy( closestPoint );
					}
				}
			}
			return result;
		};
	}(),
	equals: function ( triangle ) {
		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );
	}
} );
function Mesh( geometry, material ) {
	Object3D.call( this );
	this.type = 'Mesh';
	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );
	this.drawMode = TrianglesDrawMode;
	this.updateMorphTargets();
}
Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {
	constructor: Mesh,
	isMesh: true,
	setDrawMode: function ( value ) {
		this.drawMode = value;
	},
	copy: function ( source ) {
		Object3D.prototype.copy.call( this, source );
		this.drawMode = source.drawMode;
		if ( source.morphTargetInfluences !== undefined ) {
			this.morphTargetInfluences = source.morphTargetInfluences.slice();
		}
		if ( source.morphTargetDictionary !== undefined ) {
			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );
		}
		return this;
	},
	updateMorphTargets: function () {
		var geometry = this.geometry;
		var m, ml, name;
		if ( geometry.isBufferGeometry ) {
			var morphAttributes = geometry.morphAttributes;
			var keys = Object.keys( morphAttributes );
			if ( keys.length > 0 ) {
				var morphAttribute = morphAttributes[ keys[ 0 ] ];
				if ( morphAttribute !== undefined ) {
					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};
					for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {
						name = morphAttribute[ m ].name || String( m );
						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;
					}
				}
			}
		} else {
			var morphTargets = geometry.morphTargets;
			if ( morphTargets !== undefined && morphTargets.length > 0 ) {
				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};
				for ( m = 0, ml = morphTargets.length; m < ml; m ++ ) {
					name = morphTargets[ m ].name || String( m );
					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;
				}
			}
		}
	},
	raycast: ( function () {
		var inverseMatrix = new Matrix4();
		var ray = new Ray();
		var sphere = new Sphere();
		var vA = new Vector3();
		var vB = new Vector3();
		var vC = new Vector3();
		var tempA = new Vector3();
		var tempB = new Vector3();
		var tempC = new Vector3();
		var uvA = new Vector2();
		var uvB = new Vector2();
		var uvC = new Vector2();
		var barycoord = new Vector3();
		var intersectionPoint = new Vector3();
		var intersectionPointWorld = new Vector3();
		function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {
			Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );
			uv1.multiplyScalar( barycoord.x );
			uv2.multiplyScalar( barycoord.y );
			uv3.multiplyScalar( barycoord.z );
			uv1.add( uv2 ).add( uv3 );
			return uv1.clone();
		}
		function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {
			var intersect;
			if ( material.side === BackSide ) {
				intersect = ray.intersectTriangle( pC, pB, pA, true, point );
			} else {
				intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );
			}
			if ( intersect === null ) return null;
			intersectionPointWorld.copy( point );
			intersectionPointWorld.applyMatrix4( object.matrixWorld );
			var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );
			if ( distance < raycaster.near || distance > raycaster.far ) return null;
			return {
				distance: distance,
				point: intersectionPointWorld.clone(),
				object: object
			};
		}
		function checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {
			vA.fromBufferAttribute( position, a );
			vB.fromBufferAttribute( position, b );
			vC.fromBufferAttribute( position, c );
			var intersection = checkIntersection( object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint );
			if ( intersection ) {
				if ( uv ) {
					uvA.fromBufferAttribute( uv, a );
					uvB.fromBufferAttribute( uv, b );
					uvC.fromBufferAttribute( uv, c );
					intersection.uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );
				}
				intersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );
				intersection.faceIndex = a;
			}
			return intersection;
		}
		return function raycast( raycaster, intersects ) {
			var geometry = this.geometry;
			var material = this.material;
			var matrixWorld = this.matrixWorld;
			if ( material === undefined ) return;
			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );
			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
			if ( geometry.boundingBox !== null ) {
				if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;
			}
			var intersection;
			if ( geometry.isBufferGeometry ) {
				var a, b, c;
				var index = geometry.index;
				var position = geometry.attributes.position;
				var uv = geometry.attributes.uv;
				var i, l;
				if ( index !== null ) {
					for ( i = 0, l = index.count; i < l; i += 3 ) {
						a = index.getX( i );
						b = index.getX( i + 1 );
						c = index.getX( i + 2 );
						intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );
						if ( intersection ) {
							intersection.faceIndex = Math.floor( i / 3 );
							intersects.push( intersection );
						}
					}
				} else if ( position !== undefined ) {
					for ( i = 0, l = position.count; i < l; i += 3 ) {
						a = i;
						b = i + 1;
						c = i + 2;
						intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );
						if ( intersection ) {
							intersection.index = a;
							intersects.push( intersection );
						}
					}
				}
			} else if ( geometry.isGeometry ) {
				var fvA, fvB, fvC;
				var isMultiMaterial = Array.isArray( material );
				var vertices = geometry.vertices;
				var faces = geometry.faces;
				var uvs;
				var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
				if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;
				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {
					var face = faces[ f ];
					var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;
					if ( faceMaterial === undefined ) continue;
					fvA = vertices[ face.a ];
					fvB = vertices[ face.b ];
					fvC = vertices[ face.c ];
					if ( faceMaterial.morphTargets === true ) {
						var morphTargets = geometry.morphTargets;
						var morphInfluences = this.morphTargetInfluences;
						vA.set( 0, 0, 0 );
						vB.set( 0, 0, 0 );
						vC.set( 0, 0, 0 );
						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {
							var influence = morphInfluences[ t ];
							if ( influence === 0 ) continue;
							var targets = morphTargets[ t ].vertices;
							vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
							vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
							vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );
						}
						vA.add( fvA );
						vB.add( fvB );
						vC.add( fvC );
						fvA = vA;
						fvB = vB;
						fvC = vC;
					}
					intersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );
					if ( intersection ) {
						if ( uvs && uvs[ f ] ) {
							var uvs_f = uvs[ f ];
							uvA.copy( uvs_f[ 0 ] );
							uvB.copy( uvs_f[ 1 ] );
							uvC.copy( uvs_f[ 2 ] );
							intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );
						}
						intersection.face = face;
						intersection.faceIndex = f;
						intersects.push( intersection );
					}
				}
			}
		};
	}() ),
	clone: function () {
		return new this.constructor( this.geometry, this.material ).copy( this );
	}
} );
function WebGLBackground( renderer, state, geometries, premultipliedAlpha ) {
	var clearColor = new Color( 0x000000 );
	var clearAlpha = 0;
	var planeCamera, planeMesh;
	var boxMesh;
	function render( renderList, scene, camera, forceClear ) {
		var background = scene.background;
		if ( background === null ) {
			setClear( clearColor, clearAlpha );
		} else if ( background && background.isColor ) {
			setClear( background, 1 );
			forceClear = true;
		}
		if ( renderer.autoClear || forceClear ) {
			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
		}
		if ( background && background.isCubeTexture ) {
			if ( boxMesh === undefined ) {
				boxMesh = new Mesh(
					new BoxBufferGeometry( 1, 1, 1 ),
					new ShaderMaterial( {
						uniforms: ShaderLib.cube.uniforms,
						vertexShader: ShaderLib.cube.vertexShader,
						fragmentShader: ShaderLib.cube.fragmentShader,
						side: BackSide,
						depthTest: true,
						depthWrite: false,
						fog: false
					} )
				);
				boxMesh.geometry.removeAttribute( 'normal' );
				boxMesh.geometry.removeAttribute( 'uv' );
				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {
					this.matrixWorld.copyPosition( camera.matrixWorld );
				};
				geometries.update( boxMesh.geometry );
			}
			boxMesh.material.uniforms.tCube.value = background;
			renderList.push( boxMesh, boxMesh.geometry, boxMesh.material, 0, null );
		} else if ( background && background.isTexture ) {
			if ( planeCamera === undefined ) {
				planeCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
				planeMesh = new Mesh(
					new PlaneBufferGeometry( 2, 2 ),
					new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
				);
				geometries.update( planeMesh.geometry );
			}
			planeMesh.material.map = background;
			renderer.renderBufferDirect( planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null );
		}
	}
	function setClear( color, alpha ) {
		state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );
	}
	return {
		getClearColor: function () {
			return clearColor;
		},
		setClearColor: function ( color, alpha ) {
			clearColor.set( color );
			clearAlpha = alpha !== undefined ? alpha : 1;
			setClear( clearColor, clearAlpha );
		},
		getClearAlpha: function () {
			return clearAlpha;
		},
		setClearAlpha: function ( alpha ) {
			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );
		},
		render: render
	};
}
function painterSortStable( a, b ) {
	if ( a.renderOrder !== b.renderOrder ) {
		return a.renderOrder - b.renderOrder;
	} else if ( a.program && b.program && a.program !== b.program ) {
		return a.program.id - b.program.id;
	} else if ( a.material.id !== b.material.id ) {
		return a.material.id - b.material.id;
	} else if ( a.z !== b.z ) {
		return a.z - b.z;
	} else {
		return a.id - b.id;
	}
}
function reversePainterSortStable( a, b ) {
	if ( a.renderOrder !== b.renderOrder ) {
		return a.renderOrder - b.renderOrder;
	} if ( a.z !== b.z ) {
		return b.z - a.z;
	} else {
		return a.id - b.id;
	}
}
function WebGLRenderList() {
	var renderItems = [];
	var renderItemsIndex = 0;
	var opaque = [];
	var transparent = [];
	function init() {
		renderItemsIndex = 0;
		opaque.length = 0;
		transparent.length = 0;
	}
	function push( object, geometry, material, z, group ) {
		var renderItem = renderItems[ renderItemsIndex ];
		if ( renderItem === undefined ) {
			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				program: material.program,
				renderOrder: object.renderOrder,
				z: z,
				group: group
			};
			renderItems[ renderItemsIndex ] = renderItem;
		} else {
			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.program = material.program;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;
		}
		( material.transparent === true ? transparent : opaque ).push( renderItem );
		renderItemsIndex ++;
	}
	function sort() {
		if ( opaque.length > 1 ) opaque.sort( painterSortStable );
		if ( transparent.length > 1 ) transparent.sort( reversePainterSortStable );
	}
	return {
		opaque: opaque,
		transparent: transparent,
		init: init,
		push: push,
		sort: sort
	};
}
function WebGLRenderLists() {
	var lists = {};
	function get( scene, camera ) {
		var hash = scene.id + ',' + camera.id;
		var list = lists[ hash ];
		if ( list === undefined ) {
			list = new WebGLRenderList();
			lists[ hash ] = list;
		}
		return list;
	}
	function dispose() {
		lists = {};
	}
	return {
		get: get,
		dispose: dispose
	};
}
function absNumericalSort( a, b ) {
	return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );
}
function WebGLMorphtargets( gl ) {
	var influencesList = {};
	var morphInfluences = new Float32Array( 8 );
	function update( object, geometry, material, program ) {
		var objectInfluences = object.morphTargetInfluences;
		var length = objectInfluences.length;
		var influences = influencesList[ geometry.id ];
		if ( influences === undefined ) {
			influences = [];
			for ( var i = 0; i < length; i ++ ) {
				influences[ i ] = [ i, 0 ];
			}
			influencesList[ geometry.id ] = influences;
		}
		var morphTargets = material.morphTargets && geometry.morphAttributes.position;
		var morphNormals = material.morphNormals && geometry.morphAttributes.normal;
		for ( var i = 0; i < length; i ++ ) {
			var influence = influences[ i ];
			if ( influence[ 1 ] !== 0 ) {
				if ( morphTargets ) geometry.removeAttribute( 'morphTarget' + i );
				if ( morphNormals ) geometry.removeAttribute( 'morphNormal' + i );
			}
		}
		for ( var i = 0; i < length; i ++ ) {
			var influence = influences[ i ];
			influence[ 0 ] = i;
			influence[ 1 ] = objectInfluences[ i ];
		}
		influences.sort( absNumericalSort );
		for ( var i = 0; i < 8; i ++ ) {
			var influence = influences[ i ];
			if ( influence ) {
				var index = influence[ 0 ];
				var value = influence[ 1 ];
				if ( value ) {
					if ( morphTargets ) geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] );
					if ( morphNormals ) geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] );
					morphInfluences[ i ] = value;
					continue;
				}
			}
			morphInfluences[ i ] = 0;
		}
		program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );
	}
	return {
		update: update
	};
}
function WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {
	var mode;
	function setMode( value ) {
		mode = value;
	}
	var type, bytesPerElement;
	function setIndex( value ) {
		type = value.type;
		bytesPerElement = value.bytesPerElement;
	}
	function render( start, count ) {
		gl.drawElements( mode, count, type, start * bytesPerElement );
		infoRender.calls ++;
		infoRender.vertices += count;
		if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;
		else if ( mode === gl.POINTS ) infoRender.points += count;
	}
	function renderInstances( geometry, start, count ) {
		var extension = extensions.get( 'ANGLE_instanced_arrays' );
		if ( extension === null ) {
			console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
			return;
		}
		extension.drawElementsInstancedANGLE( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );
		infoRender.calls ++;
		infoRender.vertices += count * geometry.maxInstancedCount;
		if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;
		else if ( mode === gl.POINTS ) infoRender.points += geometry.maxInstancedCount * count;
	}
	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;
}
function WebGLBufferRenderer( gl, extensions, infoRender ) {
	var mode;
	function setMode( value ) {
		mode = value;
	}
	function render( start, count ) {
		gl.drawArrays( mode, start, count );
		infoRender.calls ++;
		infoRender.vertices += count;
		if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;
		else if ( mode === gl.POINTS ) infoRender.points += count;
	}
	function renderInstances( geometry, start, count ) {
		var extension = extensions.get( 'ANGLE_instanced_arrays' );
		if ( extension === null ) {
			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
			return;
		}
		var position = geometry.attributes.position;
		if ( position.isInterleavedBufferAttribute ) {
			count = position.data.count;
			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );
		} else {
			extension.drawArraysInstancedANGLE( mode, start, count, geometry.maxInstancedCount );
		}
		infoRender.calls ++;
		infoRender.vertices += count * geometry.maxInstancedCount;
		if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;
		else if ( mode === gl.POINTS ) infoRender.points += geometry.maxInstancedCount * count;
	}
	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;
}
function WebGLGeometries( gl, attributes, infoMemory ) {
	var geometries = {};
	var wireframeAttributes = {};
	function onGeometryDispose( event ) {
		var geometry = event.target;
		var buffergeometry = geometries[ geometry.id ];
		if ( buffergeometry.index !== null ) {
			attributes.remove( buffergeometry.index );
		}
		for ( var name in buffergeometry.attributes ) {
			attributes.remove( buffergeometry.attributes[ name ] );
		}
		geometry.removeEventListener( 'dispose', onGeometryDispose );
		delete geometries[ geometry.id ];
		var attribute = wireframeAttributes[ geometry.id ];
		if ( attribute ) {
			attributes.remove( attribute );
			delete wireframeAttributes[ geometry.id ];
		}
		attribute = wireframeAttributes[ buffergeometry.id ];
		if ( attribute ) {
			attributes.remove( attribute );
			delete wireframeAttributes[ buffergeometry.id ];
		}
		infoMemory.geometries --;
	}
	function get( object, geometry ) {
		var buffergeometry = geometries[ geometry.id ];
		if ( buffergeometry ) return buffergeometry;
		geometry.addEventListener( 'dispose', onGeometryDispose );
		if ( geometry.isBufferGeometry ) {
			buffergeometry = geometry;
		} else if ( geometry.isGeometry ) {
			if ( geometry._bufferGeometry === undefined ) {
				geometry._bufferGeometry = new BufferGeometry().setFromObject( object );
			}
			buffergeometry = geometry._bufferGeometry;
		}
		geometries[ geometry.id ] = buffergeometry;
		infoMemory.geometries ++;
		return buffergeometry;
	}
	function update( geometry ) {
		var index = geometry.index;
		var geometryAttributes = geometry.attributes;
		if ( index !== null ) {
			attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );
		}
		for ( var name in geometryAttributes ) {
			attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );
		}
		var morphAttributes = geometry.morphAttributes;
		for ( var name in morphAttributes ) {
			var array = morphAttributes[ name ];
			for ( var i = 0, l = array.length; i < l; i ++ ) {
				attributes.update( array[ i ], gl.ARRAY_BUFFER );
			}
		}
	}
	function getWireframeAttribute( geometry ) {
		var attribute = wireframeAttributes[ geometry.id ];
		if ( attribute ) return attribute;
		var indices = [];
		var geometryIndex = geometry.index;
		var geometryAttributes = geometry.attributes;
		if ( geometryIndex !== null ) {
			var array = geometryIndex.array;
			for ( var i = 0, l = array.length; i < l; i += 3 ) {
				var a = array[ i + 0 ];
				var b = array[ i + 1 ];
				var c = array[ i + 2 ];
				indices.push( a, b, b, c, c, a );
			}
		} else {
			var array = geometryAttributes.position.array;
			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {
				var a = i + 0;
				var b = i + 1;
				var c = i + 2;
				indices.push( a, b, b, c, c, a );
			}
		}
		attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
		attributes.update( attribute, gl.ELEMENT_ARRAY_BUFFER );
		wireframeAttributes[ geometry.id ] = attribute;
		return attribute;
	}
	return {
		get: get,
		update: update,
		getWireframeAttribute: getWireframeAttribute
	};
}
function UniformsCache() {
	var lights = {};
	return {
		get: function ( light ) {
			if ( lights[ light.id ] !== undefined ) {
				return lights[ light.id ];
			}
			var uniforms;
			switch ( light.type ) {
				case 'DirectionalLight':
					uniforms = {
						direction: new Vector3(),
						color: new Color(),
						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;
				case 'SpotLight':
					uniforms = {
						position: new Vector3(),
						direction: new Vector3(),
						color: new Color(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0,
						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;
				case 'PointLight':
					uniforms = {
						position: new Vector3(),
						color: new Color(),
						distance: 0,
						decay: 0,
						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2(),
						shadowCameraNear: 1,
						shadowCameraFar: 1000
					};
					break;
				case 'HemisphereLight':
					uniforms = {
						direction: new Vector3(),
						skyColor: new Color(),
						groundColor: new Color()
					};
					break;
				case 'RectAreaLight':
					uniforms = {
						color: new Color(),
						position: new Vector3(),
						halfWidth: new Vector3(),
						halfHeight: new Vector3()
					};
					break;
			}
			lights[ light.id ] = uniforms;
			return uniforms;
		}
	};
}
function WebGLLights() {
	var cache = new UniformsCache();
	var state = {
		hash: '',
		ambient: [ 0, 0, 0 ],
		directional: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotShadowMap: [],
		spotShadowMatrix: [],
		rectArea: [],
		point: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: []
	};
	var vector3 = new Vector3();
	var matrix4 = new Matrix4();
	var matrix42 = new Matrix4();
	function setup( lights, shadows, camera ) {
		var r = 0, g = 0, b = 0;
		var directionalLength = 0;
		var pointLength = 0;
		var spotLength = 0;
		var rectAreaLength = 0;
		var hemiLength = 0;
		var viewMatrix = camera.matrixWorldInverse;
		for ( var i = 0, l = lights.length; i < l; i ++ ) {
			var light = lights[ i ];
			var color = light.color;
			var intensity = light.intensity;
			var distance = light.distance;
			var shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;
			if ( light.isAmbientLight ) {
				r += color.r * intensity;
				g += color.g * intensity;
				b += color.b * intensity;
			} else if ( light.isDirectionalLight ) {
				var uniforms = cache.get( light );
				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );
				uniforms.shadow = light.castShadow;
				if ( light.castShadow ) {
					var shadow = light.shadow;
					uniforms.shadowBias = shadow.bias;
					uniforms.shadowRadius = shadow.radius;
					uniforms.shadowMapSize = shadow.mapSize;
				}
				state.directionalShadowMap[ directionalLength ] = shadowMap;
				state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
				state.directional[ directionalLength ] = uniforms;
				directionalLength ++;
			} else if ( light.isSpotLight ) {
				var uniforms = cache.get( light );
				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );
				uniforms.color.copy( color ).multiplyScalar( intensity );
				uniforms.distance = distance;
				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );
				uniforms.coneCos = Math.cos( light.angle );
				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;
				uniforms.shadow = light.castShadow;
				if ( light.castShadow ) {
					var shadow = light.shadow;
					uniforms.shadowBias = shadow.bias;
					uniforms.shadowRadius = shadow.radius;
					uniforms.shadowMapSize = shadow.mapSize;
				}
				state.spotShadowMap[ spotLength ] = shadowMap;
				state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
				state.spot[ spotLength ] = uniforms;
				spotLength ++;
			} else if ( light.isRectAreaLight ) {
				var uniforms = cache.get( light );
				uniforms.color
					.copy( color )
					.multiplyScalar( intensity / ( light.width * light.height ) );
				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );
				matrix42.identity();
				matrix4.copy( light.matrixWorld );
				matrix4.premultiply( viewMatrix );
				matrix42.extractRotation( matrix4 );
				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );
				uniforms.halfWidth.applyMatrix4( matrix42 );
				uniforms.halfHeight.applyMatrix4( matrix42 );
				state.rectArea[ rectAreaLength ] = uniforms;
				rectAreaLength ++;
			} else if ( light.isPointLight ) {
				var uniforms = cache.get( light );
				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );
				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.distance = light.distance;
				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;
				uniforms.shadow = light.castShadow;
				if ( light.castShadow ) {
					var shadow = light.shadow;
					uniforms.shadowBias = shadow.bias;
					uniforms.shadowRadius = shadow.radius;
					uniforms.shadowMapSize = shadow.mapSize;
					uniforms.shadowCameraNear = shadow.camera.near;
					uniforms.shadowCameraFar = shadow.camera.far;
				}
				state.pointShadowMap[ pointLength ] = shadowMap;
				state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;
				state.point[ pointLength ] = uniforms;
				pointLength ++;
			} else if ( light.isHemisphereLight ) {
				var uniforms = cache.get( light );
				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				uniforms.direction.transformDirection( viewMatrix );
				uniforms.direction.normalize();
				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );
				state.hemi[ hemiLength ] = uniforms;
				hemiLength ++;
			}
		}
		state.ambient[ 0 ] = r;
		state.ambient[ 1 ] = g;
		state.ambient[ 2 ] = b;
		state.directional.length = directionalLength;
		state.spot.length = spotLength;
		state.rectArea.length = rectAreaLength;
		state.point.length = pointLength;
		state.hemi.length = hemiLength;
		state.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + shadows.length;
	}
	return {
		setup: setup,
		state: state
	};
}
function WebGLObjects( geometries, infoRender ) {
	var updateList = {};
	function update( object ) {
		var frame = infoRender.frame;
		var geometry = object.geometry;
		var buffergeometry = geometries.get( object, geometry );
		if ( updateList[ buffergeometry.id ] !== frame ) {
			if ( geometry.isGeometry ) {
				buffergeometry.updateFromObject( object );
			}
			geometries.update( buffergeometry );
			updateList[ buffergeometry.id ] = frame;
		}
		return buffergeometry;
	}
	function clear() {
		updateList = {};
	}
	return {
		update: update,
		clear: clear
	};
}
function addLineNumbers( string ) {
	var lines = string.split( '\n' );
	for ( var i = 0; i < lines.length; i ++ ) {
		lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];
	}
	return lines.join( '\n' );
}
function WebGLShader( gl, type, string ) {
	var shader = gl.createShader( type );
	gl.shaderSource( shader, string );
	gl.compileShader( shader );
	if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {
		console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );
	}
	if ( gl.getShaderInfoLog( shader ) !== '' ) {
		console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );
	}
	return shader;
}
var programIdCount = 0;
function getEncodingComponents( encoding ) {
	switch ( encoding ) {
		case LinearEncoding:
			return [ 'Linear', '( value )' ];
		case sRGBEncoding:
			return [ 'sRGB', '( value )' ];
		case RGBEEncoding:
			return [ 'RGBE', '( value )' ];
		case RGBM7Encoding:
			return [ 'RGBM', '( value, 7.0 )' ];
		case RGBM16Encoding:
			return [ 'RGBM', '( value, 16.0 )' ];
		case RGBDEncoding:
			return [ 'RGBD', '( value, 256.0 )' ];
		case GammaEncoding:
			return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
		default:
			throw new Error( 'unsupported encoding: ' + encoding );
	}
}
function getTexelDecodingFunction( functionName, encoding ) {
	var components = getEncodingComponents( encoding );
	return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";
}
function getTexelEncodingFunction( functionName, encoding ) {
	var components = getEncodingComponents( encoding );
	return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";
}
function getToneMappingFunction( functionName, toneMapping ) {
	var toneMappingName;
	switch ( toneMapping ) {
		case LinearToneMapping:
			toneMappingName = "Linear";
			break;
		case ReinhardToneMapping:
			toneMappingName = "Reinhard";
			break;
		case Uncharted2ToneMapping:
			toneMappingName = "Uncharted2";
			break;
		case CineonToneMapping:
			toneMappingName = "OptimizedCineon";
			break;
		default:
			throw new Error( 'unsupported toneMapping: ' + toneMapping );
	}
	return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions( extensions, parameters, rendererExtensions ) {
	extensions = extensions || {};
	var chunks = [
		( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
		( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
		( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
		( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
	];
	return chunks.filter( filterEmptyLine ).join( '\n' );
}
function generateDefines( defines ) {
	var chunks = [];
	for ( var name in defines ) {
		var value = defines[ name ];
		if ( value === false ) continue;
		chunks.push( '#define ' + name + ' ' + value );
	}
	return chunks.join( '\n' );
}
function fetchAttributeLocations( gl, program ) {
	var attributes = {};
	var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );
	for ( var i = 0; i < n; i ++ ) {
		var info = gl.getActiveAttrib( program, i );
		var name = info.name;
		attributes[ name ] = gl.getAttribLocation( program, name );
	}
	return attributes;
}
function filterEmptyLine( string ) {
	return string !== '';
}
function replaceLightNums( string, parameters ) {
	return string
		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );
}
function parseIncludes( string ) {
	var pattern = /^[ \t]*#include +<([\w\d.]+)>/gm;
	function replace( match, include ) {
		var replace = ShaderChunk[ include ];
		if ( replace === undefined ) {
			throw new Error( 'Can not resolve #include <' + include + '>' );
		}
		return parseIncludes( replace );
	}
	return string.replace( pattern, replace );
}
function unrollLoops( string ) {
	var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	function replace( match, start, end, snippet ) {
		var unroll = '';
		for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {
			unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );
		}
		return unroll;
	}
	return string.replace( pattern, replace );
}
function WebGLProgram( renderer, extensions, code, material, shader, parameters ) {
	var gl = renderer.context;
	var defines = material.defines;
	var vertexShader = shader.vertexShader;
	var fragmentShader = shader.fragmentShader;
	var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
	if ( parameters.shadowMapType === PCFShadowMap ) {
		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {
		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
	}
	var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
	var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
	var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
	if ( parameters.envMap ) {
		switch ( material.envMap.mapping ) {
			case CubeReflectionMapping:
			case CubeRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;
			case CubeUVReflectionMapping:
			case CubeUVRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;
			case EquirectangularReflectionMapping:
			case EquirectangularRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
				break;
			case SphericalReflectionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
				break;
		}
		switch ( material.envMap.mapping ) {
			case CubeRefractionMapping:
			case EquirectangularRefractionMapping:
				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;
		}
		switch ( material.combine ) {
			case MultiplyOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;
			case MixOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;
			case AddOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;
		}
	}
	var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;
	var customExtensions = generateExtensions( material.extensions, parameters, extensions );
	var customDefines = generateDefines( defines );
	var program = gl.createProgram();
	var prefixVertex, prefixFragment;
	if ( material.isRawShaderMaterial ) {
		prefixVertex = [
			customDefines
		].filter( filterEmptyLine ).join( '\n' );
		if ( prefixVertex.length > 0 ) {
			prefixVertex += '\n';
		}
		prefixFragment = [
			customExtensions,
			customDefines
		].filter( filterEmptyLine ).join( '\n' );
		if ( prefixFragment.length > 0 ) {
			prefixFragment += '\n';
		}
	} else {
		prefixVertex = [
			'precision ' + parameters.precision + ' float;',
			'precision ' + parameters.precision + ' int;',
			'#define SHADER_NAME ' + shader.name,
			customDefines,
			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
			'#define GAMMA_FACTOR ' + gammaFactorDefine,
			'#define MAX_BONES ' + parameters.maxBones,
			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',
			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',
			parameters.flatShading ? '#define FLAT_SHADED' : '',
			parameters.skinning ? '#define USE_SKINNING' : '',
			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',
			'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			parameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
			'uniform mat4 modelMatrix;',
			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',
			'attribute vec3 position;',
			'attribute vec3 normal;',
			'attribute vec2 uv;',
			'#ifdef USE_COLOR',
			'	attribute vec3 color;',
			'#endif',
			'#ifdef USE_MORPHTARGETS',
			'	attribute vec3 morphTarget0;',
			'	attribute vec3 morphTarget1;',
			'	attribute vec3 morphTarget2;',
			'	attribute vec3 morphTarget3;',
			'	#ifdef USE_MORPHNORMALS',
			'		attribute vec3 morphNormal0;',
			'		attribute vec3 morphNormal1;',
			'		attribute vec3 morphNormal2;',
			'		attribute vec3 morphNormal3;',
			'	#else',
			'		attribute vec3 morphTarget4;',
			'		attribute vec3 morphTarget5;',
			'		attribute vec3 morphTarget6;',
			'		attribute vec3 morphTarget7;',
			'	#endif',
			'#endif',
			'#ifdef USE_SKINNING',
			'	attribute vec4 skinIndex;',
			'	attribute vec4 skinWeight;',
			'#endif',
			'\n'
		].filter( filterEmptyLine ).join( '\n' );
		prefixFragment = [
			customExtensions,
			'precision ' + parameters.precision + ' float;',
			'precision ' + parameters.precision + ' int;',
			'#define SHADER_NAME ' + shader.name,
			customDefines,
			parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',
			'#define GAMMA_FACTOR ' + gammaFactorDefine,
			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',
			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapTypeDefine : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',
			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',
			parameters.flatShading ? '#define FLAT_SHADED' : '',
			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',
			'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
			'#define UNION_CLIPPING_PLANES ' + ( parameters.numClippingPlanes - parameters.numClipIntersection ),
			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
			parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',
			parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',
			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			parameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
			parameters.envMap && extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',
			'uniform mat4 viewMatrix;',
			'uniform vec3 cameraPosition;',
			( parameters.toneMapping !== NoToneMapping ) ? "#define TONE_MAPPING" : '',
			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',
			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( "toneMapping", parameters.toneMapping ) : '',
			parameters.dithering ? '#define DITHERING' : '',
			( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '',
			parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
			parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
			parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
			parameters.outputEncoding ? getTexelEncodingFunction( "linearToOutputTexel", parameters.outputEncoding ) : '',
			parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',
			'\n'
		].filter( filterEmptyLine ).join( '\n' );
	}
	vertexShader = parseIncludes( vertexShader );
	vertexShader = replaceLightNums( vertexShader, parameters );
	fragmentShader = parseIncludes( fragmentShader );
	fragmentShader = replaceLightNums( fragmentShader, parameters );
	if ( ! material.isShaderMaterial ) {
		vertexShader = unrollLoops( vertexShader );
		fragmentShader = unrollLoops( fragmentShader );
	}
	var vertexGlsl = prefixVertex + vertexShader;
	var fragmentGlsl = prefixFragment + fragmentShader;
	var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
	var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );
	gl.attachShader( program, glVertexShader );
	gl.attachShader( program, glFragmentShader );
	if ( material.index0AttributeName !== undefined ) {
		gl.bindAttribLocation( program, 0, material.index0AttributeName );
	} else if ( parameters.morphTargets === true ) {
		gl.bindAttribLocation( program, 0, 'position' );
	}
	gl.linkProgram( program );
	var programLog = gl.getProgramInfoLog( program );
	var vertexLog = gl.getShaderInfoLog( glVertexShader );
	var fragmentLog = gl.getShaderInfoLog( glFragmentShader );
	var runnable = true;
	var haveDiagnostics = true;
	if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {
		runnable = false;
		console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );
	} else if ( programLog !== '' ) {
		console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );
	} else if ( vertexLog === '' || fragmentLog === '' ) {
		haveDiagnostics = false;
	}
	if ( haveDiagnostics ) {
		this.diagnostics = {
			runnable: runnable,
			material: material,
			programLog: programLog,
			vertexShader: {
				log: vertexLog,
				prefix: prefixVertex
			},
			fragmentShader: {
				log: fragmentLog,
				prefix: prefixFragment
			}
		};
	}
	gl.deleteShader( glVertexShader );
	gl.deleteShader( glFragmentShader );
	var cachedUniforms;
	this.getUniforms = function () {
		if ( cachedUniforms === undefined ) {
			cachedUniforms = new WebGLUniforms( gl, program, renderer );
		}
		return cachedUniforms;
	};
	var cachedAttributes;
	this.getAttributes = function () {
		if ( cachedAttributes === undefined ) {
			cachedAttributes = fetchAttributeLocations( gl, program );
		}
		return cachedAttributes;
	};
	this.destroy = function () {
		gl.deleteProgram( program );
		this.program = undefined;
	};
	Object.defineProperties( this, {
		uniforms: {
			get: function () {
				console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
				return this.getUniforms();
			}
		},
		attributes: {
			get: function () {
				console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
				return this.getAttributes();
			}
		}
	} );
	this.id = programIdCount ++;
	this.code = code;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;
	return this;
}
function WebGLPrograms( renderer, extensions, capabilities ) {
	var programs = [];
	var shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshDistanceMaterial: 'distanceRGBA',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'phong',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points',
		ShadowMaterial: 'shadow'
	};
	var parameterNames = [
		"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
		"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
		"roughnessMap", "metalnessMap", "gradientMap",
		"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
		"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
		"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
		"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
		"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"
	];
	function allocateBones( object ) {
		var skeleton = object.skeleton;
		var bones = skeleton.bones;
		if ( capabilities.floatVertexTextures ) {
			return 1024;
		} else {
			var nVertexUniforms = capabilities.maxVertexUniforms;
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );
			var maxBones = Math.min( nVertexMatrices, bones.length );
			if ( maxBones < bones.length ) {
				console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
				return 0;
			}
			return maxBones;
		}
	}
	function getTextureEncodingFromMap( map, gammaOverrideLinear ) {
		var encoding;
		if ( ! map ) {
			encoding = LinearEncoding;
		} else if ( map.isTexture ) {
			encoding = map.encoding;
		} else if ( map.isWebGLRenderTarget ) {
			console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
			encoding = map.texture.encoding;
		}
		if ( encoding === LinearEncoding && gammaOverrideLinear ) {
			encoding = GammaEncoding;
		}
		return encoding;
	}
	this.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {
		var shaderID = shaderIDs[ material.type ];
		var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;
		var precision = capabilities.precision;
		if ( material.precision !== null ) {
			precision = capabilities.getMaxPrecision( material.precision );
			if ( precision !== material.precision ) {
				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );
			}
		}
		var currentRenderTarget = renderer.getRenderTarget();
		var parameters = {
			shaderID: shaderID,
			precision: precision,
			supportsVertexTextures: capabilities.vertexTextures,
			outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
			map: !! material.map,
			mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
			envMap: !! material.envMap,
			envMapMode: material.envMap && material.envMap.mapping,
			envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
			envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
			lightMap: !! material.lightMap,
			aoMap: !! material.aoMap,
			emissiveMap: !! material.emissiveMap,
			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			displacementMap: !! material.displacementMap,
			roughnessMap: !! material.roughnessMap,
			metalnessMap: !! material.metalnessMap,
			specularMap: !! material.specularMap,
			alphaMap: !! material.alphaMap,
			gradientMap: !! material.gradientMap,
			combine: material.combine,
			vertexColors: material.vertexColors,
			fog: !! fog,
			useFog: material.fog,
			fogExp: ( fog && fog.isFogExp2 ),
			flatShading: material.flatShading,
			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
			skinning: material.skinning && maxBones > 0,
			maxBones: maxBones,
			useVertexTexture: capabilities.floatVertexTextures,
			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: renderer.maxMorphTargets,
			maxMorphNormals: renderer.maxMorphNormals,
			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,
			numClippingPlanes: nClipPlanes,
			numClipIntersection: nClipIntersection,
			dithering: material.dithering,
			shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,
			toneMapping: renderer.toneMapping,
			physicallyCorrectLights: renderer.physicallyCorrectLights,
			premultipliedAlpha: material.premultipliedAlpha,
			alphaTest: material.alphaTest,
			doubleSided: material.side === DoubleSide,
			flipSided: material.side === BackSide,
			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false
		};
		return parameters;
	};
	this.getProgramCode = function ( material, parameters ) {
		var array = [];
		if ( parameters.shaderID ) {
			array.push( parameters.shaderID );
		} else {
			array.push( material.fragmentShader );
			array.push( material.vertexShader );
		}
		if ( material.defines !== undefined ) {
			for ( var name in material.defines ) {
				array.push( name );
				array.push( material.defines[ name ] );
			}
		}
		for ( var i = 0; i < parameterNames.length; i ++ ) {
			array.push( parameters[ parameterNames[ i ] ] );
		}
		array.push( material.onBeforeCompile.toString() );
		array.push( renderer.gammaOutput );
		return array.join();
	};
	this.acquireProgram = function ( material, shader, parameters, code ) {
		var program;
		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {
			var programInfo = programs[ p ];
			if ( programInfo.code === code ) {
				program = programInfo;
				++ program.usedTimes;
				break;
			}
		}
		if ( program === undefined ) {
			program = new WebGLProgram( renderer, extensions, code, material, shader, parameters );
			programs.push( program );
		}
		return program;
	};
	this.releaseProgram = function ( program ) {
		if ( -- program.usedTimes === 0 ) {
			var i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();
			program.destroy();
		}
	};
	this.programs = programs;
}
function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, infoMemory ) {
	var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof window.WebGL2RenderingContext );
	function clampToMaxSize( image, maxSize ) {
		if ( image.width > maxSize || image.height > maxSize ) {
			var scale = maxSize / Math.max( image.width, image.height );
			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			canvas.width = Math.floor( image.width * scale );
			canvas.height = Math.floor( image.height * scale );
			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );
			console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );
			return canvas;
		}
		return image;
	}
	function isPowerOfTwo( image ) {
		return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );
	}
	function makePowerOfTwo( image ) {
		if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap ) {
			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			canvas.width = _Math.floorPowerOfTwo( image.width );
			canvas.height = _Math.floorPowerOfTwo( image.height );
			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, canvas.width, canvas.height );
			console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );
			return canvas;
		}
		return image;
	}
	function textureNeedsPowerOfTwo( texture ) {
		return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
			( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );
	}
	function textureNeedsGenerateMipmaps( texture, isPowerOfTwo ) {
		return texture.generateMipmaps && isPowerOfTwo &&
			texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
	}
	function filterFallback( f ) {
		if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {
			return _gl.NEAREST;
		}
		return _gl.LINEAR;
	}
	function onTextureDispose( event ) {
		var texture = event.target;
		texture.removeEventListener( 'dispose', onTextureDispose );
		deallocateTexture( texture );
		infoMemory.textures --;
	}
	function onRenderTargetDispose( event ) {
		var renderTarget = event.target;
		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );
		deallocateRenderTarget( renderTarget );
		infoMemory.textures --;
	}
	function deallocateTexture( texture ) {
		var textureProperties = properties.get( texture );
		if ( texture.image && textureProperties.__image__webglTextureCube ) {
			_gl.deleteTexture( textureProperties.__image__webglTextureCube );
		} else {
			if ( textureProperties.__webglInit === undefined ) return;
			_gl.deleteTexture( textureProperties.__webglTexture );
		}
		properties.remove( texture );
	}
	function deallocateRenderTarget( renderTarget ) {
		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );
		if ( ! renderTarget ) return;
		if ( textureProperties.__webglTexture !== undefined ) {
			_gl.deleteTexture( textureProperties.__webglTexture );
		}
		if ( renderTarget.depthTexture ) {
			renderTarget.depthTexture.dispose();
		}
		if ( renderTarget.isWebGLRenderTargetCube ) {
			for ( var i = 0; i < 6; i ++ ) {
				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );
			}
		} else {
			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
		}
		properties.remove( renderTarget.texture );
		properties.remove( renderTarget );
	}
	function setTexture2D( texture, slot ) {
		var textureProperties = properties.get( texture );
		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
			var image = texture.image;
			if ( image === undefined ) {
				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
			} else if ( image.complete === false ) {
				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
			} else {
				uploadTexture( textureProperties, texture, slot );
				return;
			}
		}
		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
	}
	function setTextureCube( texture, slot ) {
		var textureProperties = properties.get( texture );
		if ( texture.image.length === 6 ) {
			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
				if ( ! textureProperties.__image__webglTextureCube ) {
					texture.addEventListener( 'dispose', onTextureDispose );
					textureProperties.__image__webglTextureCube = _gl.createTexture();
					infoMemory.textures ++;
				}
				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );
				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
				var isCompressed = ( texture && texture.isCompressedTexture );
				var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );
				var cubeImage = [];
				for ( var i = 0; i < 6; i ++ ) {
					if ( ! isCompressed && ! isDataTexture ) {
						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );
					} else {
						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];
					}
				}
				var image = cubeImage[ 0 ],
					isPowerOfTwoImage = isPowerOfTwo( image ),
					glFormat = utils.convert( texture.format ),
					glType = utils.convert( texture.type );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );
				for ( var i = 0; i < 6; i ++ ) {
					if ( ! isCompressed ) {
						if ( isDataTexture ) {
							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );
						} else {
							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );
						}
					} else {
						var mipmap, mipmaps = cubeImage[ i ].mipmaps;
						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {
							mipmap = mipmaps[ j ];
							if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {
								if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {
									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
								} else {
									console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );
								}
							} else {
								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
							}
						}
					}
				}
				if ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {
					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
				}
				textureProperties.__version = texture.version;
				if ( texture.onUpdate ) texture.onUpdate( texture );
			} else {
				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );
			}
		}
	}
	function setTextureCubeDynamic( texture, slot ) {
		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );
	}
	function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {
		var extension;
		if ( isPowerOfTwoImage ) {
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, utils.convert( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, utils.convert( texture.wrapT ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, utils.convert( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, utils.convert( texture.minFilter ) );
		} else {
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {
				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );
			}
			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );
			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {
				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );
			}
		}
		extension = extensions.get( 'EXT_texture_filter_anisotropic' );
		if ( extension ) {
			if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
			if ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;
			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {
				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;
			}
		}
	}
	function uploadTexture( textureProperties, texture, slot ) {
		if ( textureProperties.__webglInit === undefined ) {
			textureProperties.__webglInit = true;
			texture.addEventListener( 'dispose', onTextureDispose );
			textureProperties.__webglTexture = _gl.createTexture();
			infoMemory.textures ++;
		}
		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
		var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );
		if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {
			image = makePowerOfTwo( image );
		}
		var isPowerOfTwoImage = isPowerOfTwo( image ),
			glFormat = utils.convert( texture.format ),
			glType = utils.convert( texture.type );
		setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );
		var mipmap, mipmaps = texture.mipmaps;
		if ( texture.isDepthTexture ) {
			var internalFormat = _gl.DEPTH_COMPONENT;
			if ( texture.type === FloatType ) {
				if ( ! _isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );
				internalFormat = _gl.DEPTH_COMPONENT32F;
			} else if ( _isWebGL2 ) {
				internalFormat = _gl.DEPTH_COMPONENT16;
			}
			if ( texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT ) {
				if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {
					console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );
					texture.type = UnsignedShortType;
					glType = utils.convert( texture.type );
				}
			}
			if ( texture.format === DepthStencilFormat ) {
				internalFormat = _gl.DEPTH_STENCIL;
				if ( texture.type !== UnsignedInt248Type ) {
					console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );
					texture.type = UnsignedInt248Type;
					glType = utils.convert( texture.type );
				}
			}
			state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );
		} else if ( texture.isDataTexture ) {
			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {
				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
				}
				texture.generateMipmaps = false;
			} else {
				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );
			}
		} else if ( texture.isCompressedTexture ) {
			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
				mipmap = mipmaps[ i ];
				if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {
					if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {
						state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
					} else {
						console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );
					}
				} else {
					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
				}
			}
		} else {
			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {
				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );
				}
				texture.generateMipmaps = false;
			} else {
				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );
			}
		}
		if ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) _gl.generateMipmap( _gl.TEXTURE_2D );
		textureProperties.__version = texture.version;
		if ( texture.onUpdate ) texture.onUpdate( texture );
	}
	function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {
		var glFormat = utils.convert( renderTarget.texture.format );
		var glType = utils.convert( renderTarget.texture.type );
		state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
	}
	function setupRenderBufferStorage( renderbuffer, renderTarget ) {
		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );
		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {
			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
		} else {
			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );
		}
		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
	}
	function setupDepthTexture( framebuffer, renderTarget ) {
		var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
		if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );
		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {
			throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );
		}
		if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height ) {
			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;
		}
		setTexture2D( renderTarget.depthTexture, 0 );
		var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
		if ( renderTarget.depthTexture.format === DepthFormat ) {
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );
		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );
		} else {
			throw new Error( 'Unknown depthTexture format' );
		}
	}
	function setupDepthRenderbuffer( renderTarget ) {
		var renderTargetProperties = properties.get( renderTarget );
		var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
		if ( renderTarget.depthTexture ) {
			if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );
			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );
		} else {
			if ( isCube ) {
				renderTargetProperties.__webglDepthbuffer = [];
				for ( var i = 0; i < 6; i ++ ) {
					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );
				}
			} else {
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );
			}
		}
		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
	}
	function setupRenderTarget( renderTarget ) {
		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );
		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );
		textureProperties.__webglTexture = _gl.createTexture();
		infoMemory.textures ++;
		var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
		var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );
		if ( isCube ) {
			renderTargetProperties.__webglFramebuffer = [];
			for ( var i = 0; i < 6; i ++ ) {
				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
			}
		} else {
			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
		}
		if ( isCube ) {
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
			setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );
			for ( var i = 0; i < 6; i ++ ) {
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
			}
			if ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );
		} else {
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
			setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );
			if ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_2D );
			state.bindTexture( _gl.TEXTURE_2D, null );
		}
		if ( renderTarget.depthBuffer ) {
			setupDepthRenderbuffer( renderTarget );
		}
	}
	function updateRenderTargetMipmap( renderTarget ) {
		var texture = renderTarget.texture;
		var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );
		if ( textureNeedsGenerateMipmaps( texture, isTargetPowerOfTwo ) ) {
			var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
			var webglTexture = properties.get( texture ).__webglTexture;
			state.bindTexture( target, webglTexture );
			_gl.generateMipmap( target );
			state.bindTexture( target, null );
		}
	}
	this.setTexture2D = setTexture2D;
	this.setTextureCube = setTextureCube;
	this.setTextureCubeDynamic = setTextureCubeDynamic;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
}
function WebGLProperties() {
	var properties = {};
	function get( object ) {
		var uuid = object.uuid;
		var map = properties[ uuid ];
		if ( map === undefined ) {
			map = {};
			properties[ uuid ] = map;
		}
		return map;
	}
	function remove( object ) {
		delete properties[ object.uuid ];
	}
	function clear() {
		properties = {};
	}
	return {
		get: get,
		remove: remove,
		clear: clear
	};
}
function WebGLState( gl, extensions, utils ) {
	function ColorBuffer() {
		var locked = false;
		var color = new Vector4();
		var currentColorMask = null;
		var currentColorClear = new Vector4( 0, 0, 0, 0 );
		return {
			setMask: function ( colorMask ) {
				if ( currentColorMask !== colorMask && ! locked ) {
					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
					currentColorMask = colorMask;
				}
			},
			setLocked: function ( lock ) {
				locked = lock;
			},
			setClear: function ( r, g, b, a, premultipliedAlpha ) {
				if ( premultipliedAlpha === true ) {
					r *= a; g *= a; b *= a;
				}
				color.set( r, g, b, a );
				if ( currentColorClear.equals( color ) === false ) {
					gl.clearColor( r, g, b, a );
					currentColorClear.copy( color );
				}
			},
			reset: function () {
				locked = false;
				currentColorMask = null;
				currentColorClear.set( - 1, 0, 0, 0 );
			}
		};
	}
	function DepthBuffer() {
		var locked = false;
		var currentDepthMask = null;
		var currentDepthFunc = null;
		var currentDepthClear = null;
		return {
			setTest: function ( depthTest ) {
				if ( depthTest ) {
					enable( gl.DEPTH_TEST );
				} else {
					disable( gl.DEPTH_TEST );
				}
			},
			setMask: function ( depthMask ) {
				if ( currentDepthMask !== depthMask && ! locked ) {
					gl.depthMask( depthMask );
					currentDepthMask = depthMask;
				}
			},
			setFunc: function ( depthFunc ) {
				if ( currentDepthFunc !== depthFunc ) {
					if ( depthFunc ) {
						switch ( depthFunc ) {
							case NeverDepth:
								gl.depthFunc( gl.NEVER );
								break;
							case AlwaysDepth:
								gl.depthFunc( gl.ALWAYS );
								break;
							case LessDepth:
								gl.depthFunc( gl.LESS );
								break;
							case LessEqualDepth:
								gl.depthFunc( gl.LEQUAL );
								break;
							case EqualDepth:
								gl.depthFunc( gl.EQUAL );
								break;
							case GreaterEqualDepth:
								gl.depthFunc( gl.GEQUAL );
								break;
							case GreaterDepth:
								gl.depthFunc( gl.GREATER );
								break;
							case NotEqualDepth:
								gl.depthFunc( gl.NOTEQUAL );
								break;
							default:
								gl.depthFunc( gl.LEQUAL );
						}
					} else {
						gl.depthFunc( gl.LEQUAL );
					}
					currentDepthFunc = depthFunc;
				}
			},
			setLocked: function ( lock ) {
				locked = lock;
			},
			setClear: function ( depth ) {
				if ( currentDepthClear !== depth ) {
					gl.clearDepth( depth );
					currentDepthClear = depth;
				}
			},
			reset: function () {
				locked = false;
				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;
			}
		};
	}
	function StencilBuffer() {
		var locked = false;
		var currentStencilMask = null;
		var currentStencilFunc = null;
		var currentStencilRef = null;
		var currentStencilFuncMask = null;
		var currentStencilFail = null;
		var currentStencilZFail = null;
		var currentStencilZPass = null;
		var currentStencilClear = null;
		return {
			setTest: function ( stencilTest ) {
				if ( stencilTest ) {
					enable( gl.STENCIL_TEST );
				} else {
					disable( gl.STENCIL_TEST );
				}
			},
			setMask: function ( stencilMask ) {
				if ( currentStencilMask !== stencilMask && ! locked ) {
					gl.stencilMask( stencilMask );
					currentStencilMask = stencilMask;
				}
			},
			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {
				if ( currentStencilFunc !== stencilFunc ||
				     currentStencilRef 	!== stencilRef 	||
				     currentStencilFuncMask !== stencilMask ) {
					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );
					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;
				}
			},
			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {
				if ( currentStencilFail	 !== stencilFail 	||
				     currentStencilZFail !== stencilZFail ||
				     currentStencilZPass !== stencilZPass ) {
					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );
					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;
				}
			},
			setLocked: function ( lock ) {
				locked = lock;
			},
			setClear: function ( stencil ) {
				if ( currentStencilClear !== stencil ) {
					gl.clearStencil( stencil );
					currentStencilClear = stencil;
				}
			},
			reset: function () {
				locked = false;
				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;
			}
		};
	}
	var colorBuffer = new ColorBuffer();
	var depthBuffer = new DepthBuffer();
	var stencilBuffer = new StencilBuffer();
	var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	var newAttributes = new Uint8Array( maxVertexAttributes );
	var enabledAttributes = new Uint8Array( maxVertexAttributes );
	var attributeDivisors = new Uint8Array( maxVertexAttributes );
	var capabilities = {};
	var compressedTextureFormats = null;
	var currentProgram = null;
	var currentBlending = null;
	var currentBlendEquation = null;
	var currentBlendSrc = null;
	var currentBlendDst = null;
	var currentBlendEquationAlpha = null;
	var currentBlendSrcAlpha = null;
	var currentBlendDstAlpha = null;
	var currentPremultipledAlpha = false;
	var currentFlipSided = null;
	var currentCullFace = null;
	var currentLineWidth = null;
	var currentPolygonOffsetFactor = null;
	var currentPolygonOffsetUnits = null;
	var maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );
	var version = parseFloat( /^WebGL\ ([0-9])/.exec( gl.getParameter( gl.VERSION ) )[ 1 ] );
	var lineWidthAvailable = parseFloat( version ) >= 1.0;
	var currentTextureSlot = null;
	var currentBoundTextures = {};
	var currentScissor = new Vector4();
	var currentViewport = new Vector4();
	function createTexture( type, target, count ) {
		var data = new Uint8Array( 4 );
		var texture = gl.createTexture();
		gl.bindTexture( type, texture );
		gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
		gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		for ( var i = 0; i < count; i ++ ) {
			gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );
		}
		return texture;
	}
	var emptyTextures = {};
	emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
	emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );
	colorBuffer.setClear( 0, 0, 0, 1 );
	depthBuffer.setClear( 1 );
	stencilBuffer.setClear( 0 );
	enable( gl.DEPTH_TEST );
	depthBuffer.setFunc( LessEqualDepth );
	setFlipSided( false );
	setCullFace( CullFaceBack );
	enable( gl.CULL_FACE );
	enable( gl.BLEND );
	setBlending( NormalBlending );
	function initAttributes() {
		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {
			newAttributes[ i ] = 0;
		}
	}
	function enableAttribute( attribute ) {
		newAttributes[ attribute ] = 1;
		if ( enabledAttributes[ attribute ] === 0 ) {
			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;
		}
		if ( attributeDivisors[ attribute ] !== 0 ) {
			var extension = extensions.get( 'ANGLE_instanced_arrays' );
			extension.vertexAttribDivisorANGLE( attribute, 0 );
			attributeDivisors[ attribute ] = 0;
		}
	}
	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {
		newAttributes[ attribute ] = 1;
		if ( enabledAttributes[ attribute ] === 0 ) {
			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;
		}
		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {
			var extension = extensions.get( 'ANGLE_instanced_arrays' );
			extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;
		}
	}
	function disableUnusedAttributes() {
		for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {
			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {
				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;
			}
		}
	}
	function enable( id ) {
		if ( capabilities[ id ] !== true ) {
			gl.enable( id );
			capabilities[ id ] = true;
		}
	}
	function disable( id ) {
		if ( capabilities[ id ] !== false ) {
			gl.disable( id );
			capabilities[ id ] = false;
		}
	}
	function getCompressedTextureFormats() {
		if ( compressedTextureFormats === null ) {
			compressedTextureFormats = [];
			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
			     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
			     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {
				var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );
				for ( var i = 0; i < formats.length; i ++ ) {
					compressedTextureFormats.push( formats[ i ] );
				}
			}
		}
		return compressedTextureFormats;
	}
	function useProgram( program ) {
		if ( currentProgram !== program ) {
			gl.useProgram( program );
			currentProgram = program;
			return true;
		}
		return false;
	}
	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {
		if ( blending !== NoBlending ) {
			enable( gl.BLEND );
		} else {
			disable( gl.BLEND );
		}
		if ( blending !== CustomBlending ) {
			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {
				switch ( blending ) {
					case AdditiveBlending:
						if ( premultipliedAlpha ) {
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );
						} else {
							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
						}
						break;
					case SubtractiveBlending:
						if ( premultipliedAlpha ) {
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );
						} else {
							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );
						}
						break;
					case MultiplyBlending:
						if ( premultipliedAlpha ) {
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
						} else {
							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
						}
						break;
					default:
						if ( premultipliedAlpha ) {
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
						} else {
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
						}
				}
			}
			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;
		} else {
			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;
			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {
				gl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );
				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;
			}
			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {
				gl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );
				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;
			}
		}
		currentBlending = blending;
		currentPremultipledAlpha = premultipliedAlpha;
	}
	function setMaterial( material ) {
		material.side === DoubleSide
			? disable( gl.CULL_FACE )
			: enable( gl.CULL_FACE );
		setFlipSided( material.side === BackSide );
		material.transparent === true
			? setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )
			: setBlending( NoBlending );
		depthBuffer.setFunc( material.depthFunc );
		depthBuffer.setTest( material.depthTest );
		depthBuffer.setMask( material.depthWrite );
		colorBuffer.setMask( material.colorWrite );
		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
	}
	function setFlipSided( flipSided ) {
		if ( currentFlipSided !== flipSided ) {
			if ( flipSided ) {
				gl.frontFace( gl.CW );
			} else {
				gl.frontFace( gl.CCW );
			}
			currentFlipSided = flipSided;
		}
	}
	function setCullFace( cullFace ) {
		if ( cullFace !== CullFaceNone ) {
			enable( gl.CULL_FACE );
			if ( cullFace !== currentCullFace ) {
				if ( cullFace === CullFaceBack ) {
					gl.cullFace( gl.BACK );
				} else if ( cullFace === CullFaceFront ) {
					gl.cullFace( gl.FRONT );
				} else {
					gl.cullFace( gl.FRONT_AND_BACK );
				}
			}
		} else {
			disable( gl.CULL_FACE );
		}
		currentCullFace = cullFace;
	}
	function setLineWidth( width ) {
		if ( width !== currentLineWidth ) {
			if ( lineWidthAvailable ) gl.lineWidth( width );
			currentLineWidth = width;
		}
	}
	function setPolygonOffset( polygonOffset, factor, units ) {
		if ( polygonOffset ) {
			enable( gl.POLYGON_OFFSET_FILL );
			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {
				gl.polygonOffset( factor, units );
				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;
			}
		} else {
			disable( gl.POLYGON_OFFSET_FILL );
		}
	}
	function setScissorTest( scissorTest ) {
		if ( scissorTest ) {
			enable( gl.SCISSOR_TEST );
		} else {
			disable( gl.SCISSOR_TEST );
		}
	}
	function activeTexture( webglSlot ) {
		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;
		if ( currentTextureSlot !== webglSlot ) {
			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;
		}
	}
	function bindTexture( webglType, webglTexture ) {
		if ( currentTextureSlot === null ) {
			activeTexture();
		}
		var boundTexture = currentBoundTextures[ currentTextureSlot ];
		if ( boundTexture === undefined ) {
			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ currentTextureSlot ] = boundTexture;
		}
		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {
			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );
			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;
		}
	}
	function compressedTexImage2D() {
		try {
			gl.compressedTexImage2D.apply( gl, arguments );
		} catch ( error ) {
			console.error( 'THREE.WebGLState:', error );
		}
	}
	function texImage2D() {
		try {
			gl.texImage2D.apply( gl, arguments );
		} catch ( error ) {
			console.error( 'THREE.WebGLState:', error );
		}
	}
	function scissor( scissor ) {
		if ( currentScissor.equals( scissor ) === false ) {
			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			currentScissor.copy( scissor );
		}
	}
	function viewport( viewport ) {
		if ( currentViewport.equals( viewport ) === false ) {
			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			currentViewport.copy( viewport );
		}
	}
	function reset() {
		for ( var i = 0; i < enabledAttributes.length; i ++ ) {
			if ( enabledAttributes[ i ] === 1 ) {
				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;
			}
		}
		capabilities = {};
		compressedTextureFormats = null;
		currentTextureSlot = null;
		currentBoundTextures = {};
		currentProgram = null;
		currentBlending = null;
		currentFlipSided = null;
		currentCullFace = null;
		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();
	}
	return {
		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},
		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		enableAttributeAndDivisor: enableAttributeAndDivisor,
		disableUnusedAttributes: disableUnusedAttributes,
		enable: enable,
		disable: disable,
		getCompressedTextureFormats: getCompressedTextureFormats,
		useProgram: useProgram,
		setBlending: setBlending,
		setMaterial: setMaterial,
		setFlipSided: setFlipSided,
		setCullFace: setCullFace,
		setLineWidth: setLineWidth,
		setPolygonOffset: setPolygonOffset,
		setScissorTest: setScissorTest,
		activeTexture: activeTexture,
		bindTexture: bindTexture,
		compressedTexImage2D: compressedTexImage2D,
		texImage2D: texImage2D,
		scissor: scissor,
		viewport: viewport,
		reset: reset
	};
}
function WebGLCapabilities( gl, extensions, parameters ) {
	var maxAnisotropy;
	function getMaxAnisotropy() {
		if ( maxAnisotropy !== undefined ) return maxAnisotropy;
		var extension = extensions.get( 'EXT_texture_filter_anisotropic' );
		if ( extension !== null ) {
			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );
		} else {
			maxAnisotropy = 0;
		}
		return maxAnisotropy;
	}
	function getMaxPrecision( precision ) {
		if ( precision === 'highp' ) {
			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {
				return 'highp';
			}
			precision = 'mediump';
		}
		if ( precision === 'mediump' ) {
			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {
				return 'mediump';
			}
		}
		return 'lowp';
	}
	var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	var maxPrecision = getMaxPrecision( precision );
	if ( maxPrecision !== precision ) {
		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
		precision = maxPrecision;
	}
	var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
	var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );
	var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
	var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
	var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );
	var vertexTextures = maxVertexTextures > 0;
	var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
	var floatVertexTextures = vertexTextures && floatFragmentTextures;
	return {
		getMaxAnisotropy: getMaxAnisotropy,
		getMaxPrecision: getMaxPrecision,
		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,
		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,
		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,
		vertexTextures: vertexTextures,
		floatFragmentTextures: floatFragmentTextures,
		floatVertexTextures: floatVertexTextures
	};
}
function PerspectiveCamera( fov, aspect, near, far ) {
	Camera.call( this );
	this.type = 'PerspectiveCamera';
	this.fov = fov !== undefined ? fov : 50;
	this.zoom = 1;
	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;
	this.focus = 10;
	this.aspect = aspect !== undefined ? aspect : 1;
	this.view = null;
	this.filmGauge = 35;
	this.filmOffset = 0;
	this.updateProjectionMatrix();
}
PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {
	constructor: PerspectiveCamera,
	isPerspectiveCamera: true,
	copy: function ( source, recursive ) {
		Camera.prototype.copy.call( this, source, recursive );
		this.fov = source.fov;
		this.zoom = source.zoom;
		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;
		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );
		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;
		return this;
	},
	setFocalLength: function ( focalLength ) {
		var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
		this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();
	},
	getFocalLength: function () {
		var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );
		return 0.5 * this.getFilmHeight() / vExtentSlope;
	},
	getEffectiveFOV: function () {
		return _Math.RAD2DEG * 2 * Math.atan(
			Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );
	},
	getFilmWidth: function () {
		return this.filmGauge * Math.min( this.aspect, 1 );
	},
	getFilmHeight: function () {
		return this.filmGauge / Math.max( this.aspect, 1 );
	},
	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {
		this.aspect = fullWidth / fullHeight;
		if ( this.view === null ) {
			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};
		}
		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;
		this.updateProjectionMatrix();
	},
	clearViewOffset: function () {
		if ( this.view !== null ) {
			this.view.enabled = false;
		}
		this.updateProjectionMatrix();
	},
	updateProjectionMatrix: function () {
		var near = this.near,
			top = near * Math.tan(
				_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
			height = 2 * top,
			width = this.aspect * height,
			left = - 0.5 * width,
			view = this.view;
		if ( this.view !== null && this.view.enabled ) {
			var fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;
			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;
		}
		var skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();
		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );
	},
	toJSON: function ( meta ) {
		var data = Object3D.prototype.toJSON.call( this, meta );
		data.object.fov = this.fov;
		data.object.zoom = this.zoom;
		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;
		data.object.aspect = this.aspect;
		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;
		return data;
	}
} );
function ArrayCamera( array ) {
	PerspectiveCamera.call( this );
	this.cameras = array || [];
}
ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {
	constructor: ArrayCamera,
	isArrayCamera: true
} );
function WebVRManager( renderer ) {
	var scope = this;
	var device = null;
	var frameData = null;
	if ( typeof window !== 'undefined' && 'VRFrameData' in window ) {
		frameData = new window.VRFrameData();
	}
	var matrixWorldInverse = new Matrix4();
	var standingMatrix = new Matrix4();
	var standingMatrixInverse = new Matrix4();
	var cameraL = new PerspectiveCamera();
	cameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );
	cameraL.layers.enable( 1 );
	var cameraR = new PerspectiveCamera();
	cameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );
	cameraR.layers.enable( 2 );
	var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
	cameraVR.layers.enable( 1 );
	cameraVR.layers.enable( 2 );
	var currentSize, currentPixelRatio;
	function onVRDisplayPresentChange() {
		if ( device !== null && device.isPresenting ) {
			var eyeParameters = device.getEyeParameters( 'left' );
			var renderWidth = eyeParameters.renderWidth;
			var renderHeight = eyeParameters.renderHeight;
			currentPixelRatio = renderer.getPixelRatio();
			currentSize = renderer.getSize();
			renderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );
		} else if ( scope.enabled ) {
			renderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );
		}
	}
	if ( typeof window !== 'undefined' ) {
		window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );
	}
	this.enabled = false;
	this.standing = false;
	this.getDevice = function () {
		return device;
	};
	this.setDevice = function ( value ) {
		if ( value !== undefined ) device = value;
	};
	this.getCamera = function ( camera ) {
		if ( device === null ) return camera;
		device.depthNear = camera.near;
		device.depthFar = camera.far;
		device.getFrameData( frameData );
		var pose = frameData.pose;
		if ( pose.position !== null ) {
			camera.position.fromArray( pose.position );
		} else {
			camera.position.set( 0, 0, 0 );
		}
		if ( pose.orientation !== null ) {
			camera.quaternion.fromArray( pose.orientation );
		}
		camera.updateMatrixWorld();
		var stageParameters = device.stageParameters;
		if ( this.standing && stageParameters ) {
			standingMatrix.fromArray( stageParameters.sittingToStandingTransform );
			standingMatrixInverse.getInverse( standingMatrix );
			camera.matrixWorld.multiply( standingMatrix );
			camera.matrixWorldInverse.multiply( standingMatrixInverse );
		}
		if ( device.isPresenting === false ) return camera;
		cameraL.near = camera.near;
		cameraR.near = camera.near;
		cameraL.far = camera.far;
		cameraR.far = camera.far;
		cameraVR.matrixWorld.copy( camera.matrixWorld );
		cameraVR.matrixWorldInverse.copy( camera.matrixWorldInverse );
		cameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );
		cameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );
		if ( this.standing && stageParameters ) {
			cameraL.matrixWorldInverse.multiply( standingMatrixInverse );
			cameraR.matrixWorldInverse.multiply( standingMatrixInverse );
		}
		var parent = camera.parent;
		if ( parent !== null ) {
			matrixWorldInverse.getInverse( parent.matrixWorld );
			cameraL.matrixWorldInverse.multiply( matrixWorldInverse );
			cameraR.matrixWorldInverse.multiply( matrixWorldInverse );
		}
		cameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );
		cameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );
		cameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );
		cameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );
		cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );
		var layers = device.getLayers();
		if ( layers.length ) {
			var layer = layers[ 0 ];
			if ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {
				cameraL.bounds.fromArray( layer.leftBounds );
			}
			if ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {
				cameraR.bounds.fromArray( layer.rightBounds );
			}
		}
		return cameraVR;
	};
	this.getStandingMatrix = function () {
		return standingMatrix;
	};
	this.submitFrame = function () {
		if ( device && device.isPresenting ) device.submitFrame();
	};
	this.dispose = function () {
		if ( typeof window !== 'undefined' ) {
			window.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );
		}
	};
}
function WebGLExtensions( gl ) {
	var extensions = {};
	return {
		get: function ( name ) {
			if ( extensions[ name ] !== undefined ) {
				return extensions[ name ];
			}
			var extension;
			switch ( name ) {
				case 'WEBGL_depth_texture':
					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
					break;
				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;
				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;
				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;
				case 'WEBGL_compressed_texture_etc1':
					extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
					break;
				default:
					extension = gl.getExtension( name );
			}
			if ( extension === null ) {
				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );
			}
			extensions[ name ] = extension;
			return extension;
		}
	};
}
function WebGLClipping() {
	var scope = this,
		globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false,
		plane = new Plane(),
		viewNormalMatrix = new Matrix3(),
		uniform = { value: null, needsUpdate: false };
	this.uniform = uniform;
	this.numPlanes = 0;
	this.numIntersection = 0;
	this.init = function ( planes, enableLocalClipping, camera ) {
		var enabled =
			planes.length !== 0 ||
			enableLocalClipping ||
			numGlobalPlanes !== 0 ||
			localClippingEnabled;
		localClippingEnabled = enableLocalClipping;
		globalState = projectPlanes( planes, camera, 0 );
		numGlobalPlanes = planes.length;
		return enabled;
	};
	this.beginShadows = function () {
		renderingShadows = true;
		projectPlanes( null );
	};
	this.endShadows = function () {
		renderingShadows = false;
		resetGlobalState();
	};
	this.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {
		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {
			if ( renderingShadows ) {
				projectPlanes( null );
			} else {
				resetGlobalState();
			}
		} else {
			var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4,
				dstArray = cache.clippingState || null;
			uniform.value = dstArray;
			dstArray = projectPlanes( planes, camera, lGlobal, fromCache );
			for ( var i = 0; i !== lGlobal; ++ i ) {
				dstArray[ i ] = globalState[ i ];
			}
			cache.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;
		}
	};
	function resetGlobalState() {
		if ( uniform.value !== globalState ) {
			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;
		}
		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;
	}
	function projectPlanes( planes, camera, dstOffset, skipTransform ) {
		var nPlanes = planes !== null ? planes.length : 0,
			dstArray = null;
		if ( nPlanes !== 0 ) {
			dstArray = uniform.value;
			if ( skipTransform !== true || dstArray === null ) {
				var flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;
				viewNormalMatrix.getNormalMatrix( viewMatrix );
				if ( dstArray === null || dstArray.length < flatSize ) {
					dstArray = new Float32Array( flatSize );
				}
				for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {
					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );
					plane.normal.toArray( dstArray, i4 );
					dstArray[ i4 + 3 ] = plane.constant;
				}
			}
			uniform.value = dstArray;
			uniform.needsUpdate = true;
		}
		scope.numPlanes = nPlanes;
		return dstArray;
	}
}
function WebGLUtils( gl, extensions ) {
	function convert( p ) {
		var extension;
		if ( p === RepeatWrapping ) return gl.REPEAT;
		if ( p === ClampToEdgeWrapping ) return gl.CLAMP_TO_EDGE;
		if ( p === MirroredRepeatWrapping ) return gl.MIRRORED_REPEAT;
		if ( p === NearestFilter ) return gl.NEAREST;
		if ( p === NearestMipMapNearestFilter ) return gl.NEAREST_MIPMAP_NEAREST;
		if ( p === NearestMipMapLinearFilter ) return gl.NEAREST_MIPMAP_LINEAR;
		if ( p === LinearFilter ) return gl.LINEAR;
		if ( p === LinearMipMapNearestFilter ) return gl.LINEAR_MIPMAP_NEAREST;
		if ( p === LinearMipMapLinearFilter ) return gl.LINEAR_MIPMAP_LINEAR;
		if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
		if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === UnsignedShort565Type ) return gl.UNSIGNED_SHORT_5_6_5;
		if ( p === ByteType ) return gl.BYTE;
		if ( p === ShortType ) return gl.SHORT;
		if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
		if ( p === IntType ) return gl.INT;
		if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
		if ( p === FloatType ) return gl.FLOAT;
		if ( p === HalfFloatType ) {
			extension = extensions.get( 'OES_texture_half_float' );
			if ( extension !== null ) return extension.HALF_FLOAT_OES;
		}
		if ( p === AlphaFormat ) return gl.ALPHA;
		if ( p === RGBFormat ) return gl.RGB;
		if ( p === RGBAFormat ) return gl.RGBA;
		if ( p === LuminanceFormat ) return gl.LUMINANCE;
		if ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;
		if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
		if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;
		if ( p === AddEquation ) return gl.FUNC_ADD;
		if ( p === SubtractEquation ) return gl.FUNC_SUBTRACT;
		if ( p === ReverseSubtractEquation ) return gl.FUNC_REVERSE_SUBTRACT;
		if ( p === ZeroFactor ) return gl.ZERO;
		if ( p === OneFactor ) return gl.ONE;
		if ( p === SrcColorFactor ) return gl.SRC_COLOR;
		if ( p === OneMinusSrcColorFactor ) return gl.ONE_MINUS_SRC_COLOR;
		if ( p === SrcAlphaFactor ) return gl.SRC_ALPHA;
		if ( p === OneMinusSrcAlphaFactor ) return gl.ONE_MINUS_SRC_ALPHA;
		if ( p === DstAlphaFactor ) return gl.DST_ALPHA;
		if ( p === OneMinusDstAlphaFactor ) return gl.ONE_MINUS_DST_ALPHA;
		if ( p === DstColorFactor ) return gl.DST_COLOR;
		if ( p === OneMinusDstColorFactor ) return gl.ONE_MINUS_DST_COLOR;
		if ( p === SrcAlphaSaturateFactor ) return gl.SRC_ALPHA_SATURATE;
		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
			p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {
			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );
			if ( extension !== null ) {
				if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
			}
		}
		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
			p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {
			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );
			if ( extension !== null ) {
				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
			}
		}
		if ( p === RGB_ETC1_Format ) {
			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );
			if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;
		}
		if ( p === MinEquation || p === MaxEquation ) {
			extension = extensions.get( 'EXT_blend_minmax' );
			if ( extension !== null ) {
				if ( p === MinEquation ) return extension.MIN_EXT;
				if ( p === MaxEquation ) return extension.MAX_EXT;
			}
		}
		if ( p === UnsignedInt248Type ) {
			extension = extensions.get( 'WEBGL_depth_texture' );
			if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;
		}
		return 0;
	}
	return { convert: convert };
}
function WebGLRenderer( parameters ) {
	console.log( 'THREE.WebGLRenderer', REVISION );
	parameters = parameters || {};
	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
		_context = parameters.context !== undefined ? parameters.context : null,
		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
	var lightsArray = [];
	var shadowsArray = [];
	var currentRenderList = null;
	var spritesArray = [];
	var flaresArray = [];
	this.domElement = _canvas;
	this.context = null;
	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;
	this.sortObjects = true;
	this.clippingPlanes = [];
	this.localClippingEnabled = false;
	this.gammaFactor = 2.0;
	this.gammaInput = false;
	this.gammaOutput = false;
	this.physicallyCorrectLights = false;
	this.toneMapping = LinearToneMapping;
	this.toneMappingExposure = 1.0;
	this.toneMappingWhitePoint = 1.0;
	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;
	var _this = this,
		_isContextLost = false,
		_currentRenderTarget = null,
		_currentFramebuffer = null,
		_currentMaterialId = - 1,
		_currentGeometryProgram = '',
		_currentCamera = null,
		_currentArrayCamera = null,
		_currentViewport = new Vector4(),
		_currentScissor = new Vector4(),
		_currentScissorTest = null,
		_usedTextureUnits = 0,
		_width = _canvas.width,
		_height = _canvas.height,
		_pixelRatio = 1,
		_viewport = new Vector4( 0, 0, _width, _height ),
		_scissor = new Vector4( 0, 0, _width, _height ),
		_scissorTest = false,
		_frustum = new Frustum(),
		_clipping = new WebGLClipping(),
		_clippingEnabled = false,
		_localClippingEnabled = false,
		_projScreenMatrix = new Matrix4(),
		_vector3 = new Vector3(),
		_infoMemory = {
			geometries: 0,
			textures: 0
		},
		_infoRender = {
			frame: 0,
			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0
		};
	this.info = {
		render: _infoRender,
		memory: _infoMemory,
		programs: null
	};
	function getTargetPixelRatio() {
		return _currentRenderTarget === null ? _pixelRatio : 1;
	}
	var _gl;
	try {
		var contextAttributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer
		};
		_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );
		if ( _gl === null ) {
			if ( _canvas.getContext( 'webgl' ) !== null ) {
				throw 'Error creating WebGL context with your selected attributes.';
			} else {
				throw 'Error creating WebGL context.';
			}
		}
		if ( _gl.getShaderPrecisionFormat === undefined ) {
			_gl.getShaderPrecisionFormat = function () {
				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };
			};
		}
		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );
	} catch ( error ) {
		console.error( 'THREE.WebGLRenderer: ' + error );
	}
	var extensions, capabilities, state;
	var properties, textures, attributes, geometries, objects, lights;
	var programCache, renderLists;
	var background, morphtargets, bufferRenderer, indexedBufferRenderer;
	var flareRenderer, spriteRenderer;
	var utils;
	function initGLContext() {
		extensions = new WebGLExtensions( _gl );
		extensions.get( 'WEBGL_depth_texture' );
		extensions.get( 'OES_texture_float' );
		extensions.get( 'OES_texture_float_linear' );
		extensions.get( 'OES_texture_half_float' );
		extensions.get( 'OES_texture_half_float_linear' );
		extensions.get( 'OES_standard_derivatives' );
		extensions.get( 'OES_element_index_uint' );
		extensions.get( 'ANGLE_instanced_arrays' );
		utils = new WebGLUtils( _gl, extensions );
		capabilities = new WebGLCapabilities( _gl, extensions, parameters );
		state = new WebGLState( _gl, extensions, utils );
		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );
		properties = new WebGLProperties();
		textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, _infoMemory );
		attributes = new WebGLAttributes( _gl );
		geometries = new WebGLGeometries( _gl, attributes, _infoMemory );
		objects = new WebGLObjects( geometries, _infoRender );
		morphtargets = new WebGLMorphtargets( _gl );
		programCache = new WebGLPrograms( _this, extensions, capabilities );
		lights = new WebGLLights();
		renderLists = new WebGLRenderLists();
		background = new WebGLBackground( _this, state, geometries, _premultipliedAlpha );
		bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );
		indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );
		flareRenderer = new WebGLFlareRenderer( _this, _gl, state, textures, capabilities );
		spriteRenderer = new WebGLSpriteRenderer( _this, _gl, state, textures, capabilities );
		_this.info.programs = programCache.programs;
		_this.context = _gl;
		_this.capabilities = capabilities;
		_this.extensions = extensions;
		_this.properties = properties;
		_this.renderLists = renderLists;
		_this.state = state;
	}
	initGLContext();
	var vr = new WebVRManager( _this );
	this.vr = vr;
	var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );
	this.shadowMap = shadowMap;
	this.getContext = function () {
		return _gl;
	};
	this.getContextAttributes = function () {
		return _gl.getContextAttributes();
	};
	this.forceContextLoss = function () {
		var extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.loseContext();
	};
	this.forceContextRestore = function () {
		var extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.restoreContext();
	};
	this.getPixelRatio = function () {
		return _pixelRatio;
	};
	this.setPixelRatio = function ( value ) {
		if ( value === undefined ) return;
		_pixelRatio = value;
		this.setSize( _width, _height, false );
	};
	this.getSize = function () {
		return {
			width: _width,
			height: _height
		};
	};
	this.setSize = function ( width, height, updateStyle ) {
		var device = vr.getDevice();
		if ( device && device.isPresenting ) {
			console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
			return;
		}
		_width = width;
		_height = height;
		_canvas.width = width * _pixelRatio;
		_canvas.height = height * _pixelRatio;
		if ( updateStyle !== false ) {
			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';
		}
		this.setViewport( 0, 0, width, height );
	};
	this.getDrawingBufferSize = function () {
		return {
			width: _width * _pixelRatio,
			height: _height * _pixelRatio
		};
	};
	this.setDrawingBufferSize = function ( width, height, pixelRatio ) {
		_width = width;
		_height = height;
		_pixelRatio = pixelRatio;
		_canvas.width = width * pixelRatio;
		_canvas.height = height * pixelRatio;
		this.setViewport( 0, 0, width, height );
	};
	this.setViewport = function ( x, y, width, height ) {
		_viewport.set( x, _height - y - height, width, height );
		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );
	};
	this.setScissor = function ( x, y, width, height ) {
		_scissor.set( x, _height - y - height, width, height );
		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
	};
	this.setScissorTest = function ( boolean ) {
		state.setScissorTest( _scissorTest = boolean );
	};
	this.getClearColor = function () {
		return background.getClearColor();
	};
	this.setClearColor = function () {
		background.setClearColor.apply( background, arguments );
	};
	this.getClearAlpha = function () {
		return background.getClearAlpha();
	};
	this.setClearAlpha = function () {
		background.setClearAlpha.apply( background, arguments );
	};
	this.clear = function ( color, depth, stencil ) {
		var bits = 0;
		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;
		_gl.clear( bits );
	};
	this.clearColor = function () {
		this.clear( true, false, false );
	};
	this.clearDepth = function () {
		this.clear( false, true, false );
	};
	this.clearStencil = function () {
		this.clear( false, false, true );
	};
	this.clearTarget = function ( renderTarget, color, depth, stencil ) {
		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );
	};
	this.dispose = function () {
		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );
		renderLists.dispose();
		vr.dispose();
	};
	function onContextLost( event ) {
		event.preventDefault();
		console.log( 'THREE.WebGLRenderer: Context Lost.' );
		_isContextLost = true;
	}
	function onContextRestore(             ) {
		console.log( 'THREE.WebGLRenderer: Context Restored.' );
		_isContextLost = false;
		initGLContext();
	}
	function onMaterialDispose( event ) {
		var material = event.target;
		material.removeEventListener( 'dispose', onMaterialDispose );
		deallocateMaterial( material );
	}
	function deallocateMaterial( material ) {
		releaseMaterialProgramReference( material );
		properties.remove( material );
	}
	function releaseMaterialProgramReference( material ) {
		var programInfo = properties.get( material ).program;
		material.program = undefined;
		if ( programInfo !== undefined ) {
			programCache.releaseProgram( programInfo );
		}
	}
	function renderObjectImmediate( object, program, material ) {
		object.render( function ( object ) {
			_this.renderBufferImmediate( object, program, material );
		} );
	}
	this.renderBufferImmediate = function ( object, program, material ) {
		state.initAttributes();
		var buffers = properties.get( object );
		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();
		var programAttributes = program.getAttributes();
		if ( object.hasPositions ) {
			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
			state.enableAttribute( programAttributes.position );
			_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );
		}
		if ( object.hasNormals ) {
			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );
			if ( ! material.isMeshPhongMaterial &&
				! material.isMeshStandardMaterial &&
				! material.isMeshNormalMaterial &&
				material.flatShading === true ) {
				for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {
					var array = object.normalArray;
					var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
					var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
					var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;
					array[ i + 0 ] = nx;
					array[ i + 1 ] = ny;
					array[ i + 2 ] = nz;
					array[ i + 3 ] = nx;
					array[ i + 4 ] = ny;
					array[ i + 5 ] = nz;
					array[ i + 6 ] = nx;
					array[ i + 7 ] = ny;
					array[ i + 8 ] = nz;
				}
			}
			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
			state.enableAttribute( programAttributes.normal );
			_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );
		}
		if ( object.hasUvs && material.map ) {
			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
			state.enableAttribute( programAttributes.uv );
			_gl.vertexAttribPointer( programAttributes.uv, 2, _gl.FLOAT, false, 0, 0 );
		}
		if ( object.hasColors && material.vertexColors !== NoColors ) {
			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
			state.enableAttribute( programAttributes.color );
			_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );
		}
		state.disableUnusedAttributes();
		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );
		object.count = 0;
	};
	this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {
		state.setMaterial( material );
		var program = setProgram( camera, fog, material, object );
		var geometryProgram = geometry.id + '_' + program.id + '_' + ( material.wireframe === true );
		var updateBuffers = false;
		if ( geometryProgram !== _currentGeometryProgram ) {
			_currentGeometryProgram = geometryProgram;
			updateBuffers = true;
		}
		if ( object.morphTargetInfluences ) {
			morphtargets.update( object, geometry, material, program );
			updateBuffers = true;
		}
		var index = geometry.index;
		var position = geometry.attributes.position;
		var rangeFactor = 1;
		if ( material.wireframe === true ) {
			index = geometries.getWireframeAttribute( geometry );
			rangeFactor = 2;
		}
		var attribute;
		var renderer = bufferRenderer;
		if ( index !== null ) {
			attribute = attributes.get( index );
			renderer = indexedBufferRenderer;
			renderer.setIndex( attribute );
		}
		if ( updateBuffers ) {
			setupVertexAttributes( material, program, geometry );
			if ( index !== null ) {
				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attribute.buffer );
			}
		}
		var dataCount = 0;
		if ( index !== null ) {
			dataCount = index.count;
		} else if ( position !== undefined ) {
			dataCount = position.count;
		}
		var rangeStart = geometry.drawRange.start * rangeFactor;
		var rangeCount = geometry.drawRange.count * rangeFactor;
		var groupStart = group !== null ? group.start * rangeFactor : 0;
		var groupCount = group !== null ? group.count * rangeFactor : Infinity;
		var drawStart = Math.max( rangeStart, groupStart );
		var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;
		var drawCount = Math.max( 0, drawEnd - drawStart + 1 );
		if ( drawCount === 0 ) return;
		if ( object.isMesh ) {
			if ( material.wireframe === true ) {
				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
				renderer.setMode( _gl.LINES );
			} else {
				switch ( object.drawMode ) {
					case TrianglesDrawMode:
						renderer.setMode( _gl.TRIANGLES );
						break;
					case TriangleStripDrawMode:
						renderer.setMode( _gl.TRIANGLE_STRIP );
						break;
					case TriangleFanDrawMode:
						renderer.setMode( _gl.TRIANGLE_FAN );
						break;
				}
			}
		} else if ( object.isLine ) {
			var lineWidth = material.linewidth;
			if ( lineWidth === undefined ) lineWidth = 1;
			state.setLineWidth( lineWidth * getTargetPixelRatio() );
			if ( object.isLineSegments ) {
				renderer.setMode( _gl.LINES );
			} else if ( object.isLineLoop ) {
				renderer.setMode( _gl.LINE_LOOP );
			} else {
				renderer.setMode( _gl.LINE_STRIP );
			}
		} else if ( object.isPoints ) {
			renderer.setMode( _gl.POINTS );
		}
		if ( geometry && geometry.isInstancedBufferGeometry ) {
			if ( geometry.maxInstancedCount > 0 ) {
				renderer.renderInstances( geometry, drawStart, drawCount );
			}
		} else {
			renderer.render( drawStart, drawCount );
		}
	};
	function setupVertexAttributes( material, program, geometry, startIndex ) {
		if ( geometry && geometry.isInstancedBufferGeometry ) {
			if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {
				console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;
			}
		}
		if ( startIndex === undefined ) startIndex = 0;
		state.initAttributes();
		var geometryAttributes = geometry.attributes;
		var programAttributes = program.getAttributes();
		var materialDefaultAttributeValues = material.defaultAttributeValues;
		for ( var name in programAttributes ) {
			var programAttribute = programAttributes[ name ];
			if ( programAttribute >= 0 ) {
				var geometryAttribute = geometryAttributes[ name ];
				if ( geometryAttribute !== undefined ) {
					var normalized = geometryAttribute.normalized;
					var size = geometryAttribute.itemSize;
					var attribute = attributes.get( geometryAttribute );
					if ( attribute === undefined ) continue;
					var buffer = attribute.buffer;
					var type = attribute.type;
					var bytesPerElement = attribute.bytesPerElement;
					if ( geometryAttribute.isInterleavedBufferAttribute ) {
						var data = geometryAttribute.data;
						var stride = data.stride;
						var offset = geometryAttribute.offset;
						if ( data && data.isInstancedInterleavedBuffer ) {
							state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );
							if ( geometry.maxInstancedCount === undefined ) {
								geometry.maxInstancedCount = data.meshPerAttribute * data.count;
							}
						} else {
							state.enableAttribute( programAttribute );
						}
						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
						_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, ( startIndex * stride + offset ) * bytesPerElement );
					} else {
						if ( geometryAttribute.isInstancedBufferAttribute ) {
							state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );
							if ( geometry.maxInstancedCount === undefined ) {
								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
							}
						} else {
							state.enableAttribute( programAttribute );
						}
						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
						_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement );
					}
				} else if ( materialDefaultAttributeValues !== undefined ) {
					var value = materialDefaultAttributeValues[ name ];
					if ( value !== undefined ) {
						switch ( value.length ) {
							case 2:
								_gl.vertexAttrib2fv( programAttribute, value );
								break;
							case 3:
								_gl.vertexAttrib3fv( programAttribute, value );
								break;
							case 4:
								_gl.vertexAttrib4fv( programAttribute, value );
								break;
							default:
								_gl.vertexAttrib1fv( programAttribute, value );
						}
					}
				}
			}
		}
		state.disableUnusedAttributes();
	}
	this.compile = function ( scene, camera ) {
		lightsArray.length = 0;
		shadowsArray.length = 0;
		scene.traverse( function ( object ) {
			if ( object.isLight ) {
				lightsArray.push( object );
				if ( object.castShadow ) {
					shadowsArray.push( object );
				}
			}
		} );
		lights.setup( lightsArray, shadowsArray, camera );
		scene.traverse( function ( object ) {
			if ( object.material ) {
				if ( Array.isArray( object.material ) ) {
					for ( var i = 0; i < object.material.length; i ++ ) {
						initMaterial( object.material[ i ], scene.fog, object );
					}
				} else {
					initMaterial( object.material, scene.fog, object );
				}
			}
		} );
	};
	var isAnimating = false;
	var onAnimationFrame = null;
	function start() {
		if ( isAnimating ) return;
		var device = vr.getDevice();
		if ( device && device.isPresenting ) {
			device.requestAnimationFrame( loop );
		} else {
			window.requestAnimationFrame( loop );
		}
		isAnimating = true;
	}
	function loop( time ) {
		if ( onAnimationFrame !== null ) onAnimationFrame( time );
		var device = vr.getDevice();
		if ( device && device.isPresenting ) {
			device.requestAnimationFrame( loop );
		} else {
			window.requestAnimationFrame( loop );
		}
	}
	this.animate = function ( callback ) {
		onAnimationFrame = callback;
		start();
	};
	this.render = function ( scene, camera, renderTarget, forceClear ) {
		if ( ! ( camera && camera.isCamera ) ) {
			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;
		}
		if ( _isContextLost ) return;
		_currentGeometryProgram = '';
		_currentMaterialId = - 1;
		_currentCamera = null;
		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
		if ( camera.parent === null ) camera.updateMatrixWorld();
		if ( vr.enabled ) {
			camera = vr.getCamera( camera );
		}
		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );
		lightsArray.length = 0;
		shadowsArray.length = 0;
		spritesArray.length = 0;
		flaresArray.length = 0;
		_localClippingEnabled = this.localClippingEnabled;
		_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );
		currentRenderList = renderLists.get( scene, camera );
		currentRenderList.init();
		projectObject( scene, camera, _this.sortObjects );
		if ( _this.sortObjects === true ) {
			currentRenderList.sort();
		}
		if ( _clippingEnabled ) _clipping.beginShadows();
		shadowMap.render( shadowsArray, scene, camera );
		lights.setup( lightsArray, shadowsArray, camera );
		if ( _clippingEnabled ) _clipping.endShadows();
		_infoRender.frame ++;
		_infoRender.calls = 0;
		_infoRender.vertices = 0;
		_infoRender.faces = 0;
		_infoRender.points = 0;
		if ( renderTarget === undefined ) {
			renderTarget = null;
		}
		this.setRenderTarget( renderTarget );
		background.render( currentRenderList, scene, camera, forceClear );
		var opaqueObjects = currentRenderList.opaque;
		var transparentObjects = currentRenderList.transparent;
		if ( scene.overrideMaterial ) {
			var overrideMaterial = scene.overrideMaterial;
			if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );
			if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );
		} else {
			if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );
			if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );
		}
		spriteRenderer.render( spritesArray, scene, camera );
		flareRenderer.render( flaresArray, scene, camera, _currentViewport );
		if ( renderTarget ) {
			textures.updateRenderTargetMipmap( renderTarget );
		}
		state.buffers.depth.setTest( true );
		state.buffers.depth.setMask( true );
		state.buffers.color.setMask( true );
		state.setPolygonOffset( false );
		if ( vr.enabled ) {
			vr.submitFrame();
		}
	};
	function projectObject( object, camera, sortObjects ) {
		if ( object.visible === false ) return;
		var visible = object.layers.test( camera.layers );
		if ( visible ) {
			if ( object.isLight ) {
				lightsArray.push( object );
				if ( object.castShadow ) {
					shadowsArray.push( object );
				}
			} else if ( object.isSprite ) {
				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {
					spritesArray.push( object );
				}
			} else if ( object.isLensFlare ) {
				flaresArray.push( object );
			} else if ( object.isImmediateRenderObject ) {
				if ( sortObjects ) {
					_vector3.setFromMatrixPosition( object.matrixWorld )
						.applyMatrix4( _projScreenMatrix );
				}
				currentRenderList.push( object, null, object.material, _vector3.z, null );
			} else if ( object.isMesh || object.isLine || object.isPoints ) {
				if ( object.isSkinnedMesh ) {
					object.skeleton.update();
				}
				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {
					if ( sortObjects ) {
						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );
					}
					var geometry = objects.update( object );
					var material = object.material;
					if ( Array.isArray( material ) ) {
						var groups = geometry.groups;
						for ( var i = 0, l = groups.length; i < l; i ++ ) {
							var group = groups[ i ];
							var groupMaterial = material[ group.materialIndex ];
							if ( groupMaterial && groupMaterial.visible ) {
								currentRenderList.push( object, geometry, groupMaterial, _vector3.z, group );
							}
						}
					} else if ( material.visible ) {
						currentRenderList.push( object, geometry, material, _vector3.z, null );
					}
				}
			}
		}
		var children = object.children;
		for ( var i = 0, l = children.length; i < l; i ++ ) {
			projectObject( children[ i ], camera, sortObjects );
		}
	}
	function renderObjects( renderList, scene, camera, overrideMaterial ) {
		for ( var i = 0, l = renderList.length; i < l; i ++ ) {
			var renderItem = renderList[ i ];
			var object = renderItem.object;
			var geometry = renderItem.geometry;
			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
			var group = renderItem.group;
			if ( camera.isArrayCamera ) {
				_currentArrayCamera = camera;
				var cameras = camera.cameras;
				for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {
					var camera2 = cameras[ j ];
					if ( object.layers.test( camera2.layers ) ) {
						var bounds = camera2.bounds;
						var x = bounds.x * _width;
						var y = bounds.y * _height;
						var width = bounds.z * _width;
						var height = bounds.w * _height;
						state.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );
						renderObject( object, scene, camera2, geometry, material, group );
					}
				}
			} else {
				_currentArrayCamera = null;
				renderObject( object, scene, camera, geometry, material, group );
			}
		}
	}
	function renderObject( object, scene, camera, geometry, material, group ) {
		object.onBeforeRender( _this, scene, camera, geometry, material, group );
		object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object.normalMatrix.getNormalMatrix( object.modelViewMatrix );
		if ( object.isImmediateRenderObject ) {
			state.setMaterial( material );
			var program = setProgram( camera, scene.fog, material, object );
			_currentGeometryProgram = '';
			renderObjectImmediate( object, program, material );
		} else {
			_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );
		}
		object.onAfterRender( _this, scene, camera, geometry, material, group );
	}
	function initMaterial( material, fog, object ) {
		var materialProperties = properties.get( material );
		var parameters = programCache.getParameters(
			material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );
		var code = programCache.getProgramCode( material, parameters );
		var program = materialProperties.program;
		var programChange = true;
		if ( program === undefined ) {
			material.addEventListener( 'dispose', onMaterialDispose );
		} else if ( program.code !== code ) {
			releaseMaterialProgramReference( material );
		} else if ( parameters.shaderID !== undefined ) {
			return;
		} else {
			programChange = false;
		}
		if ( programChange ) {
			if ( parameters.shaderID ) {
				var shader = ShaderLib[ parameters.shaderID ];
				materialProperties.shader = {
					name: material.type,
					uniforms: UniformsUtils.clone( shader.uniforms ),
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader
				};
			} else {
				materialProperties.shader = {
					name: material.type,
					uniforms: material.uniforms,
					vertexShader: material.vertexShader,
					fragmentShader: material.fragmentShader
				};
			}
			material.onBeforeCompile( materialProperties.shader );
			program = programCache.acquireProgram( material, materialProperties.shader, parameters, code );
			materialProperties.program = program;
			material.program = program;
		}
		var programAttributes = program.getAttributes();
		if ( material.morphTargets ) {
			material.numSupportedMorphTargets = 0;
			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {
				if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {
					material.numSupportedMorphTargets ++;
				}
			}
		}
		if ( material.morphNormals ) {
			material.numSupportedMorphNormals = 0;
			for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {
				if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {
					material.numSupportedMorphNormals ++;
				}
			}
		}
		var uniforms = materialProperties.shader.uniforms;
		if ( ! material.isShaderMaterial &&
			! material.isRawShaderMaterial ||
			material.clipping === true ) {
			materialProperties.numClippingPlanes = _clipping.numPlanes;
			materialProperties.numIntersection = _clipping.numIntersection;
			uniforms.clippingPlanes = _clipping.uniform;
		}
		materialProperties.fog = fog;
		materialProperties.lightsHash = lights.state.hash;
		if ( material.lights ) {
			uniforms.ambientLightColor.value = lights.state.ambient;
			uniforms.directionalLights.value = lights.state.directional;
			uniforms.spotLights.value = lights.state.spot;
			uniforms.rectAreaLights.value = lights.state.rectArea;
			uniforms.pointLights.value = lights.state.point;
			uniforms.hemisphereLights.value = lights.state.hemi;
			uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
			uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
			uniforms.spotShadowMap.value = lights.state.spotShadowMap;
			uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
			uniforms.pointShadowMap.value = lights.state.pointShadowMap;
			uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
		}
		var progUniforms = materialProperties.program.getUniforms(),
			uniformsList =
				WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );
		materialProperties.uniformsList = uniformsList;
	}
	function setProgram( camera, fog, material, object ) {
		_usedTextureUnits = 0;
		var materialProperties = properties.get( material );
		if ( _clippingEnabled ) {
			if ( _localClippingEnabled || camera !== _currentCamera ) {
				var useCache =
					camera === _currentCamera &&
					material.id === _currentMaterialId;
				_clipping.setState(
					material.clippingPlanes, material.clipIntersection, material.clipShadows,
					camera, materialProperties, useCache );
			}
		}
		if ( material.needsUpdate === false ) {
			if ( materialProperties.program === undefined ) {
				material.needsUpdate = true;
			} else if ( material.fog && materialProperties.fog !== fog ) {
				material.needsUpdate = true;
			} else if ( material.lights && materialProperties.lightsHash !== lights.state.hash ) {
				material.needsUpdate = true;
			} else if ( materialProperties.numClippingPlanes !== undefined &&
				( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
				materialProperties.numIntersection !== _clipping.numIntersection ) ) {
				material.needsUpdate = true;
			}
		}
		if ( material.needsUpdate ) {
			initMaterial( material, fog, object );
			material.needsUpdate = false;
		}
		var refreshProgram = false;
		var refreshMaterial = false;
		var refreshLights = false;
		var program = materialProperties.program,
			p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.shader.uniforms;
		if ( state.useProgram( program.program ) ) {
			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;
		}
		if ( material.id !== _currentMaterialId ) {
			_currentMaterialId = material.id;
			refreshMaterial = true;
		}
		if ( refreshProgram || camera !== _currentCamera ) {
			p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );
			if ( capabilities.logarithmicDepthBuffer ) {
				p_uniforms.setValue( _gl, 'logDepthBufFC',
					2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );
			}
			if ( _currentCamera !== ( _currentArrayCamera || camera ) ) {
				_currentCamera = ( _currentArrayCamera || camera );
				refreshMaterial = true;
				refreshLights = true;
			}
			if ( material.isShaderMaterial ||
				material.isMeshPhongMaterial ||
				material.isMeshStandardMaterial ||
				material.envMap ) {
				var uCamPos = p_uniforms.map.cameraPosition;
				if ( uCamPos !== undefined ) {
					uCamPos.setValue( _gl,
						_vector3.setFromMatrixPosition( camera.matrixWorld ) );
				}
			}
			if ( material.isMeshPhongMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ||
				material.skinning ) {
				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );
			}
		}
		if ( material.skinning ) {
			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );
			var skeleton = object.skeleton;
			if ( skeleton ) {
				var bones = skeleton.bones;
				if ( capabilities.floatVertexTextures ) {
					if ( skeleton.boneTexture === undefined ) {
						var size = Math.sqrt( bones.length * 4 );
						size = _Math.ceilPowerOfTwo( size );
						size = Math.max( size, 4 );
						var boneMatrices = new Float32Array( size * size * 4 );
						boneMatrices.set( skeleton.boneMatrices );
						var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
						skeleton.boneMatrices = boneMatrices;
						skeleton.boneTexture = boneTexture;
						skeleton.boneTextureSize = size;
					}
					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );
					p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );
				} else {
					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );
				}
			}
		}
		if ( refreshMaterial ) {
			p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
			p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );
			if ( material.lights ) {
				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );
			}
			if ( fog && material.fog ) {
				refreshUniformsFog( m_uniforms, fog );
			}
			if ( material.isMeshBasicMaterial ) {
				refreshUniformsCommon( m_uniforms, material );
			} else if ( material.isMeshLambertMaterial ) {
				refreshUniformsCommon( m_uniforms, material );
				refreshUniformsLambert( m_uniforms, material );
			} else if ( material.isMeshPhongMaterial ) {
				refreshUniformsCommon( m_uniforms, material );
				if ( material.isMeshToonMaterial ) {
					refreshUniformsToon( m_uniforms, material );
				} else {
					refreshUniformsPhong( m_uniforms, material );
				}
			} else if ( material.isMeshStandardMaterial ) {
				refreshUniformsCommon( m_uniforms, material );
				if ( material.isMeshPhysicalMaterial ) {
					refreshUniformsPhysical( m_uniforms, material );
				} else {
					refreshUniformsStandard( m_uniforms, material );
				}
			} else if ( material.isMeshDepthMaterial ) {
				refreshUniformsCommon( m_uniforms, material );
				refreshUniformsDepth( m_uniforms, material );
			} else if ( material.isMeshDistanceMaterial ) {
				refreshUniformsCommon( m_uniforms, material );
				refreshUniformsDistance( m_uniforms, material );
			} else if ( material.isMeshNormalMaterial ) {
				refreshUniformsCommon( m_uniforms, material );
				refreshUniformsNormal( m_uniforms, material );
			} else if ( material.isLineBasicMaterial ) {
				refreshUniformsLine( m_uniforms, material );
				if ( material.isLineDashedMaterial ) {
					refreshUniformsDash( m_uniforms, material );
				}
			} else if ( material.isPointsMaterial ) {
				refreshUniformsPoints( m_uniforms, material );
			} else if ( material.isShadowMaterial ) {
				m_uniforms.color.value = material.color;
				m_uniforms.opacity.value = material.opacity;
			}
			if ( m_uniforms.ltcMat !== undefined ) m_uniforms.ltcMat.value = UniformsLib.LTC_MAT_TEXTURE;
			if ( m_uniforms.ltcMag !== undefined ) m_uniforms.ltcMag.value = UniformsLib.LTC_MAG_TEXTURE;
			WebGLUniforms.upload(
				_gl, materialProperties.uniformsList, m_uniforms, _this );
		}
		p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
		p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );
		return program;
	}
	function refreshUniformsCommon( uniforms, material ) {
		uniforms.opacity.value = material.opacity;
		if ( material.color ) {
			uniforms.diffuse.value = material.color;
		}
		if ( material.emissive ) {
			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );
		}
		if ( material.map ) {
			uniforms.map.value = material.map;
		}
		if ( material.alphaMap ) {
			uniforms.alphaMap.value = material.alphaMap;
		}
		if ( material.specularMap ) {
			uniforms.specularMap.value = material.specularMap;
		}
		if ( material.envMap ) {
			uniforms.envMap.value = material.envMap;
			uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;
			uniforms.reflectivity.value = material.reflectivity;
			uniforms.refractionRatio.value = material.refractionRatio;
		}
		if ( material.lightMap ) {
			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;
		}
		if ( material.aoMap ) {
			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;
		}
		var uvScaleMap;
		if ( material.map ) {
			uvScaleMap = material.map;
		} else if ( material.specularMap ) {
			uvScaleMap = material.specularMap;
		} else if ( material.displacementMap ) {
			uvScaleMap = material.displacementMap;
		} else if ( material.normalMap ) {
			uvScaleMap = material.normalMap;
		} else if ( material.bumpMap ) {
			uvScaleMap = material.bumpMap;
		} else if ( material.roughnessMap ) {
			uvScaleMap = material.roughnessMap;
		} else if ( material.metalnessMap ) {
			uvScaleMap = material.metalnessMap;
		} else if ( material.alphaMap ) {
			uvScaleMap = material.alphaMap;
		} else if ( material.emissiveMap ) {
			uvScaleMap = material.emissiveMap;
		}
		if ( uvScaleMap !== undefined ) {
			if ( uvScaleMap.isWebGLRenderTarget ) {
				uvScaleMap = uvScaleMap.texture;
			}
			if ( uvScaleMap.matrixAutoUpdate === true ) {
				var offset = uvScaleMap.offset;
				var repeat = uvScaleMap.repeat;
				var rotation = uvScaleMap.rotation;
				var center = uvScaleMap.center;
				uvScaleMap.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );
			}
			uniforms.uvTransform.value.copy( uvScaleMap.matrix );
		}
	}
	function refreshUniformsLine( uniforms, material ) {
		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;
	}
	function refreshUniformsDash( uniforms, material ) {
		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;
	}
	function refreshUniformsPoints( uniforms, material ) {
		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * _pixelRatio;
		uniforms.scale.value = _height * 0.5;
		uniforms.map.value = material.map;
		if ( material.map !== null ) {
			if ( material.map.matrixAutoUpdate === true ) {
				var offset = material.map.offset;
				var repeat = material.map.repeat;
				var rotation = material.map.rotation;
				var center = material.map.center;
				material.map.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );
			}
			uniforms.uvTransform.value.copy( material.map.matrix );
		}
	}
	function refreshUniformsFog( uniforms, fog ) {
		uniforms.fogColor.value = fog.color;
		if ( fog.isFog ) {
			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;
		} else if ( fog.isFogExp2 ) {
			uniforms.fogDensity.value = fog.density;
		}
	}
	function refreshUniformsLambert( uniforms, material ) {
		if ( material.emissiveMap ) {
			uniforms.emissiveMap.value = material.emissiveMap;
		}
	}
	function refreshUniformsPhong( uniforms, material ) {
		uniforms.specular.value = material.specular;
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 );
		if ( material.emissiveMap ) {
			uniforms.emissiveMap.value = material.emissiveMap;
		}
		if ( material.bumpMap ) {
			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
		}
		if ( material.normalMap ) {
			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
		}
		if ( material.displacementMap ) {
			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;
		}
	}
	function refreshUniformsToon( uniforms, material ) {
		refreshUniformsPhong( uniforms, material );
		if ( material.gradientMap ) {
			uniforms.gradientMap.value = material.gradientMap;
		}
	}
	function refreshUniformsStandard( uniforms, material ) {
		uniforms.roughness.value = material.roughness;
		uniforms.metalness.value = material.metalness;
		if ( material.roughnessMap ) {
			uniforms.roughnessMap.value = material.roughnessMap;
		}
		if ( material.metalnessMap ) {
			uniforms.metalnessMap.value = material.metalnessMap;
		}
		if ( material.emissiveMap ) {
			uniforms.emissiveMap.value = material.emissiveMap;
		}
		if ( material.bumpMap ) {
			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
		}
		if ( material.normalMap ) {
			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
		}
		if ( material.displacementMap ) {
			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;
		}
		if ( material.envMap ) {
			uniforms.envMapIntensity.value = material.envMapIntensity;
		}
	}
	function refreshUniformsPhysical( uniforms, material ) {
		uniforms.clearCoat.value = material.clearCoat;
		uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
		refreshUniformsStandard( uniforms, material );
	}
	function refreshUniformsDepth( uniforms, material ) {
		if ( material.displacementMap ) {
			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;
		}
	}
	function refreshUniformsDistance( uniforms, material ) {
		if ( material.displacementMap ) {
			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;
		}
		uniforms.referencePosition.value.copy( material.referencePosition );
		uniforms.nearDistance.value = material.nearDistance;
		uniforms.farDistance.value = material.farDistance;
	}
	function refreshUniformsNormal( uniforms, material ) {
		if ( material.bumpMap ) {
			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
		}
		if ( material.normalMap ) {
			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
		}
		if ( material.displacementMap ) {
			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;
		}
	}
	function markUniformsLightsNeedsUpdate( uniforms, value ) {
		uniforms.ambientLightColor.needsUpdate = value;
		uniforms.directionalLights.needsUpdate = value;
		uniforms.pointLights.needsUpdate = value;
		uniforms.spotLights.needsUpdate = value;
		uniforms.rectAreaLights.needsUpdate = value;
		uniforms.hemisphereLights.needsUpdate = value;
	}
	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {
		state.setCullFace( cullFace );
		state.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );
	};
	function allocTextureUnit() {
		var textureUnit = _usedTextureUnits;
		if ( textureUnit >= capabilities.maxTextures ) {
			console.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );
		}
		_usedTextureUnits += 1;
		return textureUnit;
	}
	this.allocTextureUnit = allocTextureUnit;
	this.setTexture2D = ( function () {
		var warned = false;
		return function setTexture2D( texture, slot ) {
			if ( texture && texture.isWebGLRenderTarget ) {
				if ( ! warned ) {
					console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
					warned = true;
				}
				texture = texture.texture;
			}
			textures.setTexture2D( texture, slot );
		};
	}() );
	this.setTexture = ( function () {
		var warned = false;
		return function setTexture( texture, slot ) {
			if ( ! warned ) {
				console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
				warned = true;
			}
			textures.setTexture2D( texture, slot );
		};
	}() );
	this.setTextureCube = ( function () {
		var warned = false;
		return function setTextureCube( texture, slot ) {
			if ( texture && texture.isWebGLRenderTargetCube ) {
				if ( ! warned ) {
					console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
					warned = true;
				}
				texture = texture.texture;
			}
			if ( ( texture && texture.isCubeTexture ) ||
				( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {
				textures.setTextureCube( texture, slot );
			} else {
				textures.setTextureCubeDynamic( texture, slot );
			}
		};
	}() );
	this.getRenderTarget = function () {
		return _currentRenderTarget;
	};
	this.setRenderTarget = function ( renderTarget ) {
		_currentRenderTarget = renderTarget;
		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {
			textures.setupRenderTarget( renderTarget );
		}
		var framebuffer = null;
		var isCube = false;
		if ( renderTarget ) {
			var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;
			if ( renderTarget.isWebGLRenderTargetCube ) {
				framebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ];
				isCube = true;
			} else {
				framebuffer = __webglFramebuffer;
			}
			_currentViewport.copy( renderTarget.viewport );
			_currentScissor.copy( renderTarget.scissor );
			_currentScissorTest = renderTarget.scissorTest;
		} else {
			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
			_currentScissorTest = _scissorTest;
		}
		if ( _currentFramebuffer !== framebuffer ) {
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_currentFramebuffer = framebuffer;
		}
		state.viewport( _currentViewport );
		state.scissor( _currentScissor );
		state.setScissorTest( _currentScissorTest );
		if ( isCube ) {
			var textureProperties = properties.get( renderTarget.texture );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );
		}
	};
	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {
		if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {
			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			return;
		}
		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;
		if ( framebuffer ) {
			var restore = false;
			if ( framebuffer !== _currentFramebuffer ) {
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				restore = true;
			}
			try {
				var texture = renderTarget.texture;
				var textureFormat = texture.format;
				var textureType = texture.type;
				if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {
					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					return;
				}
				if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) &&
					! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) &&
					! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {
					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					return;
				}
				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {
					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {
						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );
					}
				} else {
					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );
				}
			} finally {
				if ( restore ) {
					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );
				}
			}
		}
	};
}
function FogExp2( color, density ) {
	this.name = '';
	this.color = new Color( color );
	this.density = ( density !== undefined ) ? density : 0.00025;
}
FogExp2.prototype.isFogExp2 = true;
FogExp2.prototype.clone = function () {
	return new FogExp2( this.color.getHex(), this.density );
};
FogExp2.prototype.toJSON = function (            ) {
	return {
		type: 'FogExp2',
		color: this.color.getHex(),
		density: this.density
	};
};
function Fog( color, near, far ) {
	this.name = '';
	this.color = new Color( color );
	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;
}
Fog.prototype.isFog = true;
Fog.prototype.clone = function () {
	return new Fog( this.color.getHex(), this.near, this.far );
};
Fog.prototype.toJSON = function (            ) {
	return {
		type: 'Fog',
		color: this.color.getHex(),
		near: this.near,
		far: this.far
	};
};
function Scene() {
	Object3D.call( this );
	this.type = 'Scene';
	this.background = null;
	this.fog = null;
	this.overrideMaterial = null;
	this.autoUpdate = true;
}
Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {
	constructor: Scene,
	copy: function ( source, recursive ) {
		Object3D.prototype.copy.call( this, source, recursive );
		if ( source.background !== null ) this.background = source.background.clone();
		if ( source.fog !== null ) this.fog = source.fog.clone();
		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();
		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;
		return this;
	},
	toJSON: function ( meta ) {
		var data = Object3D.prototype.toJSON.call( this, meta );
		if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();
		return data;
	}
} );
function LensFlare( texture, size, distance, blending, color ) {
	Object3D.call( this );
	this.lensFlares = [];
	this.positionScreen = new Vector3();
	this.customUpdateCallback = undefined;
	if ( texture !== undefined ) {
		this.add( texture, size, distance, blending, color );
	}
}
LensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {
	constructor: LensFlare,
	isLensFlare: true,
	copy: function ( source ) {
		Object3D.prototype.copy.call( this, source );
		this.positionScreen.copy( source.positionScreen );
		this.customUpdateCallback = source.customUpdateCallback;
		for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {
			this.lensFlares.push( source.lensFlares[ i ] );
		}
		return this;
	},
	add: function ( texture, size, distance, blending, color, opacity ) {
		if ( size === undefined ) size = - 1;
		if ( distance === undefined ) distance = 0;
		if ( opacity === undefined ) opacity = 1;
		if ( color === undefined ) color = new Color( 0xffffff );
		if ( blending === undefined ) blending = NormalBlending;
		distance = Math.min( distance, Math.max( 0, distance ) );
		this.lensFlares.push( {
			texture: texture,
			size: size,
			distance: distance,
			x: 0, y: 0, z: 0,
			scale: 1,
			rotation: 0,
			opacity: opacity,
			color: color,
			blending: blending
		} );
	},
	updateLensFlares: function () {
		var f, fl = this.lensFlares.length;
		var flare;
		var vecX = - this.positionScreen.x * 2;
		var vecY = - this.positionScreen.y * 2;
		for ( f = 0; f < fl; f ++ ) {
			flare = this.lensFlares[ f ];
			flare.x = this.positionScreen.x + vecX * flare.distance;
			flare.y = this.positionScreen.y + vecY * flare.distance;
			flare.wantedRotation = flare.x * Math.PI * 0.25;
			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;
		}
	}
} );
function SpriteMaterial( parameters ) {
	Material.call( this );
	this.type = 'SpriteMaterial';
	this.color = new Color( 0xffffff );
	this.map = null;
	this.rotation = 0;
	this.fog = false;
	this.lights = false;
	this.setValues( parameters );
}
SpriteMaterial.prototype = Object.create( Material.prototype );
SpriteMaterial.prototype.constructor = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = true;
SpriteMaterial.prototype.copy = function ( source ) {
	Material.prototype.copy.call( this, source );
	this.color.copy( source.color );
	this.map = source.map;
	this.rotation = source.rotation;
	return this;
};
function Sprite( material ) {
	Object3D.call( this );
	this.type = 'Sprite';
	this.material = ( material !== undefined ) ? material : new SpriteMaterial();
}
Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {
	constructor: Sprite,
	isSprite: true,
	raycast: ( function () {
		var intersectPoint = new Vector3();
		var worldPosition = new Vector3();
		var worldScale = new Vector3();
		return function raycast( raycaster, intersects ) {
			worldPosition.setFromMatrixPosition( this.matrixWorld );
			raycaster.ray.closestPointToPoint( worldPosition, intersectPoint );
			worldScale.setFromMatrixScale( this.matrixWorld );
			var guessSizeSq = worldScale.x * worldScale.y / 4;
			if ( worldPosition.distanceToSquared( intersectPoint ) > guessSizeSq ) return;
			var distance = raycaster.ray.origin.distanceTo( intersectPoint );
			if ( distance < raycaster.near || distance > raycaster.far ) return;
			intersects.push( {
				distance: distance,
				point: intersectPoint.clone(),
				face: null,
				object: this
			} );
		};
	}() ),
	clone: function () {
		return new this.constructor( this.material ).copy( this );
	}
} );
function LOD() {
	Object3D.call( this );
	this.type = 'LOD';
	Object.defineProperties( this, {
		levels: {
			enumerable: true,
			value: []
		}
	} );
}
LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {
	constructor: LOD,
	copy: function ( source ) {
		Object3D.prototype.copy.call( this, source, false );
		var levels = source.levels;
		for ( var i = 0, l = levels.length; i < l; i ++ ) {
			var level = levels[ i ];
			this.addLevel( level.object.clone(), level.distance );
		}
		return this;
	},
	addLevel: function ( object, distance ) {
		if ( distance === undefined ) distance = 0;
		distance = Math.abs( distance );
		var levels = this.levels;
		for ( var l = 0; l < levels.length; l ++ ) {
			if ( distance < levels[ l ].distance ) {
				break;
			}
		}
		levels.splice( l, 0, { distance: distance, object: object } );
		this.add( object );
	},
	getObjectForDistance: function ( distance ) {
		var levels = this.levels;
		for ( var i = 1, l = levels.length; i < l; i ++ ) {
			if ( distance < levels[ i ].distance ) {
				break;
			}
		}
		return levels[ i - 1 ].object;
	},
	raycast: ( function () {
		var matrixPosition = new Vector3();
		return function raycast( raycaster, intersects ) {
			matrixPosition.setFromMatrixPosition( this.matrixWorld );
			var distance = raycaster.ray.origin.distanceTo( matrixPosition );
			this.getObjectForDistance( distance ).raycast( raycaster, intersects );
		};
	}() ),
	update: function () {
		var v1 = new Vector3();
		var v2 = new Vector3();
		return function update( camera ) {
			var levels = this.levels;
			if ( levels.length > 1 ) {
				v1.setFromMatrixPosition( camera.matrixWorld );
				v2.setFromMatrixPosition( this.matrixWorld );
				var distance = v1.distanceTo( v2 );
				levels[ 0 ].object.visible = true;
				for ( var i = 1, l = levels.length; i < l; i ++ ) {
					if ( distance >= levels[ i ].distance ) {
						levels[ i - 1 ].object.visible = false;
						levels[ i ].object.visible = true;
					} else {
						break;
					}
				}
				for ( ; i < l; i ++ ) {
					levels[ i ].object.visible = false;
				}
			}
		};
	}(),
	toJSON: function ( meta ) {
		var data = Object3D.prototype.toJSON.call( this, meta );
		data.object.levels = [];
		var levels = this.levels;
		for ( var i = 0, l = levels.length; i < l; i ++ ) {
			var level = levels[ i ];
			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance
			} );
		}
		return data;
	}
} );
function Skeleton( bones, boneInverses ) {
	bones = bones || [];
	this.bones = bones.slice( 0 );
	this.boneMatrices = new Float32Array( this.bones.length * 16 );
	if ( boneInverses === undefined ) {
		this.calculateInverses();
	} else {
		if ( this.bones.length === boneInverses.length ) {
			this.boneInverses = boneInverses.slice( 0 );
		} else {
			console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );
			this.boneInverses = [];
			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {
				this.boneInverses.push( new Matrix4() );
			}
		}
	}
}
Object.assign( Skeleton.prototype, {
	calculateInverses: function () {
		this.boneInverses = [];
		for ( var i = 0, il = this.bones.length; i < il; i ++ ) {
			var inverse = new Matrix4();
			if ( this.bones[ i ] ) {
				inverse.getInverse( this.bones[ i ].matrixWorld );
			}
			this.boneInverses.push( inverse );
		}
	},
	pose: function () {
		var bone, i, il;
		for ( i = 0, il = this.bones.length; i < il; i ++ ) {
			bone = this.bones[ i ];
			if ( bone ) {
				bone.matrixWorld.getInverse( this.boneInverses[ i ] );
			}
		}
		for ( i = 0, il = this.bones.length; i < il; i ++ ) {
			bone = this.bones[ i ];
			if ( bone ) {
				if ( bone.parent && bone.parent.isBone ) {
					bone.matrix.getInverse( bone.parent.matrixWorld );
					bone.matrix.multiply( bone.matrixWorld );
				} else {
					bone.matrix.copy( bone.matrixWorld );
				}
				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );
			}
		}
	},
	update: ( function () {
		var offsetMatrix = new Matrix4();
		var identityMatrix = new Matrix4();
		return function update() {
			var bones = this.bones;
			var boneInverses = this.boneInverses;
			var boneMatrices = this.boneMatrices;
			var boneTexture = this.boneTexture;
			for ( var i = 0, il = bones.length; i < il; i ++ ) {
				var matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;
				offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
				offsetMatrix.toArray( boneMatrices, i * 16 );
			}
			if ( boneTexture !== undefined ) {
				boneTexture.needsUpdate = true;
			}
		};
	} )(),
	clone: function () {
		return new Skeleton( this.bones, this.boneInverses );
	}
} );
function Bone() {
	Object3D.call( this );
	this.type = 'Bone';
}
Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {
	constructor: Bone,
	isBone: true
} );
function SkinnedMesh( geometry, material ) {
	Mesh.call( this, geometry, material );
	this.type = 'SkinnedMesh';
	this.bindMode = 'attached';
	this.bindMatrix = new Matrix4();
	this.bindMatrixInverse = new Matrix4();
	var bones = this.initBones();
	var skeleton = new Skeleton( bones );
	this.bind( skeleton, this.matrixWorld );
	this.normalizeSkinWeights();
}
SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {
	constructor: SkinnedMesh,
	isSkinnedMesh: true,
	initBones: function () {
		var bones = [], bone, gbone;
		var i, il;
		if ( this.geometry && this.geometry.bones !== undefined ) {
			for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {
				gbone = this.geometry.bones[ i ];
				bone = new Bone();
				bones.push( bone );
				bone.name = gbone.name;
				bone.position.fromArray( gbone.pos );
				bone.quaternion.fromArray( gbone.rotq );
				if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );
			}
			for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {
				gbone = this.geometry.bones[ i ];
				if ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {
					bones[ gbone.parent ].add( bones[ i ] );
				} else {
					this.add( bones[ i ] );
				}
			}
		}
		this.updateMatrixWorld( true );
		return bones;
	},
	bind: function ( skeleton, bindMatrix ) {
		this.skeleton = skeleton;
		if ( bindMatrix === undefined ) {
			this.updateMatrixWorld( true );
			this.skeleton.calculateInverses();
			bindMatrix = this.matrixWorld;
		}
		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.getInverse( bindMatrix );
	},
	pose: function () {
		this.skeleton.pose();
	},
	normalizeSkinWeights: function () {
		var scale, i;
		if ( this.geometry && this.geometry.isGeometry ) {
			for ( i = 0; i < this.geometry.skinWeights.length; i ++ ) {
				var sw = this.geometry.skinWeights[ i ];
				scale = 1.0 / sw.manhattanLength();
				if ( scale !== Infinity ) {
					sw.multiplyScalar( scale );
				} else {
					sw.set( 1, 0, 0, 0 );
				}
			}
		} else if ( this.geometry && this.geometry.isBufferGeometry ) {
			var vec = new Vector4();
			var skinWeight = this.geometry.attributes.skinWeight;
			for ( i = 0; i < skinWeight.count; i ++ ) {
				vec.x = skinWeight.getX( i );
				vec.y = skinWeight.getY( i );
				vec.z = skinWeight.getZ( i );
				vec.w = skinWeight.getW( i );
				scale = 1.0 / vec.manhattanLength();
				if ( scale !== Infinity ) {
					vec.multiplyScalar( scale );
				} else {
					vec.set( 1, 0, 0, 0 );
				}
				skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );
			}
		}
	},
	updateMatrixWorld: function ( force ) {
		Mesh.prototype.updateMatrixWorld.call( this, force );
		if ( this.bindMode === 'attached' ) {
			this.bindMatrixInverse.getInverse( this.matrixWorld );
		} else if ( this.bindMode === 'detached' ) {
			this.bindMatrixInverse.getInverse( this.bindMatrix );
		} else {
			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );
		}
	},
	clone: function () {
		return new this.constructor( this.geometry, this.material ).copy( this );
	}
} );
function LineBasicMaterial( parameters ) {
	Material.call( this );
	this.type = 'LineBasicMaterial';
	this.color = new Color( 0xffffff );
	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';
	this.lights = false;
	this.setValues( parameters );
}
LineBasicMaterial.prototype = Object.create( Material.prototype );
LineBasicMaterial.prototype.constructor = LineBasicMaterial;
LineBasicMaterial.prototype.isLineBasicMaterial = true;
LineBasicMaterial.prototype.copy = function ( source ) {
	Material.prototype.copy.call( this, source );
	this.color.copy( source.color );
	this.linewidth = source.linewidth;
	this.linecap = source.linecap;
	this.linejoin = source.linejoin;
	return this;
};
function Line( geometry, material, mode ) {
	if ( mode === 1 ) {
		console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
		return new LineSegments( geometry, material );
	}
	Object3D.call( this );
	this.type = 'Line';
	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );
}
Line.prototype = Object.assign( Object.create( Object3D.prototype ), {
	constructor: Line,
	isLine: true,
	raycast: ( function () {
		var inverseMatrix = new Matrix4();
		var ray = new Ray();
		var sphere = new Sphere();
		return function raycast( raycaster, intersects ) {
			var precision = raycaster.linePrecision;
			var precisionSq = precision * precision;
			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;
			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );
			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
			var vStart = new Vector3();
			var vEnd = new Vector3();
			var interSegment = new Vector3();
			var interRay = new Vector3();
			var step = ( this && this.isLineSegments ) ? 2 : 1;
			if ( geometry.isBufferGeometry ) {
				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;
				if ( index !== null ) {
					var indices = index.array;
					for ( var i = 0, l = indices.length - 1; i < l; i += step ) {
						var a = indices[ i ];
						var b = indices[ i + 1 ];
						vStart.fromArray( positions, a * 3 );
						vEnd.fromArray( positions, b * 3 );
						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
						if ( distSq > precisionSq ) continue;
						interRay.applyMatrix4( this.matrixWorld );
						var distance = raycaster.ray.origin.distanceTo( interRay );
						if ( distance < raycaster.near || distance > raycaster.far ) continue;
						intersects.push( {
							distance: distance,
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this
						} );
					}
				} else {
					for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {
						vStart.fromArray( positions, 3 * i );
						vEnd.fromArray( positions, 3 * i + 3 );
						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
						if ( distSq > precisionSq ) continue;
						interRay.applyMatrix4( this.matrixWorld );
						var distance = raycaster.ray.origin.distanceTo( interRay );
						if ( distance < raycaster.near || distance > raycaster.far ) continue;
						intersects.push( {
							distance: distance,
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this
						} );
					}
				}
			} else if ( geometry.isGeometry ) {
				var vertices = geometry.vertices;
				var nbVertices = vertices.length;
				for ( var i = 0; i < nbVertices - 1; i += step ) {
					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );
					if ( distSq > precisionSq ) continue;
					interRay.applyMatrix4( this.matrixWorld );
					var distance = raycaster.ray.origin.distanceTo( interRay );
					if ( distance < raycaster.near || distance > raycaster.far ) continue;
					intersects.push( {
						distance: distance,
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this
					} );
				}
			}
		};
	}() ),
	clone: function () {
		return new this.constructor( this.geometry, this.material ).copy( this );
	}
} );
function LineSegments( geometry, material ) {
	Line.call( this, geometry, material );
	this.type = 'LineSegments';
}
LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {
	constructor: LineSegments,
	isLineSegments: true
} );
function LineLoop( geometry, material ) {
	Line.call( this, geometry, material );
	this.type = 'LineLoop';
}
LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {
	constructor: LineLoop,
	isLineLoop: true,
} );
function PointsMaterial( parameters ) {
	Material.call( this );
	this.type = 'PointsMaterial';
	this.color = new Color( 0xffffff );
	this.map = null;
	this.size = 1;
	this.sizeAttenuation = true;
	this.lights = false;
	this.setValues( parameters );
}
PointsMaterial.prototype = Object.create( Material.prototype );
PointsMaterial.prototype.constructor = PointsMaterial;
PointsMaterial.prototype.isPointsMaterial = true;
PointsMaterial.prototype.copy = function ( source ) {
	Material.prototype.copy.call( this, source );
	this.color.copy( source.color );
	this.map = source.map;
	this.size = source.size;
	this.sizeAttenuation = source.sizeAttenuation;
	return this;
};
function Points( geometry, material ) {
	Object3D.call( this );
	this.type = 'Points';
	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );
}
Points.prototype = Object.assign( Object.create( Object3D.prototype ), {
	constructor: Points,
	isPoints: true,
	raycast: ( function () {
		var inverseMatrix = new Matrix4();
		var ray = new Ray();
		var sphere = new Sphere();
		return function raycast( raycaster, intersects ) {
			var object = this;
			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;
			var threshold = raycaster.params.Points.threshold;
			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );
			sphere.radius += threshold;
			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			var localThresholdSq = localThreshold * localThreshold;
			var position = new Vector3();
			function testPoint( point, index ) {
				var rayPointDistanceSq = ray.distanceSqToPoint( point );
				if ( rayPointDistanceSq < localThresholdSq ) {
					var intersectPoint = ray.closestPointToPoint( point );
					intersectPoint.applyMatrix4( matrixWorld );
					var distance = raycaster.ray.origin.distanceTo( intersectPoint );
					if ( distance < raycaster.near || distance > raycaster.far ) return;
					intersects.push( {
						distance: distance,
						distanceToRay: Math.sqrt( rayPointDistanceSq ),
						point: intersectPoint.clone(),
						index: index,
						face: null,
						object: object
					} );
				}
			}
			if ( geometry.isBufferGeometry ) {
				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;
				if ( index !== null ) {
					var indices = index.array;
					for ( var i = 0, il = indices.length; i < il; i ++ ) {
						var a = indices[ i ];
						position.fromArray( positions, a * 3 );
						testPoint( position, a );
					}
				} else {
					for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {
						position.fromArray( positions, i * 3 );
						testPoint( position, i );
					}
				}
			} else {
				var vertices = geometry.vertices;
				for ( var i = 0, l = vertices.length; i < l; i ++ ) {
					testPoint( vertices[ i ], i );
				}
			}
		};
	}() ),
	clone: function () {
		return new this.constructor( this.geometry, this.material ).copy( this );
	}
} );
function Group() {
	Object3D.call( this );
	this.type = 'Group';
}
Group.prototype = Object.assign( Object.create( Object3D.prototype ), {
	constructor: Group
} );
function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	this.generateMipmaps = false;
	var scope = this;
	function update() {
		var video = scope.image;
		if ( video.readyState >= video.HAVE_CURRENT_DATA ) {
			scope.needsUpdate = true;
		}
		requestAnimationFrame( update );
	}
	requestAnimationFrame( update );
}
VideoTexture.prototype = Object.create( Texture.prototype );
VideoTexture.prototype.constructor = VideoTexture;
function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {
	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;
	this.flipY = false;
	this.generateMipmaps = false;
}
CompressedTexture.prototype = Object.create( Texture.prototype );
CompressedTexture.prototype.constructor = CompressedTexture;
CompressedTexture.prototype.isCompressedTexture = true;
function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {
	format = format !== undefined ? format : DepthFormat;
	if ( format !== DepthFormat && format !== DepthStencilFormat ) {
		throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );
	}
	if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
	if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;
	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	this.image = { width: width, height: height };
	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
	this.flipY = false;
	this.generateMipmaps	= false;
}
DepthTexture.prototype = Object.create( Texture.prototype );
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;
function WireframeGeometry( geometry ) {
	BufferGeometry.call( this );
	this.type = 'WireframeGeometry';
	var vertices = [];
	var i, j, l, o, ol;
	var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
	var key, keys = [ 'a', 'b', 'c' ];
	var vertex;
	if ( geometry && geometry.isGeometry ) {
		var faces = geometry.faces;
		for ( i = 0, l = faces.length; i < l; i ++ ) {
			var face = faces[ i ];
			for ( j = 0; j < 3; j ++ ) {
				edge1 = face[ keys[ j ] ];
				edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
				edge[ 0 ] = Math.min( edge1, edge2 );
				edge[ 1 ] = Math.max( edge1, edge2 );
				key = edge[ 0 ] + ',' + edge[ 1 ];
				if ( edges[ key ] === undefined ) {
					edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };
				}
			}
		}
		for ( key in edges ) {
			e = edges[ key ];
			vertex = geometry.vertices[ e.index1 ];
			vertices.push( vertex.x, vertex.y, vertex.z );
			vertex = geometry.vertices[ e.index2 ];
			vertices.push( vertex.x, vertex.y, vertex.z );
		}
	} else if ( geometry && geometry.isBufferGeometry ) {
		var position, indices, groups;
		var group, start, count;
		var index1, index2;
		vertex = new Vector3();
		if ( geometry.index !== null ) {
			position = geometry.attributes.position;
			indices = geometry.index;
			groups = geometry.groups;
			if ( groups.length === 0 ) {
				groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];
			}
			for ( o = 0, ol = groups.length; o < ol; ++ o ) {
				group = groups[ o ];
				start = group.start;
				count = group.count;
				for ( i = start, l = ( start + count ); i < l; i += 3 ) {
					for ( j = 0; j < 3; j ++ ) {
						edge1 = indices.getX( i + j );
						edge2 = indices.getX( i + ( j + 1 ) % 3 );
						edge[ 0 ] = Math.min( edge1, edge2 );
						edge[ 1 ] = Math.max( edge1, edge2 );
						key = edge[ 0 ] + ',' + edge[ 1 ];
						if ( edges[ key ] === undefined ) {
							edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };
						}
					}
				}
			}
			for ( key in edges ) {
				e = edges[ key ];
				vertex.fromBufferAttribute( position, e.index1 );
				vertices.push( vertex.x, vertex.y, vertex.z );
				vertex.fromBufferAttribute( position, e.index2 );
				vertices.push( vertex.x, vertex.y, vertex.z );
			}
		} else {
			position = geometry.attributes.position;
			for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {
				for ( j = 0; j < 3; j ++ ) {
					index1 = 3 * i + j;
					vertex.fromBufferAttribute( position, index1 );
					vertices.push( vertex.x, vertex.y, vertex.z );
					index2 = 3 * i + ( ( j + 1 ) % 3 );
					vertex.fromBufferAttribute( position, index2 );
					vertices.push( vertex.x, vertex.y, vertex.z );
				}
			}
		}
	}
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
}
WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
WireframeGeometry.prototype.constructor = WireframeGeometry;
function ParametricGeometry( func, slices, stacks ) {
	Geometry.call( this );
	this.type = 'ParametricGeometry';
	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};
	this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
	this.mergeVertices();
}
ParametricGeometry.prototype = Object.create( Geometry.prototype );
ParametricGeometry.prototype.constructor = ParametricGeometry;
function ParametricBufferGeometry( func, slices, stacks ) {
	BufferGeometry.call( this );
	this.type = 'ParametricBufferGeometry';
	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};
	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];
	var EPS = 0.00001;
	var normal = new Vector3();
	var p0 = new Vector3(), p1 = new Vector3();
	var pu = new Vector3(), pv = new Vector3();
	var i, j;
	var sliceCount = slices + 1;
	for ( i = 0; i <= stacks; i ++ ) {
		var v = i / stacks;
		for ( j = 0; j <= slices; j ++ ) {
			var u = j / slices;
			p0 = func( u, v, p0 );
			vertices.push( p0.x, p0.y, p0.z );
			if ( u - EPS >= 0 ) {
				p1 = func( u - EPS, v, p1 );
				pu.subVectors( p0, p1 );
			} else {
				p1 = func( u + EPS, v, p1 );
				pu.subVectors( p1, p0 );
			}
			if ( v - EPS >= 0 ) {
				p1 = func( u, v - EPS, p1 );
				pv.subVectors( p0, p1 );
			} else {
				p1 = func( u, v + EPS, p1 );
				pv.subVectors( p1, p0 );
			}
			normal.crossVectors( pu, pv ).normalize();
			normals.push( normal.x, normal.y, normal.z );
			uvs.push( u, v );
		}
	}
	for ( i = 0; i < stacks; i ++ ) {
		for ( j = 0; j < slices; j ++ ) {
			var a = i * sliceCount + j;
			var b = i * sliceCount + j + 1;
			var c = ( i + 1 ) * sliceCount + j + 1;
			var d = ( i + 1 ) * sliceCount + j;
			indices.push( a, b, d );
			indices.push( b, c, d );
		}
	}
	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
}
ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
function PolyhedronGeometry( vertices, indices, radius, detail ) {
	Geometry.call( this );
	this.type = 'PolyhedronGeometry';
	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};
	this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
	this.mergeVertices();
}
PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {
	BufferGeometry.call( this );
	this.type = 'PolyhedronBufferGeometry';
	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};
	radius = radius || 1;
	detail = detail || 0;
	var vertexBuffer = [];
	var uvBuffer = [];
	subdivide( detail );
	appplyRadius( radius );
	generateUVs();
	this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );
	if ( detail === 0 ) {
		this.computeVertexNormals();
	} else {
		this.normalizeNormals();
	}
	function subdivide( detail ) {
		var a = new Vector3();
		var b = new Vector3();
		var c = new Vector3();
		for ( var i = 0; i < indices.length; i += 3 ) {
			getVertexByIndex( indices[ i + 0 ], a );
			getVertexByIndex( indices[ i + 1 ], b );
			getVertexByIndex( indices[ i + 2 ], c );
			subdivideFace( a, b, c, detail );
		}
	}
	function subdivideFace( a, b, c, detail ) {
		var cols = Math.pow( 2, detail );
		var v = [];
		var i, j;
		for ( i = 0; i <= cols; i ++ ) {
			v[ i ] = [];
			var aj = a.clone().lerp( c, i / cols );
			var bj = b.clone().lerp( c, i / cols );
			var rows = cols - i;
			for ( j = 0; j <= rows; j ++ ) {
				if ( j === 0 && i === cols ) {
					v[ i ][ j ] = aj;
				} else {
					v[ i ][ j ] = aj.clone().lerp( bj, j / rows );
				}
			}
		}
		for ( i = 0; i < cols; i ++ ) {
			for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {
				var k = Math.floor( j / 2 );
				if ( j % 2 === 0 ) {
					pushVertex( v[ i ][ k + 1 ] );
					pushVertex( v[ i + 1 ][ k ] );
					pushVertex( v[ i ][ k ] );
				} else {
					pushVertex( v[ i ][ k + 1 ] );
					pushVertex( v[ i + 1 ][ k + 1 ] );
					pushVertex( v[ i + 1 ][ k ] );
				}
			}
		}
	}
	function appplyRadius( radius ) {
		var vertex = new Vector3();
		for ( var i = 0; i < vertexBuffer.length; i += 3 ) {
			vertex.x = vertexBuffer[ i + 0 ];
			vertex.y = vertexBuffer[ i + 1 ];
			vertex.z = vertexBuffer[ i + 2 ];
			vertex.normalize().multiplyScalar( radius );
			vertexBuffer[ i + 0 ] = vertex.x;
			vertexBuffer[ i + 1 ] = vertex.y;
			vertexBuffer[ i + 2 ] = vertex.z;
		}
	}
	function generateUVs() {
		var vertex = new Vector3();
		for ( var i = 0; i < vertexBuffer.length; i += 3 ) {
			vertex.x = vertexBuffer[ i + 0 ];
			vertex.y = vertexBuffer[ i + 1 ];
			vertex.z = vertexBuffer[ i + 2 ];
			var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
			var v = inclination( vertex ) / Math.PI + 0.5;
			uvBuffer.push( u, 1 - v );
		}
		correctUVs();
		correctSeam();
	}
	function correctSeam() {
		for ( var i = 0; i < uvBuffer.length; i += 6 ) {
			var x0 = uvBuffer[ i + 0 ];
			var x1 = uvBuffer[ i + 2 ];
			var x2 = uvBuffer[ i + 4 ];
			var max = Math.max( x0, x1, x2 );
			var min = Math.min( x0, x1, x2 );
			if ( max > 0.9 && min < 0.1 ) {
				if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
				if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
				if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;
			}
		}
	}
	function pushVertex( vertex ) {
		vertexBuffer.push( vertex.x, vertex.y, vertex.z );
	}
	function getVertexByIndex( index, vertex ) {
		var stride = index * 3;
		vertex.x = vertices[ stride + 0 ];
		vertex.y = vertices[ stride + 1 ];
		vertex.z = vertices[ stride + 2 ];
	}
	function correctUVs() {
		var a = new Vector3();
		var b = new Vector3();
		var c = new Vector3();
		var centroid = new Vector3();
		var uvA = new Vector2();
		var uvB = new Vector2();
		var uvC = new Vector2();
		for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {
			a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
			b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
			c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );
			uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
			uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
			uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );
			centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );
			var azi = azimuth( centroid );
			correctUV( uvA, j + 0, a, azi );
			correctUV( uvB, j + 2, b, azi );
			correctUV( uvC, j + 4, c, azi );
		}
	}
	function correctUV( uv, stride, vector, azimuth ) {
		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {
			uvBuffer[ stride ] = uv.x - 1;
		}
		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {
			uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;
		}
	}
	function azimuth( vector ) {
		return Math.atan2( vector.z, - vector.x );
	}
	function inclination( vector ) {
		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );
	}
}
PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
function TetrahedronGeometry( radius, detail ) {
	Geometry.call( this );
	this.type = 'TetrahedronGeometry';
	this.parameters = {
		radius: radius,
		detail: detail
	};
	this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();
}
TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
function TetrahedronBufferGeometry( radius, detail ) {
	var vertices = [
		1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
	];
	var indices = [
		2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
	];
	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	this.type = 'TetrahedronBufferGeometry';
	this.parameters = {
		radius: radius,
		detail: detail
	};
}
TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
function OctahedronGeometry( radius, detail ) {
	Geometry.call( this );
	this.type = 'OctahedronGeometry';
	this.parameters = {
		radius: radius,
		detail: detail
	};
	this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();
}
OctahedronGeometry.prototype = Object.create( Geometry.prototype );
OctahedronGeometry.prototype.constructor = OctahedronGeometry;
function OctahedronBufferGeometry( radius, detail ) {
	var vertices = [
		1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
		0, - 1, 0, 	0, 0, 1,	0, 0, - 1
	];
	var indices = [
		0, 2, 4,	0, 4, 3,	0, 3, 5,
		0, 5, 2,	1, 2, 5,	1, 5, 3,
		1, 3, 4,	1, 4, 2
	];
	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	this.type = 'OctahedronBufferGeometry';
	this.parameters = {
		radius: radius,
		detail: detail
	};
}
OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
function IcosahedronGeometry( radius, detail ) {
	Geometry.call( this );
	this.type = 'IcosahedronGeometry';
	this.parameters = {
		radius: radius,
		detail: detail
	};
	this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();
}
IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
function IcosahedronBufferGeometry( radius, detail ) {
	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	var vertices = [
		- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
		 0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
		 t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
	];
	var indices = [
		 0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
		 1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
		 3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
		 4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
	];
	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	this.type = 'IcosahedronBufferGeometry';
	this.parameters = {
		radius: radius,
		detail: detail
	};
}
IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
function DodecahedronGeometry( radius, detail ) {
	Geometry.call( this );
	this.type = 'DodecahedronGeometry';
	this.parameters = {
		radius: radius,
		detail: detail
	};
	this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();
}
DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
function DodecahedronBufferGeometry( radius, detail ) {
	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	var r = 1 / t;
	var vertices = [
		- 1, - 1, - 1,	- 1, - 1, 1,
		- 1, 1, - 1, - 1, 1, 1,
		1, - 1, - 1, 1, - 1, 1,
		1, 1, - 1, 1, 1, 1,
		 0, - r, - t, 0, - r, t,
		 0, r, - t, 0, r, t,
		- r, - t, 0, - r, t, 0,
		 r, - t, 0, r, t, 0,
		- t, 0, - r, t, 0, - r,
		- t, 0, r, t, 0, r
	];
	var indices = [
		3, 11, 7, 	3, 7, 15, 	3, 15, 13,
		7, 19, 17, 	7, 17, 6, 	7, 6, 15,
		17, 4, 8, 	17, 8, 10, 	17, 10, 6,
		8, 0, 16, 	8, 16, 2, 	8, 2, 10,
		0, 12, 1, 	0, 1, 18, 	0, 18, 16,
		6, 10, 2, 	6, 2, 13, 	6, 13, 15,
		2, 16, 18, 	2, 18, 3, 	2, 3, 13,
		18, 1, 9, 	18, 9, 11, 	18, 11, 3,
		4, 14, 12, 	4, 12, 0, 	4, 0, 8,
		11, 9, 5, 	11, 5, 19, 	11, 19, 7,
		19, 5, 14, 	19, 14, 4, 	19, 4, 17,
		1, 12, 14, 	1, 14, 5, 	1, 5, 9
	];
	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	this.type = 'DodecahedronBufferGeometry';
	this.parameters = {
		radius: radius,
		detail: detail
	};
}
DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {
	Geometry.call( this );
	this.type = 'TubeGeometry';
	this.parameters = {
		path: path,
		tubularSegments: tubularSegments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed
	};
	if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );
	var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );
	this.tangents = bufferGeometry.tangents;
	this.normals = bufferGeometry.normals;
	this.binormals = bufferGeometry.binormals;
	this.fromBufferGeometry( bufferGeometry );
	this.mergeVertices();
}
TubeGeometry.prototype = Object.create( Geometry.prototype );
TubeGeometry.prototype.constructor = TubeGeometry;
function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {
	BufferGeometry.call( this );
	this.type = 'TubeBufferGeometry';
	this.parameters = {
		path: path,
		tubularSegments: tubularSegments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed
	};
	tubularSegments = tubularSegments || 64;
	radius = radius || 1;
	radialSegments = radialSegments || 8;
	closed = closed || false;
	var frames = path.computeFrenetFrames( tubularSegments, closed );
	this.tangents = frames.tangents;
	this.normals = frames.normals;
	this.binormals = frames.binormals;
	var vertex = new Vector3();
	var normal = new Vector3();
	var uv = new Vector2();
	var P = new Vector3();
	var i, j;
	var vertices = [];
	var normals = [];
	var uvs = [];
	var indices = [];
	generateBufferData();
	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	function generateBufferData() {
		for ( i = 0; i < tubularSegments; i ++ ) {
			generateSegment( i );
		}
		generateSegment( ( closed === false ) ? tubularSegments : 0 );
		generateUVs();
		generateIndices();
	}
	function generateSegment( i ) {
		P = path.getPointAt( i / tubularSegments, P );
		var N = frames.normals[ i ];
		var B = frames.binormals[ i ];
		for ( j = 0; j <= radialSegments; j ++ ) {
			var v = j / radialSegments * Math.PI * 2;
			var sin = Math.sin( v );
			var cos = - Math.cos( v );
			normal.x = ( cos * N.x + sin * B.x );
			normal.y = ( cos * N.y + sin * B.y );
			normal.z = ( cos * N.z + sin * B.z );
			normal.normalize();
			normals.push( normal.x, normal.y, normal.z );
			vertex.x = P.x + radius * normal.x;
			vertex.y = P.y + radius * normal.y;
			vertex.z = P.z + radius * normal.z;
			vertices.push( vertex.x, vertex.y, vertex.z );
		}
	}
	function generateIndices() {
		for ( j = 1; j <= tubularSegments; j ++ ) {
			for ( i = 1; i <= radialSegments; i ++ ) {
				var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				var b = ( radialSegments + 1 ) * j + ( i - 1 );
				var c = ( radialSegments + 1 ) * j + i;
				var d = ( radialSegments + 1 ) * ( j - 1 ) + i;
				indices.push( a, b, d );
				indices.push( b, c, d );
			}
		}
	}
	function generateUVs() {
		for ( i = 0; i <= tubularSegments; i ++ ) {
			for ( j = 0; j <= radialSegments; j ++ ) {
				uv.x = i / tubularSegments;
				uv.y = j / radialSegments;
				uvs.push( uv.x, uv.y );
			}
		}
	}
}
TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {
	Geometry.call( this );
	this.type = 'TorusKnotGeometry';
	this.parameters = {
		radius: radius,
		tube: tube,
		tubularSegments: tubularSegments,
		radialSegments: radialSegments,
		p: p,
		q: q
	};
	if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );
	this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
	this.mergeVertices();
}
TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {
	BufferGeometry.call( this );
	this.type = 'TorusKnotBufferGeometry';
	this.parameters = {
		radius: radius,
		tube: tube,
		tubularSegments: tubularSegments,
		radialSegments: radialSegments,
		p: p,
		q: q
	};
	radius = radius || 1;
	tube = tube || 0.4;
	tubularSegments = Math.floor( tubularSegments ) || 64;
	radialSegments = Math.floor( radialSegments ) || 8;
	p = p || 2;
	q = q || 3;
	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];
	var i, j;
	var vertex = new Vector3();
	var normal = new Vector3();
	var P1 = new Vector3();
	var P2 = new Vector3();
	var B = new Vector3();
	var T = new Vector3();
	var N = new Vector3();
	for ( i = 0; i <= tubularSegments; ++ i ) {
		var u = i / tubularSegments * p * Math.PI * 2;
		calculatePositionOnCurve( u, p, q, radius, P1 );
		calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );
		T.subVectors( P2, P1 );
		N.addVectors( P2, P1 );
		B.crossVectors( T, N );
		N.crossVectors( B, T );
		B.normalize();
		N.normalize();
		for ( j = 0; j <= radialSegments; ++ j ) {
			var v = j / radialSegments * Math.PI * 2;
			var cx = - tube * Math.cos( v );
			var cy = tube * Math.sin( v );
			vertex.x = P1.x + ( cx * N.x + cy * B.x );
			vertex.y = P1.y + ( cx * N.y + cy * B.y );
			vertex.z = P1.z + ( cx * N.z + cy * B.z );
			vertices.push( vertex.x, vertex.y, vertex.z );
			normal.subVectors( vertex, P1 ).normalize();
			normals.push( normal.x, normal.y, normal.z );
			uvs.push( i / tubularSegments );
			uvs.push( j / radialSegments );
		}
	}
	for ( j = 1; j <= tubularSegments; j ++ ) {
		for ( i = 1; i <= radialSegments; i ++ ) {
			var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
			var b = ( radialSegments + 1 ) * j + ( i - 1 );
			var c = ( radialSegments + 1 ) * j + i;
			var d = ( radialSegments + 1 ) * ( j - 1 ) + i;
			indices.push( a, b, d );
			indices.push( b, c, d );
		}
	}
	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	function calculatePositionOnCurve( u, p, q, radius, position ) {
		var cu = Math.cos( u );
		var su = Math.sin( u );
		var quOverP = q / p * u;
		var cs = Math.cos( quOverP );
		position.x = radius * ( 2 + cs ) * 0.5 * cu;
		position.y = radius * ( 2 + cs ) * su * 0.5;
		position.z = radius * Math.sin( quOverP ) * 0.5;
	}
}
TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {
	Geometry.call( this );
	this.type = 'TorusGeometry';
	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};
	this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
	this.mergeVertices();
}
TorusGeometry.prototype = Object.create( Geometry.prototype );
TorusGeometry.prototype.constructor = TorusGeometry;
function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {
	BufferGeometry.call( this );
	this.type = 'TorusBufferGeometry';
	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};
	radius = radius || 1;
	tube = tube || 0.4;
	radialSegments = Math.floor( radialSegments ) || 8;
	tubularSegments = Math.floor( tubularSegments ) || 6;
	arc = arc || Math.PI * 2;
	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];
	var center = new Vector3();
	var vertex = new Vector3();
	var normal = new Vector3();
	var j, i;
	for ( j = 0; j <= radialSegments; j ++ ) {
		for ( i = 0; i <= tubularSegments; i ++ ) {
			var u = i / tubularSegments * arc;
			var v = j / radialSegments * Math.PI * 2;
			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
			vertex.z = tube * Math.sin( v );
			vertices.push( vertex.x, vertex.y, vertex.z );
			center.x = radius * Math.cos( u );
			center.y = radius * Math.sin( u );
			normal.subVectors( vertex, center ).normalize();
			normals.push( normal.x, normal.y, normal.z );
			uvs.push( i / tubularSegments );
			uvs.push( j / radialSegments );
		}
	}
	for ( j = 1; j <= radialSegments; j ++ ) {
		for ( i = 1; i <= tubularSegments; i ++ ) {
			var a = ( tubularSegments + 1 ) * j + i - 1;
			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
			var d = ( tubularSegments + 1 ) * j + i;
			indices.push( a, b, d );
			indices.push( b, c, d );
		}
	}
	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
}
TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
var ShapeUtils = {
	area: function ( contour ) {
		var n = contour.length;
		var a = 0.0;
		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {
			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;
		}
		return a * 0.5;
	},
	triangulate: ( function () {
		function snip( contour, u, v, w, n, verts ) {
			var p;
			var ax, ay, bx, by;
			var cx, cy, px, py;
			ax = contour[ verts[ u ] ].x;
			ay = contour[ verts[ u ] ].y;
			bx = contour[ verts[ v ] ].x;
			by = contour[ verts[ v ] ].y;
			cx = contour[ verts[ w ] ].x;
			cy = contour[ verts[ w ] ].y;
			if ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;
			var aX, aY, bX, bY, cX, cY;
			var apx, apy, bpx, bpy, cpx, cpy;
			var cCROSSap, bCROSScp, aCROSSbp;
			aX = cx - bx; aY = cy - by;
			bX = ax - cx; bY = ay - cy;
			cX = bx - ax; cY = by - ay;
			for ( p = 0; p < n; p ++ ) {
				px = contour[ verts[ p ] ].x;
				py = contour[ verts[ p ] ].y;
				if ( ( ( px === ax ) && ( py === ay ) ) ||
					 ( ( px === bx ) && ( py === by ) ) ||
					 ( ( px === cx ) && ( py === cy ) ) )	continue;
				apx = px - ax; apy = py - ay;
				bpx = px - bx; bpy = py - by;
				cpx = px - cx; cpy = py - cy;
				aCROSSbp = aX * bpy - aY * bpx;
				cCROSSap = cX * apy - cY * apx;
				bCROSScp = bX * cpy - bY * cpx;
				if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;
			}
			return true;
		}
		return function triangulate( contour, indices ) {
			var n = contour.length;
			if ( n < 3 ) return null;
			var result = [],
				verts = [],
				vertIndices = [];
			var u, v, w;
			if ( ShapeUtils.area( contour ) > 0.0 ) {
				for ( v = 0; v < n; v ++ ) verts[ v ] = v;
			} else {
				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;
			}
			var nv = n;
			var count = 2 * nv;
			for ( v = nv - 1; nv > 2; ) {
				if ( ( count -- ) <= 0 ) {
					console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );
					if ( indices ) return vertIndices;
					return result;
				}
				u = v; if ( nv <= u ) u = 0;
				v = u + 1; if ( nv <= v ) v = 0;
				w = v + 1; if ( nv <= w ) w = 0;
				if ( snip( contour, u, v, w, nv, verts ) ) {
					var a, b, c, s, t;
					a = verts[ u ];
					b = verts[ v ];
					c = verts[ w ];
					result.push( [ contour[ a ],
						contour[ b ],
						contour[ c ] ] );
					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );
					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {
						verts[ s ] = verts[ t ];
					}
					nv --;
					count = 2 * nv;
				}
			}
			if ( indices ) return vertIndices;
			return result;
		};
	} )(),
	triangulateShape: function ( contour, holes ) {
		function removeDupEndPts( points ) {
			var l = points.length;
			if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {
				points.pop();
			}
		}
		removeDupEndPts( contour );
		holes.forEach( removeDupEndPts );
		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
			if ( inSegPt1.x !== inSegPt2.x ) {
				if ( inSegPt1.x < inSegPt2.x ) {
					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
				} else {
					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
				}
			} else {
				if ( inSegPt1.y < inSegPt2.y ) {
					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
				} else {
					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
				}
			}
		}
		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x, seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x, seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
			if ( Math.abs( limit ) > Number.EPSILON ) {
				var perpSeg2;
				if ( limit > 0 ) {
					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];
				} else {
					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];
				}
				if ( perpSeg2 === 0 ) {
					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
					return [ inSeg1Pt1 ];
				}
				if ( perpSeg2 === limit ) {
					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
					return [ inSeg1Pt2 ];
				}
				if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
				if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];
				var factorSeg1 = perpSeg2 / limit;
				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx, y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];
			} else {
				if ( ( perpSeg1 !== 0 ) ||
					 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];
				var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );
				var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );
				if ( seg1Pt && seg2Pt ) {
					if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
						 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];
					return [ inSeg1Pt1 ];
				}
				if ( seg1Pt ) {
					if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];
					return [ inSeg1Pt1 ];
				}
				if ( seg2Pt ) {
					if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];
					return [ inSeg2Pt1 ];
				}
				var seg1min, seg1max, seg1minVal, seg1maxVal;
				var seg2min, seg2max, seg2minVal, seg2maxVal;
				if ( seg1dx !== 0 ) {
					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
					} else {
						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
					}
					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
					} else {
						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
					}
				} else {
					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
					} else {
						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
					}
					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
					} else {
						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
					}
				}
				if ( seg1minVal <= seg2minVal ) {
					if ( seg1maxVal < seg2minVal )	return [];
					if ( seg1maxVal === seg2minVal )	{
						if ( inExcludeAdjacentSegs )		return [];
						return [ seg2min ];
					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
					return	[ seg2min, seg2max ];
				} else {
					if ( seg1minVal > seg2maxVal )	return [];
					if ( seg1minVal === seg2maxVal )	{
						if ( inExcludeAdjacentSegs )		return [];
						return [ seg1min ];
					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
					return	[ seg1min, seg2max ];
				}
			}
		}
		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
			var legFromPtX	= inLegFromPt.x - inVertex.x, legFromPtY = inLegFromPt.y - inVertex.y;
			var legToPtX	= inLegToPt.x	- inVertex.x, legToPtY = inLegToPt.y	- inVertex.y;
			var otherPtX	= inOtherPt.x	- inVertex.x, otherPtY = inOtherPt.y	- inVertex.y;
			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;
			if ( Math.abs( from2toAngle ) > Number.EPSILON ) {
				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
				if ( from2toAngle > 0 ) {
					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
				} else {
					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
				}
			} else {
				return	( from2otherAngle > 0 );
			}
		}
		function removeHoles( contour, holes ) {
			var shape = contour.concat();
			var hole;
			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
				var lastShapeIdx = shape.length - 1;
				var prevShapeIdx = inShapeIdx - 1;
				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;
				var nextShapeIdx = inShapeIdx + 1;
				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;
				var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
				if ( ! insideAngle ) {
					return	false;
				}
				var lastHoleIdx = hole.length - 1;
				var prevHoleIdx = inHoleIdx - 1;
				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;
				var nextHoleIdx = inHoleIdx + 1;
				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;
				insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
				if ( ! insideAngle ) {
					return	false;
				}
				return	true;
			}
			function intersectsShapeEdge( inShapePt, inHolePt ) {
				var sIdx, nextIdx, intersection;
				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {
					nextIdx = sIdx + 1; nextIdx %= shape.length;
					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
					if ( intersection.length > 0 )		return	true;
				}
				return	false;
			}
			var indepHoles = [];
			function intersectsHoleEdge( inShapePt, inHolePt ) {
				var ihIdx, chkHole,
					hIdx, nextIdx, intersection;
				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {
					chkHole = holes[ indepHoles[ ihIdx ] ];
					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {
						nextIdx = hIdx + 1; nextIdx %= chkHole.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
						if ( intersection.length > 0 )		return	true;
					}
				}
				return	false;
			}
			var holeIndex, shapeIndex,
				shapePt, holePt,
				holeIdx, cutKey, failedCuts = [],
				tmpShape1, tmpShape2,
				tmpHole1, tmpHole2;
			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {
				indepHoles.push( h );
			}
			var minShapeIndex = 0;
			var counter = indepHoles.length * 2;
			while ( indepHoles.length > 0 ) {
				counter --;
				if ( counter < 0 ) {
					console.log( 'THREE.ShapeUtils: Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!' );
					break;
				}
				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {
					shapePt = shape[ shapeIndex ];
					holeIndex	= - 1;
					for ( var h = 0; h < indepHoles.length; h ++ ) {
						holeIdx = indepHoles[ h ];
						cutKey = shapePt.x + ':' + shapePt.y + ':' + holeIdx;
						if ( failedCuts[ cutKey ] !== undefined )			continue;
						hole = holes[ holeIdx ];
						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
							holePt = hole[ h2 ];
							if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;
							holeIndex = h2;
							indepHoles.splice( h, 1 );
							tmpShape1 = shape.slice( 0, shapeIndex + 1 );
							tmpShape2 = shape.slice( shapeIndex );
							tmpHole1 = hole.slice( holeIndex );
							tmpHole2 = hole.slice( 0, holeIndex + 1 );
							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );
							minShapeIndex = shapeIndex;
							break;
						}
						if ( holeIndex >= 0 )	break;
						failedCuts[ cutKey ] = true;
					}
					if ( holeIndex >= 0 )	break;
				}
			}
			return shape;
		}
		var i, il, f, face,
			key, index,
			allPointsMap = {};
		var allpoints = contour.concat();
		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {
			Array.prototype.push.apply( allpoints, holes[ h ] );
		}
		for ( i = 0, il = allpoints.length; i < il; i ++ ) {
			key = allpoints[ i ].x + ':' + allpoints[ i ].y;
			if ( allPointsMap[ key ] !== undefined ) {
				console.warn( 'THREE.ShapeUtils: Duplicate point', key, i );
			}
			allPointsMap[ key ] = i;
		}
		var shapeWithoutHoles = removeHoles( contour, holes );
		var triangles = ShapeUtils.triangulate( shapeWithoutHoles, false );
		for ( i = 0, il = triangles.length; i < il; i ++ ) {
			face = triangles[ i ];
			for ( f = 0; f < 3; f ++ ) {
				key = face[ f ].x + ':' + face[ f ].y;
				index = allPointsMap[ key ];
				if ( index !== undefined ) {
					face[ f ] = index;
				}
			}
		}
		return triangles.concat();
	},
	isClockWise: function ( pts ) {
		return ShapeUtils.area( pts ) < 0;
	}
};
function ExtrudeGeometry( shapes, options ) {
	Geometry.call( this );
	this.type = 'ExtrudeGeometry';
	this.parameters = {
		shapes: shapes,
		options: options
	};
	this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );
	this.mergeVertices();
}
ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
function ExtrudeBufferGeometry( shapes, options ) {
	if ( typeof ( shapes ) === "undefined" ) {
		return;
	}
	BufferGeometry.call( this );
	this.type = 'ExtrudeBufferGeometry';
	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];
	this.addShapeList( shapes, options );
	this.computeVertexNormals();
}
ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;
ExtrudeBufferGeometry.prototype.getArrays = function () {
	var positionAttribute = this.getAttribute( "position" );
	var verticesArray = positionAttribute ? Array.prototype.slice.call( positionAttribute.array ) : [];
	var uvAttribute = this.getAttribute( "uv" );
	var uvArray = uvAttribute ? Array.prototype.slice.call( uvAttribute.array ) : [];
	var IndexAttribute = this.index;
	var indicesArray = IndexAttribute ? Array.prototype.slice.call( IndexAttribute.array ) : [];
	return {
		position: verticesArray,
		uv: uvArray,
		index: indicesArray
	};
};
ExtrudeBufferGeometry.prototype.addShapeList = function ( shapes, options ) {
	var sl = shapes.length;
	options.arrays = this.getArrays();
	for ( var s = 0; s < sl; s ++ ) {
		var shape = shapes[ s ];
		this.addShape( shape, options );
	}
	this.setIndex( options.arrays.index );
	this.addAttribute( 'position', new Float32BufferAttribute( options.arrays.position, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( options.arrays.uv, 2 ) );
};
ExtrudeBufferGeometry.prototype.addShape = function ( shape, options ) {
	var arrays = options.arrays ? options.arrays : this.getArrays();
	var verticesArray = arrays.position;
	var indicesArray = arrays.index;
	var uvArray = arrays.uv;
	var placeholder = [];
	var amount = options.amount !== undefined ? options.amount : 100;
	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	var steps = options.steps !== undefined ? options.steps : 1;
	var extrudePath = options.extrudePath;
	var extrudePts, extrudeByPath = false;
	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;
	var splineTube, binormal, normal, position2;
	if ( extrudePath ) {
		extrudePts = extrudePath.getSpacedPoints( steps );
		extrudeByPath = true;
		bevelEnabled = false;
		splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );
		binormal = new Vector3();
		normal = new Vector3();
		position2 = new Vector3();
	}
	if ( ! bevelEnabled ) {
		bevelSegments = 0;
		bevelThickness = 0;
		bevelSize = 0;
	}
	var ahole, h, hl;
	var scope = this;
	var shapePoints = shape.extractPoints( curveSegments );
	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;
	var reverse = ! ShapeUtils.isClockWise( vertices );
	if ( reverse ) {
		vertices = vertices.reverse();
		for ( h = 0, hl = holes.length; h < hl; h ++ ) {
			ahole = holes[ h ];
			if ( ShapeUtils.isClockWise( ahole ) ) {
				holes[ h ] = ahole.reverse();
			}
		}
	}
	var faces = ShapeUtils.triangulateShape( vertices, holes );
	var contour = vertices;
	for ( h = 0, hl = holes.length; h < hl; h ++ ) {
		ahole = holes[ h ];
		vertices = vertices.concat( ahole );
	}
	function scalePt2( pt, vec, size ) {
		if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );
		return vec.clone().multiplyScalar( size ).add( pt );
	}
	var b, bs, t, z,
		vert, vlen = vertices.length,
		face, flen = faces.length;
	function getBevelVec( inPt, inPrev, inNext ) {
		var v_trans_x, v_trans_y, shrink_by;
		var v_prev_x = inPt.x - inPrev.x,
			v_prev_y = inPt.y - inPrev.y;
		var v_next_x = inNext.x - inPt.x,
			v_next_y = inNext.y - inPt.y;
		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
		var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
		if ( Math.abs( collinear0 ) > Number.EPSILON ) {
			var v_prev_len = Math.sqrt( v_prev_lensq );
			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
			var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
					( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
				( v_prev_x * v_next_y - v_prev_y * v_next_x );
			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
			if ( v_trans_lensq <= 2 ) {
				return new Vector2( v_trans_x, v_trans_y );
			} else {
				shrink_by = Math.sqrt( v_trans_lensq / 2 );
			}
		} else {
			var direction_eq = false;
			if ( v_prev_x > Number.EPSILON ) {
				if ( v_next_x > Number.EPSILON ) {
					direction_eq = true;
				}
			} else {
				if ( v_prev_x < - Number.EPSILON ) {
					if ( v_next_x < - Number.EPSILON ) {
						direction_eq = true;
					}
				} else {
					if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {
						direction_eq = true;
					}
				}
			}
			if ( direction_eq ) {
				v_trans_x = - v_prev_y;
				v_trans_y = v_prev_x;
				shrink_by = Math.sqrt( v_prev_lensq );
			} else {
				v_trans_x = v_prev_x;
				v_trans_y = v_prev_y;
				shrink_by = Math.sqrt( v_prev_lensq / 2 );
			}
		}
		return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );
	}
	var contourMovements = [];
	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
		if ( j === il ) j = 0;
		if ( k === il ) k = 0;
		contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );
	}
	var holesMovements = [],
		oneHoleMovements, verticesMovements = contourMovements.concat();
	for ( h = 0, hl = holes.length; h < hl; h ++ ) {
		ahole = holes[ h ];
		oneHoleMovements = [];
		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
			if ( j === il ) j = 0;
			if ( k === il ) k = 0;
			oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );
		}
		holesMovements.push( oneHoleMovements );
		verticesMovements = verticesMovements.concat( oneHoleMovements );
	}
	for ( b = 0; b < bevelSegments; b ++ ) {
		t = b / bevelSegments;
		z = bevelThickness * Math.cos( t * Math.PI / 2 );
		bs = bevelSize * Math.sin( t * Math.PI / 2 );
		for ( i = 0, il = contour.length; i < il; i ++ ) {
			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			v( vert.x, vert.y, - z );
		}
		for ( h = 0, hl = holes.length; h < hl; h ++ ) {
			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];
			for ( i = 0, il = ahole.length; i < il; i ++ ) {
				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
				v( vert.x, vert.y, - z );
			}
		}
	}
	bs = bevelSize;
	for ( i = 0; i < vlen; i ++ ) {
		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
		if ( ! extrudeByPath ) {
			v( vert.x, vert.y, 0 );
		} else {
			normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
			binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );
			position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );
			v( position2.x, position2.y, position2.z );
		}
	}
	var s;
	for ( s = 1; s <= steps; s ++ ) {
		for ( i = 0; i < vlen; i ++ ) {
			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
			if ( ! extrudeByPath ) {
				v( vert.x, vert.y, amount / steps * s );
			} else {
				normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );
				position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );
				v( position2.x, position2.y, position2.z );
			}
		}
	}
	for ( b = bevelSegments - 1; b >= 0; b -- ) {
		t = b / bevelSegments;
		z = bevelThickness * Math.cos( t * Math.PI / 2 );
		bs = bevelSize * Math.sin( t * Math.PI / 2 );
		for ( i = 0, il = contour.length; i < il; i ++ ) {
			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			v( vert.x, vert.y, amount + z );
		}
		for ( h = 0, hl = holes.length; h < hl; h ++ ) {
			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];
			for ( i = 0, il = ahole.length; i < il; i ++ ) {
				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
				if ( ! extrudeByPath ) {
					v( vert.x, vert.y, amount + z );
				} else {
					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );
				}
			}
		}
	}
	buildLidFaces();
	buildSideFaces();
	function buildLidFaces() {
		var start = verticesArray.length / 3;
		if ( bevelEnabled ) {
			var layer = 0;
			var offset = vlen * layer;
			for ( i = 0; i < flen; i ++ ) {
				face = faces[ i ];
				f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );
			}
			layer = steps + bevelSegments * 2;
			offset = vlen * layer;
			for ( i = 0; i < flen; i ++ ) {
				face = faces[ i ];
				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );
			}
		} else {
			for ( i = 0; i < flen; i ++ ) {
				face = faces[ i ];
				f3( face[ 2 ], face[ 1 ], face[ 0 ] );
			}
			for ( i = 0; i < flen; i ++ ) {
				face = faces[ i ];
				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );
			}
		}
		scope.addGroup( start, verticesArray.length / 3 - start, options.material !== undefined ? options.material : 0 );
	}
	function buildSideFaces() {
		var start = verticesArray.length / 3;
		var layeroffset = 0;
		sidewalls( contour, layeroffset );
		layeroffset += contour.length;
		for ( h = 0, hl = holes.length; h < hl; h ++ ) {
			ahole = holes[ h ];
			sidewalls( ahole, layeroffset );
			layeroffset += ahole.length;
		}
		scope.addGroup( start, verticesArray.length / 3 - start, options.extrudeMaterial !== undefined ? options.extrudeMaterial : 1 );
	}
	function sidewalls( contour, layeroffset ) {
		var j, k;
		i = contour.length;
		while ( -- i >= 0 ) {
			j = i;
			k = i - 1;
			if ( k < 0 ) k = contour.length - 1;
			var s = 0,
				sl = steps + bevelSegments * 2;
			for ( s = 0; s < sl; s ++ ) {
				var slen1 = vlen * s;
				var slen2 = vlen * ( s + 1 );
				var a = layeroffset + j + slen1,
					b = layeroffset + k + slen1,
					c = layeroffset + k + slen2,
					d = layeroffset + j + slen2;
				f4( a, b, c, d );
			}
		}
	}
	function v( x, y, z ) {
		placeholder.push( x );
		placeholder.push( y );
		placeholder.push( z );
	}
	function f3( a, b, c ) {
		addVertex( a );
		addVertex( b );
		addVertex( c );
		var nextIndex = verticesArray.length / 3;
		var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );
		addUV( uvs[ 0 ] );
		addUV( uvs[ 1 ] );
		addUV( uvs[ 2 ] );
	}
	function f4( a, b, c, d ) {
		addVertex( a );
		addVertex( b );
		addVertex( d );
		addVertex( b );
		addVertex( c );
		addVertex( d );
		var nextIndex = verticesArray.length / 3;
		var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );
		addUV( uvs[ 0 ] );
		addUV( uvs[ 1 ] );
		addUV( uvs[ 3 ] );
		addUV( uvs[ 1 ] );
		addUV( uvs[ 2 ] );
		addUV( uvs[ 3 ] );
	}
	function addVertex( index ) {
		indicesArray.push( verticesArray.length / 3 );
		verticesArray.push( placeholder[ index * 3 + 0 ] );
		verticesArray.push( placeholder[ index * 3 + 1 ] );
		verticesArray.push( placeholder[ index * 3 + 2 ] );
	}
	function addUV( vector2 ) {
		uvArray.push( vector2.x );
		uvArray.push( vector2.y );
	}
	if ( ! options.arrays ) {
		this.setIndex( indicesArray );
		this.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( options.arrays.uv, 2 ) );
	}
};
ExtrudeGeometry.WorldUVGenerator = {
	generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {
		var a_x = vertices[ indexA * 3 ];
		var a_y = vertices[ indexA * 3 + 1 ];
		var b_x = vertices[ indexB * 3 ];
		var b_y = vertices[ indexB * 3 + 1 ];
		var c_x = vertices[ indexC * 3 ];
		var c_y = vertices[ indexC * 3 + 1 ];
		return [
			new Vector2( a_x, a_y ),
			new Vector2( b_x, b_y ),
			new Vector2( c_x, c_y )
		];
	},
	generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {
		var a_x = vertices[ indexA * 3 ];
		var a_y = vertices[ indexA * 3 + 1 ];
		var a_z = vertices[ indexA * 3 + 2 ];
		var b_x = vertices[ indexB * 3 ];
		var b_y = vertices[ indexB * 3 + 1 ];
		var b_z = vertices[ indexB * 3 + 2 ];
		var c_x = vertices[ indexC * 3 ];
		var c_y = vertices[ indexC * 3 + 1 ];
		var c_z = vertices[ indexC * 3 + 2 ];
		var d_x = vertices[ indexD * 3 ];
		var d_y = vertices[ indexD * 3 + 1 ];
		var d_z = vertices[ indexD * 3 + 2 ];
		if ( Math.abs( a_y - b_y ) < 0.01 ) {
			return [
				new Vector2( a_x, 1 - a_z ),
				new Vector2( b_x, 1 - b_z ),
				new Vector2( c_x, 1 - c_z ),
				new Vector2( d_x, 1 - d_z )
			];
		} else {
			return [
				new Vector2( a_y, 1 - a_z ),
				new Vector2( b_y, 1 - b_z ),
				new Vector2( c_y, 1 - c_z ),
				new Vector2( d_y, 1 - d_z )
			];
		}
	}
};
function TextGeometry( text, parameters ) {
	Geometry.call( this );
	this.type = 'TextGeometry';
	this.parameters = {
		text: text,
		parameters: parameters
	};
	this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );
	this.mergeVertices();
}
TextGeometry.prototype = Object.create( Geometry.prototype );
TextGeometry.prototype.constructor = TextGeometry;
function TextBufferGeometry( text, parameters ) {
	parameters = parameters || {};
	var font = parameters.font;
	if ( ! ( font && font.isFont ) ) {
		console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
		return new Geometry();
	}
	var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );
	parameters.amount = parameters.height !== undefined ? parameters.height : 50;
	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;
	ExtrudeBufferGeometry.call( this, shapes, parameters );
	this.type = 'TextBufferGeometry';
}
TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );
TextBufferGeometry.prototype.constructor = TextBufferGeometry;
function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	Geometry.call( this );
	this.type = 'SphereGeometry';
	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};
	this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
	this.mergeVertices();
}
SphereGeometry.prototype = Object.create( Geometry.prototype );
SphereGeometry.prototype.constructor = SphereGeometry;
function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	BufferGeometry.call( this );
	this.type = 'SphereBufferGeometry';
	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};
	radius = radius || 1;
	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );
	phiStart = phiStart !== undefined ? phiStart : 0;
	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
	var thetaEnd = thetaStart + thetaLength;
	var ix, iy;
	var index = 0;
	var grid = [];
	var vertex = new Vector3();
	var normal = new Vector3();
	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];
	for ( iy = 0; iy <= heightSegments; iy ++ ) {
		var verticesRow = [];
		var v = iy / heightSegments;
		for ( ix = 0; ix <= widthSegments; ix ++ ) {
			var u = ix / widthSegments;
			vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
			vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			vertices.push( vertex.x, vertex.y, vertex.z );
			normal.set( vertex.x, vertex.y, vertex.z ).normalize();
			normals.push( normal.x, normal.y, normal.z );
			uvs.push( u, 1 - v );
			verticesRow.push( index ++ );
		}
		grid.push( verticesRow );
	}
	for ( iy = 0; iy < heightSegments; iy ++ ) {
		for ( ix = 0; ix < widthSegments; ix ++ ) {
			var a = grid[ iy ][ ix + 1 ];
			var b = grid[ iy ][ ix ];
			var c = grid[ iy + 1 ][ ix ];
			var d = grid[ iy + 1 ][ ix + 1 ];
			if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
			if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );
		}
	}
	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
}
SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
	Geometry.call( this );
	this.type = 'RingGeometry';
	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};
	this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
	this.mergeVertices();
}
RingGeometry.prototype = Object.create( Geometry.prototype );
RingGeometry.prototype.constructor = RingGeometry;
function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
	BufferGeometry.call( this );
	this.type = 'RingBufferGeometry';
	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};
	innerRadius = innerRadius || 0.5;
	outerRadius = outerRadius || 1;
	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;
	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];
	var segment;
	var radius = innerRadius;
	var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
	var vertex = new Vector3();
	var uv = new Vector2();
	var j, i;
	for ( j = 0; j <= phiSegments; j ++ ) {
		for ( i = 0; i <= thetaSegments; i ++ ) {
			segment = thetaStart + i / thetaSegments * thetaLength;
			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );
			vertices.push( vertex.x, vertex.y, vertex.z );
			normals.push( 0, 0, 1 );
			uv.x = ( vertex.x / outerRadius + 1 ) / 2;
			uv.y = ( vertex.y / outerRadius + 1 ) / 2;
			uvs.push( uv.x, uv.y );
		}
		radius += radiusStep;
	}
	for ( j = 0; j < phiSegments; j ++ ) {
		var thetaSegmentLevel = j * ( thetaSegments + 1 );
		for ( i = 0; i < thetaSegments; i ++ ) {
			segment = i + thetaSegmentLevel;
			var a = segment;
			var b = segment + thetaSegments + 1;
			var c = segment + thetaSegments + 2;
			var d = segment + 1;
			indices.push( a, b, d );
			indices.push( b, c, d );
		}
	}
	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
}
RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
RingBufferGeometry.prototype.constructor = RingBufferGeometry;
function LatheGeometry( points, segments, phiStart, phiLength ) {
	Geometry.call( this );
	this.type = 'LatheGeometry';
	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};
	this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
	this.mergeVertices();
}
LatheGeometry.prototype = Object.create( Geometry.prototype );
LatheGeometry.prototype.constructor = LatheGeometry;
function LatheBufferGeometry( points, segments, phiStart, phiLength ) {
	BufferGeometry.call( this );
	this.type = 'LatheBufferGeometry';
	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};
	segments = Math.floor( segments ) || 12;
	phiStart = phiStart || 0;
	phiLength = phiLength || Math.PI * 2;
	phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );
	var indices = [];
	var vertices = [];
	var uvs = [];
	var base;
	var inverseSegments = 1.0 / segments;
	var vertex = new Vector3();
	var uv = new Vector2();
	var i, j;
	for ( i = 0; i <= segments; i ++ ) {
		var phi = phiStart + i * inverseSegments * phiLength;
		var sin = Math.sin( phi );
		var cos = Math.cos( phi );
		for ( j = 0; j <= ( points.length - 1 ); j ++ ) {
			vertex.x = points[ j ].x * sin;
			vertex.y = points[ j ].y;
			vertex.z = points[ j ].x * cos;
			vertices.push( vertex.x, vertex.y, vertex.z );
			uv.x = i / segments;
			uv.y = j / ( points.length - 1 );
			uvs.push( uv.x, uv.y );
		}
	}
	for ( i = 0; i < segments; i ++ ) {
		for ( j = 0; j < ( points.length - 1 ); j ++ ) {
			base = j + i * points.length;
			var a = base;
			var b = base + points.length;
			var c = base + points.length + 1;
			var d = base + 1;
			indices.push( a, b, d );
			indices.push( b, c, d );
		}
	}
	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	this.computeVertexNormals();
	if ( phiLength === Math.PI * 2 ) {
		var normals = this.attributes.normal.array;
		var n1 = new Vector3();
		var n2 = new Vector3();
		var n = new Vector3();
		base = segments * points.length * 3;
		for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {
			n1.x = normals[ j + 0 ];
			n1.y = normals[ j + 1 ];
			n1.z = normals[ j + 2 ];
			n2.x = normals[ base + j + 0 ];
			n2.y = normals[ base + j + 1 ];
			n2.z = normals[ base + j + 2 ];
			n.addVectors( n1, n2 ).normalize();
			normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
			normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
			normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;
		}
	}
}
LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
function ShapeGeometry( shapes, curveSegments ) {
	Geometry.call( this );
	this.type = 'ShapeGeometry';
	if ( typeof curveSegments === 'object' ) {
		console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );
		curveSegments = curveSegments.curveSegments;
	}
	this.parameters = {
		shapes: shapes,
		curveSegments: curveSegments
	};
	this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
	this.mergeVertices();
}
ShapeGeometry.prototype = Object.create( Geometry.prototype );
ShapeGeometry.prototype.constructor = ShapeGeometry;
function ShapeBufferGeometry( shapes, curveSegments ) {
	BufferGeometry.call( this );
	this.type = 'ShapeBufferGeometry';
	this.parameters = {
		shapes: shapes,
		curveSegments: curveSegments
	};
	curveSegments = curveSegments || 12;
	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];
	var groupStart = 0;
	var groupCount = 0;
	if ( Array.isArray( shapes ) === false ) {
		addShape( shapes );
	} else {
		for ( var i = 0; i < shapes.length; i ++ ) {
			addShape( shapes[ i ] );
			this.addGroup( groupStart, groupCount, i );
			groupStart += groupCount;
			groupCount = 0;
		}
	}
	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	function addShape( shape ) {
		var i, l, shapeHole;
		var indexOffset = vertices.length / 3;
		var points = shape.extractPoints( curveSegments );
		var shapeVertices = points.shape;
		var shapeHoles = points.holes;
		if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {
			shapeVertices = shapeVertices.reverse();
			for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {
				shapeHole = shapeHoles[ i ];
				if ( ShapeUtils.isClockWise( shapeHole ) === true ) {
					shapeHoles[ i ] = shapeHole.reverse();
				}
			}
		}
		var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );
		for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {
			shapeHole = shapeHoles[ i ];
			shapeVertices = shapeVertices.concat( shapeHole );
		}
		for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {
			var vertex = shapeVertices[ i ];
			vertices.push( vertex.x, vertex.y, 0 );
			normals.push( 0, 0, 1 );
			uvs.push( vertex.x, vertex.y );
		}
		for ( i = 0, l = faces.length; i < l; i ++ ) {
			var face = faces[ i ];
			var a = face[ 0 ] + indexOffset;
			var b = face[ 1 ] + indexOffset;
			var c = face[ 2 ] + indexOffset;
			indices.push( a, b, c );
			groupCount += 3;
		}
	}
}
ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
function EdgesGeometry( geometry, thresholdAngle ) {
	BufferGeometry.call( this );
	this.type = 'EdgesGeometry';
	this.parameters = {
		thresholdAngle: thresholdAngle
	};
	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;
	var vertices = [];
	var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );
	var edge = [ 0, 0 ], edges = {}, edge1, edge2;
	var key, keys = [ 'a', 'b', 'c' ];
	var geometry2;
	if ( geometry.isBufferGeometry ) {
		geometry2 = new Geometry();
		geometry2.fromBufferGeometry( geometry );
	} else {
		geometry2 = geometry.clone();
	}
	geometry2.mergeVertices();
	geometry2.computeFaceNormals();
	var sourceVertices = geometry2.vertices;
	var faces = geometry2.faces;
	for ( var i = 0, l = faces.length; i < l; i ++ ) {
		var face = faces[ i ];
		for ( var j = 0; j < 3; j ++ ) {
			edge1 = face[ keys[ j ] ];
			edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
			edge[ 0 ] = Math.min( edge1, edge2 );
			edge[ 1 ] = Math.max( edge1, edge2 );
			key = edge[ 0 ] + ',' + edge[ 1 ];
			if ( edges[ key ] === undefined ) {
				edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };
			} else {
				edges[ key ].face2 = i;
			}
		}
	}
	for ( key in edges ) {
		var e = edges[ key ];
		if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {
			var vertex = sourceVertices[ e.index1 ];
			vertices.push( vertex.x, vertex.y, vertex.z );
			vertex = sourceVertices[ e.index2 ];
			vertices.push( vertex.x, vertex.y, vertex.z );
		}
	}
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
}
EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
EdgesGeometry.prototype.constructor = EdgesGeometry;
function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	Geometry.call( this );
	this.type = 'CylinderGeometry';
	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};
	this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
	this.mergeVertices();
}
CylinderGeometry.prototype = Object.create( Geometry.prototype );
CylinderGeometry.prototype.constructor = CylinderGeometry;
function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	BufferGeometry.call( this );
	this.type = 'CylinderBufferGeometry';
	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};
	var scope = this;
	radiusTop = radiusTop !== undefined ? radiusTop : 1;
	radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
	height = height || 1;
	radialSegments = Math.floor( radialSegments ) || 8;
	heightSegments = Math.floor( heightSegments ) || 1;
	openEnded = openEnded !== undefined ? openEnded : false;
	thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];
	var index = 0;
	var indexArray = [];
	var halfHeight = height / 2;
	var groupStart = 0;
	generateTorso();
	if ( openEnded === false ) {
		if ( radiusTop > 0 ) generateCap( true );
		if ( radiusBottom > 0 ) generateCap( false );
	}
	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	function generateTorso() {
		var x, y;
		var normal = new Vector3();
		var vertex = new Vector3();
		var groupCount = 0;
		var slope = ( radiusBottom - radiusTop ) / height;
		for ( y = 0; y <= heightSegments; y ++ ) {
			var indexRow = [];
			var v = y / heightSegments;
			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;
			for ( x = 0; x <= radialSegments; x ++ ) {
				var u = x / radialSegments;
				var theta = u * thetaLength + thetaStart;
				var sinTheta = Math.sin( theta );
				var cosTheta = Math.cos( theta );
				vertex.x = radius * sinTheta;
				vertex.y = - v * height + halfHeight;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );
				normal.set( sinTheta, slope, cosTheta ).normalize();
				normals.push( normal.x, normal.y, normal.z );
				uvs.push( u, 1 - v );
				indexRow.push( index ++ );
			}
			indexArray.push( indexRow );
		}
		for ( x = 0; x < radialSegments; x ++ ) {
			for ( y = 0; y < heightSegments; y ++ ) {
				var a = indexArray[ y ][ x ];
				var b = indexArray[ y + 1 ][ x ];
				var c = indexArray[ y + 1 ][ x + 1 ];
				var d = indexArray[ y ][ x + 1 ];
				indices.push( a, b, d );
				indices.push( b, c, d );
				groupCount += 6;
			}
		}
		scope.addGroup( groupStart, groupCount, 0 );
		groupStart += groupCount;
	}
	function generateCap( top ) {
		var x, centerIndexStart, centerIndexEnd;
		var uv = new Vector2();
		var vertex = new Vector3();
		var groupCount = 0;
		var radius = ( top === true ) ? radiusTop : radiusBottom;
		var sign = ( top === true ) ? 1 : - 1;
		centerIndexStart = index;
		for ( x = 1; x <= radialSegments; x ++ ) {
			vertices.push( 0, halfHeight * sign, 0 );
			normals.push( 0, sign, 0 );
			uvs.push( 0.5, 0.5 );
			index ++;
		}
		centerIndexEnd = index;
		for ( x = 0; x <= radialSegments; x ++ ) {
			var u = x / radialSegments;
			var theta = u * thetaLength + thetaStart;
			var cosTheta = Math.cos( theta );
			var sinTheta = Math.sin( theta );
			vertex.x = radius * sinTheta;
			vertex.y = halfHeight * sign;
			vertex.z = radius * cosTheta;
			vertices.push( vertex.x, vertex.y, vertex.z );
			normals.push( 0, sign, 0 );
			uv.x = ( cosTheta * 0.5 ) + 0.5;
			uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
			uvs.push( uv.x, uv.y );
			index ++;
		}
		for ( x = 0; x < radialSegments; x ++ ) {
			var c = centerIndexStart + x;
			var i = centerIndexEnd + x;
			if ( top === true ) {
				indices.push( i, i + 1, c );
			} else {
				indices.push( i + 1, i, c );
			}
			groupCount += 3;
		}
		scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );
		groupStart += groupCount;
	}
}
CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );
	this.type = 'ConeGeometry';
	this.parameters = {
		radius: radius,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};
}
ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
ConeGeometry.prototype.constructor = ConeGeometry;
function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );
	this.type = 'ConeBufferGeometry';
	this.parameters = {
		radius: radius,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};
}
ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
function CircleGeometry( radius, segments, thetaStart, thetaLength ) {
	Geometry.call( this );
	this.type = 'CircleGeometry';
	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};
	this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
	this.mergeVertices();
}
CircleGeometry.prototype = Object.create( Geometry.prototype );
CircleGeometry.prototype.constructor = CircleGeometry;
function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {
	BufferGeometry.call( this );
	this.type = 'CircleBufferGeometry';
	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};
	radius = radius || 1;
	segments = segments !== undefined ? Math.max( 3, segments ) : 8;
	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];
	var i, s;
	var vertex = new Vector3();
	var uv = new Vector2();
	vertices.push( 0, 0, 0 );
	normals.push( 0, 0, 1 );
	uvs.push( 0.5, 0.5 );
	for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {
		var segment = thetaStart + s / segments * thetaLength;
		vertex.x = radius * Math.cos( segment );
		vertex.y = radius * Math.sin( segment );
		vertices.push( vertex.x, vertex.y, vertex.z );
		normals.push( 0, 0, 1 );
		uv.x = ( vertices[ i ] / radius + 1 ) / 2;
		uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;
		uvs.push( uv.x, uv.y );
	}
	for ( i = 1; i <= segments; i ++ ) {
		indices.push( i, i + 1, 0 );
	}
	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
}
CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
var Geometries = Object.freeze({
	WireframeGeometry: WireframeGeometry,
	ParametricGeometry: ParametricGeometry,
	ParametricBufferGeometry: ParametricBufferGeometry,
	TetrahedronGeometry: TetrahedronGeometry,
	TetrahedronBufferGeometry: TetrahedronBufferGeometry,
	OctahedronGeometry: OctahedronGeometry,
	OctahedronBufferGeometry: OctahedronBufferGeometry,
	IcosahedronGeometry: IcosahedronGeometry,
	IcosahedronBufferGeometry: IcosahedronBufferGeometry,
	DodecahedronGeometry: DodecahedronGeometry,
	DodecahedronBufferGeometry: DodecahedronBufferGeometry,
	PolyhedronGeometry: PolyhedronGeometry,
	PolyhedronBufferGeometry: PolyhedronBufferGeometry,
	TubeGeometry: TubeGeometry,
	TubeBufferGeometry: TubeBufferGeometry,
	TorusKnotGeometry: TorusKnotGeometry,
	TorusKnotBufferGeometry: TorusKnotBufferGeometry,
	TorusGeometry: TorusGeometry,
	TorusBufferGeometry: TorusBufferGeometry,
	TextGeometry: TextGeometry,
	TextBufferGeometry: TextBufferGeometry,
	SphereGeometry: SphereGeometry,
	SphereBufferGeometry: SphereBufferGeometry,
	RingGeometry: RingGeometry,
	RingBufferGeometry: RingBufferGeometry,
	PlaneGeometry: PlaneGeometry,
	PlaneBufferGeometry: PlaneBufferGeometry,
	LatheGeometry: LatheGeometry,
	LatheBufferGeometry: LatheBufferGeometry,
	ShapeGeometry: ShapeGeometry,
	ShapeBufferGeometry: ShapeBufferGeometry,
	ExtrudeGeometry: ExtrudeGeometry,
	ExtrudeBufferGeometry: ExtrudeBufferGeometry,
	EdgesGeometry: EdgesGeometry,
	ConeGeometry: ConeGeometry,
	ConeBufferGeometry: ConeBufferGeometry,
	CylinderGeometry: CylinderGeometry,
	CylinderBufferGeometry: CylinderBufferGeometry,
	CircleGeometry: CircleGeometry,
	CircleBufferGeometry: CircleBufferGeometry,
	BoxGeometry: BoxGeometry,
	BoxBufferGeometry: BoxBufferGeometry
});
function ShadowMaterial( parameters ) {
	Material.call( this );
	this.type = 'ShadowMaterial';
	this.color = new Color( 0x000000 );
	this.opacity = 1.0;
	this.lights = true;
	this.transparent = true;
	this.setValues( parameters );
}
ShadowMaterial.prototype = Object.create( Material.prototype );
ShadowMaterial.prototype.constructor = ShadowMaterial;
ShadowMaterial.prototype.isShadowMaterial = true;
function RawShaderMaterial( parameters ) {
	ShaderMaterial.call( this, parameters );
	this.type = 'RawShaderMaterial';
}
RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
RawShaderMaterial.prototype.constructor = RawShaderMaterial;
RawShaderMaterial.prototype.isRawShaderMaterial = true;
function MeshStandardMaterial( parameters ) {
	Material.call( this );
	this.defines = { 'STANDARD': '' };
	this.type = 'MeshStandardMaterial';
	this.color = new Color( 0xffffff );
	this.roughness = 0.5;
	this.metalness = 0.5;
	this.map = null;
	this.lightMap = null;
	this.lightMapIntensity = 1.0;
	this.aoMap = null;
	this.aoMapIntensity = 1.0;
	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;
	this.bumpMap = null;
	this.bumpScale = 1;
	this.normalMap = null;
	this.normalScale = new Vector2( 1, 1 );
	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;
	this.roughnessMap = null;
	this.metalnessMap = null;
	this.alphaMap = null;
	this.envMap = null;
	this.envMapIntensity = 1.0;
	this.refractionRatio = 0.98;
	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';
	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;
	this.setValues( parameters );
}
MeshStandardMaterial.prototype = Object.create( Material.prototype );
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
MeshStandardMaterial.prototype.copy = function ( source ) {
	Material.prototype.copy.call( this, source );
	this.defines = { 'STANDARD': '' };
	this.color.copy( source.color );
	this.roughness = source.roughness;
	this.metalness = source.metalness;
	this.map = source.map;
	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;
	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;
	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;
	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;
	this.normalMap = source.normalMap;
	this.normalScale.copy( source.normalScale );
	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;
	this.roughnessMap = source.roughnessMap;
	this.metalnessMap = source.metalnessMap;
	this.alphaMap = source.alphaMap;
	this.envMap = source.envMap;
	this.envMapIntensity = source.envMapIntensity;
	this.refractionRatio = source.refractionRatio;
	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;
	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;
	return this;
};
function MeshPhysicalMaterial( parameters ) {
	MeshStandardMaterial.call( this );
	this.defines = { 'PHYSICAL': '' };
	this.type = 'MeshPhysicalMaterial';
	this.reflectivity = 0.5;
	this.clearCoat = 0.0;
	this.clearCoatRoughness = 0.0;
	this.setValues( parameters );
}
MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
MeshPhysicalMaterial.prototype.copy = function ( source ) {
	MeshStandardMaterial.prototype.copy.call( this, source );
	this.defines = { 'PHYSICAL': '' };
	this.reflectivity = source.reflectivity;
	this.clearCoat = source.clearCoat;
	this.clearCoatRoughness = source.clearCoatRoughness;
	return this;
};
function MeshPhongMaterial( parameters ) {
	Material.call( this );
	this.type = 'MeshPhongMaterial';
	this.color = new Color( 0xffffff );
	this.specular = new Color( 0x111111 );
	this.shininess = 30;
	this.map = null;
	this.lightMap = null;
	this.lightMapIntensity = 1.0;
	this.aoMap = null;
	this.aoMapIntensity = 1.0;
	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;
	this.bumpMap = null;
	this.bumpScale = 1;
	this.normalMap = null;
	this.normalScale = new Vector2( 1, 1 );
	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;
	this.specularMap = null;
	this.alphaMap = null;
	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;
	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';
	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;
	this.setValues( parameters );
}
MeshPhongMaterial.prototype = Object.create( Material.prototype );
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
MeshPhongMaterial.prototype.copy = function ( source ) {
	Material.prototype.copy.call( this, source );
	this.color.copy( source.color );
	this.specular.copy( source.specular );
	this.shininess = source.shininess;
	this.map = source.map;
	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;
	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;
	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;
	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;
	this.normalMap = source.normalMap;
	this.normalScale.copy( source.normalScale );
	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;
	this.specularMap = source.specularMap;
	this.alphaMap = source.alphaMap;
	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;
	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;
	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;
	return this;
};
function MeshToonMaterial( parameters ) {
	MeshPhongMaterial.call( this );
	this.defines = { 'TOON': '' };
	this.type = 'MeshToonMaterial';
	this.gradientMap = null;
	this.setValues( parameters );
}
MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );
MeshToonMaterial.prototype.constructor = MeshToonMaterial;
MeshToonMaterial.prototype.isMeshToonMaterial = true;
MeshToonMaterial.prototype.copy = function ( source ) {
	MeshPhongMaterial.prototype.copy.call( this, source );
	this.gradientMap = source.gradientMap;
	return this;
};
function MeshNormalMaterial( parameters ) {
	Material.call( this );
	this.type = 'MeshNormalMaterial';
	this.bumpMap = null;
	this.bumpScale = 1;
	this.normalMap = null;
	this.normalScale = new Vector2( 1, 1 );
	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;
	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.fog = false;
	this.lights = false;
	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;
	this.setValues( parameters );
}
MeshNormalMaterial.prototype = Object.create( Material.prototype );
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
MeshNormalMaterial.prototype.copy = function ( source ) {
	Material.prototype.copy.call( this, source );
	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;
	this.normalMap = source.normalMap;
	this.normalScale.copy( source.normalScale );
	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;
	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;
	return this;
};
function MeshLambertMaterial( parameters ) {
	Material.call( this );
	this.type = 'MeshLambertMaterial';
	this.color = new Color( 0xffffff );
	this.map = null;
	this.lightMap = null;
	this.lightMapIntensity = 1.0;
	this.aoMap = null;
	this.aoMapIntensity = 1.0;
	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;
	this.specularMap = null;
	this.alphaMap = null;
	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;
	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';
	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;
	this.setValues( parameters );
}
MeshLambertMaterial.prototype = Object.create( Material.prototype );
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
MeshLambertMaterial.prototype.copy = function ( source ) {
	Material.prototype.copy.call( this, source );
	this.color.copy( source.color );
	this.map = source.map;
	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;
	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;
	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;
	this.specularMap = source.specularMap;
	this.alphaMap = source.alphaMap;
	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;
	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;
	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;
	return this;
};
function LineDashedMaterial( parameters ) {
	LineBasicMaterial.call( this );
	this.type = 'LineDashedMaterial';
	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;
	this.setValues( parameters );
}
LineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );
LineDashedMaterial.prototype.constructor = LineDashedMaterial;
LineDashedMaterial.prototype.isLineDashedMaterial = true;
LineDashedMaterial.prototype.copy = function ( source ) {
	LineBasicMaterial.prototype.copy.call( this, source );
	this.scale = source.scale;
	this.dashSize = source.dashSize;
	this.gapSize = source.gapSize;
	return this;
};
var Materials = Object.freeze({
	ShadowMaterial: ShadowMaterial,
	SpriteMaterial: SpriteMaterial,
	RawShaderMaterial: RawShaderMaterial,
	ShaderMaterial: ShaderMaterial,
	PointsMaterial: PointsMaterial,
	MeshPhysicalMaterial: MeshPhysicalMaterial,
	MeshStandardMaterial: MeshStandardMaterial,
	MeshPhongMaterial: MeshPhongMaterial,
	MeshToonMaterial: MeshToonMaterial,
	MeshNormalMaterial: MeshNormalMaterial,
	MeshLambertMaterial: MeshLambertMaterial,
	MeshDepthMaterial: MeshDepthMaterial,
	MeshDistanceMaterial: MeshDistanceMaterial,
	MeshBasicMaterial: MeshBasicMaterial,
	LineDashedMaterial: LineDashedMaterial,
	LineBasicMaterial: LineBasicMaterial,
	Material: Material
});
var Cache = {
	enabled: false,
	files: {},
	add: function ( key, file ) {
		if ( this.enabled === false ) return;
		this.files[ key ] = file;
	},
	get: function ( key ) {
		if ( this.enabled === false ) return;
		return this.files[ key ];
	},
	remove: function ( key ) {
		delete this.files[ key ];
	},
	clear: function () {
		this.files = {};
	}
};
function LoadingManager( onLoad, onProgress, onError ) {
	var scope = this;
	var isLoading = false;
	var itemsLoaded = 0;
	var itemsTotal = 0;
	var urlModifier = undefined;
	this.onStart = undefined;
	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;
	this.itemStart = function ( url ) {
		itemsTotal ++;
		if ( isLoading === false ) {
			if ( scope.onStart !== undefined ) {
				scope.onStart( url, itemsLoaded, itemsTotal );
			}
		}
		isLoading = true;
	};
	this.itemEnd = function ( url ) {
		itemsLoaded ++;
		if ( scope.onProgress !== undefined ) {
			scope.onProgress( url, itemsLoaded, itemsTotal );
		}
		if ( itemsLoaded === itemsTotal ) {
			isLoading = false;
			if ( scope.onLoad !== undefined ) {
				scope.onLoad();
			}
		}
	};
	this.itemError = function ( url ) {
		if ( scope.onError !== undefined ) {
			scope.onError( url );
		}
	};
	this.resolveURL = function ( url ) {
		if ( urlModifier ) {
			return urlModifier( url );
		}
		return url;
	};
	this.setURLModifier = function ( transform ) {
		urlModifier = transform;
	};
}
var DefaultLoadingManager = new LoadingManager();
var loading = {};
function FileLoader( manager ) {
	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
}
Object.assign( FileLoader.prototype, {
	load: function ( url, onLoad, onProgress, onError ) {
		if ( url === undefined ) url = '';
		if ( this.path !== undefined ) url = this.path + url;
		url = this.manager.resolveURL( url );
		var scope = this;
		var cached = Cache.get( url );
		if ( cached !== undefined ) {
			scope.manager.itemStart( url );
			setTimeout( function () {
				if ( onLoad ) onLoad( cached );
				scope.manager.itemEnd( url );
			}, 0 );
			return cached;
		}
		if ( loading[ url ] !== undefined ) {
			loading[ url ].push( {
				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError
			} );
			return;
		}
		var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
		var dataUriRegexResult = url.match( dataUriRegex );
		if ( dataUriRegexResult ) {
			var mimeType = dataUriRegexResult[ 1 ];
			var isBase64 = !! dataUriRegexResult[ 2 ];
			var data = dataUriRegexResult[ 3 ];
			data = window.decodeURIComponent( data );
			if ( isBase64 ) data = window.atob( data );
			try {
				var response;
				var responseType = ( this.responseType || '' ).toLowerCase();
				switch ( responseType ) {
					case 'arraybuffer':
					case 'blob':
						var view = new Uint8Array( data.length );
						for ( var i = 0; i < data.length; i ++ ) {
							view[ i ] = data.charCodeAt( i );
						}
						if ( responseType === 'blob' ) {
							response = new Blob( [ view.buffer ], { type: mimeType } );
						} else {
							response = view.buffer;
						}
						break;
					case 'document':
						var parser = new DOMParser();
						response = parser.parseFromString( data, mimeType );
						break;
					case 'json':
						response = JSON.parse( data );
						break;
					default:
						response = data;
						break;
				}
				window.setTimeout( function () {
					if ( onLoad ) onLoad( response );
					scope.manager.itemEnd( url );
				}, 0 );
			} catch ( error ) {
				window.setTimeout( function () {
					if ( onError ) onError( error );
					scope.manager.itemEnd( url );
					scope.manager.itemError( url );
				}, 0 );
			}
		} else {
			loading[ url ] = [];
			loading[ url ].push( {
				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError
			} );
			var request = new XMLHttpRequest();
			request.open( 'GET', url, true );
			request.addEventListener( 'load', function ( event ) {
				var response = event.target.response;
				Cache.add( url, response );
				var callbacks = loading[ url ];
				delete loading[ url ];
				if ( this.status === 200 ) {
					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {
						var callback = callbacks[ i ];
						if ( callback.onLoad ) callback.onLoad( response );
					}
					scope.manager.itemEnd( url );
				} else if ( this.status === 0 ) {
					console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );
					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {
						var callback = callbacks[ i ];
						if ( callback.onLoad ) callback.onLoad( response );
					}
					scope.manager.itemEnd( url );
				} else {
					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {
						var callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );
					}
					scope.manager.itemEnd( url );
					scope.manager.itemError( url );
				}
			}, false );
			request.addEventListener( 'progress', function ( event ) {
				var callbacks = loading[ url ];
				for ( var i = 0, il = callbacks.length; i < il; i ++ ) {
					var callback = callbacks[ i ];
					if ( callback.onProgress ) callback.onProgress( event );
				}
			}, false );
			request.addEventListener( 'error', function ( event ) {
				var callbacks = loading[ url ];
				delete loading[ url ];
				for ( var i = 0, il = callbacks.length; i < il; i ++ ) {
					var callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( event );
				}
				scope.manager.itemEnd( url );
				scope.manager.itemError( url );
			}, false );
			if ( this.responseType !== undefined ) request.responseType = this.responseType;
			if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;
			if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );
			for ( var header in this.requestHeader ) {
				request.setRequestHeader( header, this.requestHeader[ header ] );
			}
			request.send( null );
		}
		scope.manager.itemStart( url );
		return request;
	},
	setPath: function ( value ) {
		this.path = value;
		return this;
	},
	setResponseType: function ( value ) {
		this.responseType = value;
		return this;
	},
	setWithCredentials: function ( value ) {
		this.withCredentials = value;
		return this;
	},
	setMimeType: function ( value ) {
		this.mimeType = value;
		return this;
	},
	setRequestHeader: function ( value ) {
		this.requestHeader = value;
		return this;
	}
} );
function CompressedTextureLoader( manager ) {
	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	this._parser = null;
}
Object.assign( CompressedTextureLoader.prototype, {
	load: function ( url, onLoad, onProgress, onError ) {
		var scope = this;
		var images = [];
		var texture = new CompressedTexture();
		texture.image = images;
		var loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		function loadTexture( i ) {
			loader.load( url[ i ], function ( buffer ) {
				var texDatas = scope._parser( buffer, true );
				images[ i ] = {
					width: texDatas.width,
					height: texDatas.height,
					format: texDatas.format,
					mipmaps: texDatas.mipmaps
				};
				loaded += 1;
				if ( loaded === 6 ) {
					if ( texDatas.mipmapCount === 1 )
						texture.minFilter = LinearFilter;
					texture.format = texDatas.format;
					texture.needsUpdate = true;
					if ( onLoad ) onLoad( texture );
				}
			}, onProgress, onError );
		}
		if ( Array.isArray( url ) ) {
			var loaded = 0;
			for ( var i = 0, il = url.length; i < il; ++ i ) {
				loadTexture( i );
			}
		} else {
			loader.load( url, function ( buffer ) {
				var texDatas = scope._parser( buffer, true );
				if ( texDatas.isCubemap ) {
					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
					for ( var f = 0; f < faces; f ++ ) {
						images[ f ] = { mipmaps: [] };
						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {
							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;
						}
					}
				} else {
					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;
				}
				if ( texDatas.mipmapCount === 1 ) {
					texture.minFilter = LinearFilter;
				}
				texture.format = texDatas.format;
				texture.needsUpdate = true;
				if ( onLoad ) onLoad( texture );
			}, onProgress, onError );
		}
		return texture;
	},
	setPath: function ( value ) {
		this.path = value;
		return this;
	}
} );
function DataTextureLoader( manager ) {
	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	this._parser = null;
}
Object.assign( DataTextureLoader.prototype, {
	load: function ( url, onLoad, onProgress, onError ) {
		var scope = this;
		var texture = new DataTexture();
		var loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.load( url, function ( buffer ) {
			var texData = scope._parser( buffer );
			if ( ! texData ) return;
			if ( undefined !== texData.image ) {
				texture.image = texData.image;
			} else if ( undefined !== texData.data ) {
				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;
			}
			texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
			texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;
			texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
			texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;
			texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
			if ( undefined !== texData.format ) {
				texture.format = texData.format;
			}
			if ( undefined !== texData.type ) {
				texture.type = texData.type;
			}
			if ( undefined !== texData.mipmaps ) {
				texture.mipmaps = texData.mipmaps;
			}
			if ( 1 === texData.mipmapCount ) {
				texture.minFilter = LinearFilter;
			}
			texture.needsUpdate = true;
			if ( onLoad ) onLoad( texture, texData );
		}, onProgress, onError );
		return texture;
	}
} );
function ImageLoader( manager ) {
	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
}
Object.assign( ImageLoader.prototype, {
	crossOrigin: 'Anonymous',
	load: function ( url, onLoad, onProgress, onError ) {
		if ( url === undefined ) url = '';
		if ( this.path !== undefined ) url = this.path + url;
		url = this.manager.resolveURL( url );
		var scope = this;
		var cached = Cache.get( url );
		if ( cached !== undefined ) {
			scope.manager.itemStart( url );
			setTimeout( function () {
				if ( onLoad ) onLoad( cached );
				scope.manager.itemEnd( url );
			}, 0 );
			return cached;
		}
		var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );
		image.addEventListener( 'load', function () {
			Cache.add( url, this );
			if ( onLoad ) onLoad( this );
			scope.manager.itemEnd( url );
		}, false );
		image.addEventListener( 'error', function ( event ) {
			if ( onError ) onError( event );
			scope.manager.itemEnd( url );
			scope.manager.itemError( url );
		}, false );
		if ( url.substr( 0, 5 ) !== 'data:' ) {
			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;
		}
		scope.manager.itemStart( url );
		image.src = url;
		return image;
	},
	setCrossOrigin: function ( value ) {
		this.crossOrigin = value;
		return this;
	},
	setPath: function ( value ) {
		this.path = value;
		return this;
	}
} );
function CubeTextureLoader( manager ) {
	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
}
Object.assign( CubeTextureLoader.prototype, {
	crossOrigin: 'Anonymous',
	load: function ( urls, onLoad, onProgress, onError ) {
		var texture = new CubeTexture();
		var loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );
		var loaded = 0;
		function loadTexture( i ) {
			loader.load( urls[ i ], function ( image ) {
				texture.images[ i ] = image;
				loaded ++;
				if ( loaded === 6 ) {
					texture.needsUpdate = true;
					if ( onLoad ) onLoad( texture );
				}
			}, undefined, onError );
		}
		for ( var i = 0; i < urls.length; ++ i ) {
			loadTexture( i );
		}
		return texture;
	},
	setCrossOrigin: function ( value ) {
		this.crossOrigin = value;
		return this;
	},
	setPath: function ( value ) {
		this.path = value;
		return this;
	}
} );
function TextureLoader( manager ) {
	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
}
Object.assign( TextureLoader.prototype, {
	crossOrigin: 'Anonymous',
	load: function ( url, onLoad, onProgress, onError ) {
		var loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );
		var texture = new Texture();
		texture.image = loader.load( url, function () {
			var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;
			texture.format = isJPEG ? RGBFormat : RGBAFormat;
			texture.needsUpdate = true;
			if ( onLoad !== undefined ) {
				onLoad( texture );
			}
		}, onProgress, onError );
		return texture;
	},
	setCrossOrigin: function ( value ) {
		this.crossOrigin = value;
		return this;
	},
	setPath: function ( value ) {
		this.path = value;
		return this;
	}
} );
function Light( color, intensity ) {
	Object3D.call( this );
	this.type = 'Light';
	this.color = new Color( color );
	this.intensity = intensity !== undefined ? intensity : 1;
	this.receiveShadow = undefined;
}
Light.prototype = Object.assign( Object.create( Object3D.prototype ), {
	constructor: Light,
	isLight: true,
	copy: function ( source ) {
		Object3D.prototype.copy.call( this, source );
		this.color.copy( source.color );
		this.intensity = source.intensity;
		return this;
	},
	toJSON: function ( meta ) {
		var data = Object3D.prototype.toJSON.call( this, meta );
		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;
		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();
		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;
		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();
		return data;
	}
} );
function HemisphereLight( skyColor, groundColor, intensity ) {
	Light.call( this, skyColor, intensity );
	this.type = 'HemisphereLight';
	this.castShadow = undefined;
	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();
	this.groundColor = new Color( groundColor );
}
HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {
	constructor: HemisphereLight,
	isHemisphereLight: true,
	copy: function ( source ) {
		Light.prototype.copy.call( this, source );
		this.groundColor.copy( source.groundColor );
		return this;
	}
} );
function LightShadow( camera ) {
	this.camera = camera;
	this.bias = 0;
	this.radius = 1;
	this.mapSize = new Vector2( 512, 512 );
	this.map = null;
	this.matrix = new Matrix4();
}
Object.assign( LightShadow.prototype, {
	copy: function ( source ) {
		this.camera = source.camera.clone();
		this.bias = source.bias;
		this.radius = source.radius;
		this.mapSize.copy( source.mapSize );
		return this;
	},
	clone: function () {
		return new this.constructor().copy( this );
	},
	toJSON: function () {
		var object = {};
		if ( this.bias !== 0 ) object.bias = this.bias;
		if ( this.radius !== 1 ) object.radius = this.radius;
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();
		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;
		return object;
	}
} );
function SpotLightShadow() {
	LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );
}
SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {
	constructor: SpotLightShadow,
	isSpotLightShadow: true,
	update: function ( light ) {
		var camera = this.camera;
		var fov = _Math.RAD2DEG * 2 * light.angle;
		var aspect = this.mapSize.width / this.mapSize.height;
		var far = light.distance || camera.far;
		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {
			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();
		}
	}
} );
function SpotLight( color, intensity, distance, angle, penumbra, decay ) {
	Light.call( this, color, intensity );
	this.type = 'SpotLight';
	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();
	this.target = new Object3D();
	Object.defineProperty( this, 'power', {
		get: function () {
			return this.intensity * Math.PI;
		},
		set: function ( power ) {
			this.intensity = power / Math.PI;
		}
	} );
	this.distance = ( distance !== undefined ) ? distance : 0;
	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
	this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;
	this.shadow = new SpotLightShadow();
}
SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {
	constructor: SpotLight,
	isSpotLight: true,
	copy: function ( source ) {
		Light.prototype.copy.call( this, source );
		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;
		this.target = source.target.clone();
		this.shadow = source.shadow.clone();
		return this;
	}
} );
function PointLight( color, intensity, distance, decay ) {
	Light.call( this, color, intensity );
	this.type = 'PointLight';
	Object.defineProperty( this, 'power', {
		get: function () {
			return this.intensity * 4 * Math.PI;
		},
		set: function ( power ) {
			this.intensity = power / ( 4 * Math.PI );
		}
	} );
	this.distance = ( distance !== undefined ) ? distance : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;
	this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );
}
PointLight.prototype = Object.assign( Object.create( Light.prototype ), {
	constructor: PointLight,
	isPointLight: true,
	copy: function ( source ) {
		Light.prototype.copy.call( this, source );
		this.distance = source.distance;
		this.decay = source.decay;
		this.shadow = source.shadow.clone();
		return this;
	}
} );
function DirectionalLightShadow( ) {
	LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );
}
DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {
	constructor: DirectionalLightShadow
} );
function DirectionalLight( color, intensity ) {
	Light.call( this, color, intensity );
	this.type = 'DirectionalLight';
	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();
	this.target = new Object3D();
	this.shadow = new DirectionalLightShadow();
}
DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {
	constructor: DirectionalLight,
	isDirectionalLight: true,
	copy: function ( source ) {
		Light.prototype.copy.call( this, source );
		this.target = source.target.clone();
		this.shadow = source.shadow.clone();
		return this;
	}
} );
function AmbientLight( color, intensity ) {
	Light.call( this, color, intensity );
	this.type = 'AmbientLight';
	this.castShadow = undefined;
}
AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {
	constructor: AmbientLight,
	isAmbientLight: true
} );
function RectAreaLight( color, intensity, width, height ) {
	Light.call( this, color, intensity );
	this.type = 'RectAreaLight';
	this.position.set( 0, 1, 0 );
	this.updateMatrix();
	this.width = ( width !== undefined ) ? width : 10;
	this.height = ( height !== undefined ) ? height : 10;
}
RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {
	constructor: RectAreaLight,
	isRectAreaLight: true,
	copy: function ( source ) {
		Light.prototype.copy.call( this, source );
		this.width = source.width;
		this.height = source.height;
		return this;
	},
	toJSON: function ( meta ) {
		var data = Light.prototype.toJSON.call( this, meta );
		data.object.width = this.width;
		data.object.height = this.height;
		return data;
	}
} );
var AnimationUtils = {
	arraySlice: function ( array, from, to ) {
		if ( AnimationUtils.isTypedArray( array ) ) {
			return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );
		}
		return array.slice( from, to );
	},
	convertArray: function ( array, type, forceClone ) {
		if ( ! array ||
				! forceClone && array.constructor === type ) return array;
		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {
			return new type( array );
		}
		return Array.prototype.slice.call( array );
	},
	isTypedArray: function ( object ) {
		return ArrayBuffer.isView( object ) &&
				! ( object instanceof DataView );
	},
	getKeyframeOrder: function ( times ) {
		function compareTime( i, j ) {
			return times[ i ] - times[ j ];
		}
		var n = times.length;
		var result = new Array( n );
		for ( var i = 0; i !== n; ++ i ) result[ i ] = i;
		result.sort( compareTime );
		return result;
	},
	sortedArray: function ( values, stride, order ) {
		var nValues = values.length;
		var result = new values.constructor( nValues );
		for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {
			var srcOffset = order[ i ] * stride;
			for ( var j = 0; j !== stride; ++ j ) {
				result[ dstOffset ++ ] = values[ srcOffset + j ];
			}
		}
		return result;
	},
	flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {
		var i = 1, key = jsonKeys[ 0 ];
		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {
			key = jsonKeys[ i ++ ];
		}
		if ( key === undefined ) return;
		var value = key[ valuePropertyName ];
		if ( value === undefined ) return;
		if ( Array.isArray( value ) ) {
			do {
				value = key[ valuePropertyName ];
				if ( value !== undefined ) {
					times.push( key.time );
					values.push.apply( values, value );
				}
				key = jsonKeys[ i ++ ];
			} while ( key !== undefined );
		} else if ( value.toArray !== undefined ) {
			do {
				value = key[ valuePropertyName ];
				if ( value !== undefined ) {
					times.push( key.time );
					value.toArray( values, values.length );
				}
				key = jsonKeys[ i ++ ];
			} while ( key !== undefined );
		} else {
			do {
				value = key[ valuePropertyName ];
				if ( value !== undefined ) {
					times.push( key.time );
					values.push( value );
				}
				key = jsonKeys[ i ++ ];
			} while ( key !== undefined );
		}
	}
};
function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	this.parameterPositions = parameterPositions;
	this._cachedIndex = 0;
	this.resultBuffer = resultBuffer !== undefined ?
		resultBuffer : new sampleValues.constructor( sampleSize );
	this.sampleValues = sampleValues;
	this.valueSize = sampleSize;
}
Object.assign( Interpolant.prototype, {
	evaluate: function ( t ) {
		var pp = this.parameterPositions,
			i1 = this._cachedIndex,
			t1 = pp[ i1 ],
			t0 = pp[ i1 - 1 ];
		validate_interval: {
			seek: {
				var right;
				linear_scan: {
					forward_scan: if ( ! ( t < t1 ) ) {
						for ( var giveUpAt = i1 + 2; ; ) {
							if ( t1 === undefined ) {
								if ( t < t0 ) break forward_scan;
								i1 = pp.length;
								this._cachedIndex = i1;
								return this.afterEnd_( i1 - 1, t, t0 );
							}
							if ( i1 === giveUpAt ) break;
							t0 = t1;
							t1 = pp[ ++ i1 ];
							if ( t < t1 ) {
								break seek;
							}
						}
						right = pp.length;
						break linear_scan;
					}
					if ( ! ( t >= t0 ) ) {
						var t1global = pp[ 1 ];
						if ( t < t1global ) {
							i1 = 2;
							t0 = t1global;
						}
						for ( var giveUpAt = i1 - 2; ; ) {
							if ( t0 === undefined ) {
								this._cachedIndex = 0;
								return this.beforeStart_( 0, t, t1 );
							}
							if ( i1 === giveUpAt ) break;
							t1 = t0;
							t0 = pp[ -- i1 - 1 ];
							if ( t >= t0 ) {
								break seek;
							}
						}
						right = i1;
						i1 = 0;
						break linear_scan;
					}
					break validate_interval;
				}
				while ( i1 < right ) {
					var mid = ( i1 + right ) >>> 1;
					if ( t < pp[ mid ] ) {
						right = mid;
					} else {
						i1 = mid + 1;
					}
				}
				t1 = pp[ i1 ];
				t0 = pp[ i1 - 1 ];
				if ( t0 === undefined ) {
					this._cachedIndex = 0;
					return this.beforeStart_( 0, t, t1 );
				}
				if ( t1 === undefined ) {
					i1 = pp.length;
					this._cachedIndex = i1;
					return this.afterEnd_( i1 - 1, t0, t );
				}
			}
			this._cachedIndex = i1;
			this.intervalChanged_( i1, t0, t1 );
		}
		return this.interpolate_( i1, t0, t, t1 );
	},
	settings: null,
	DefaultSettings_: {},
	getSettings_: function () {
		return this.settings || this.DefaultSettings_;
	},
	copySampleValue_: function ( index ) {
		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;
		for ( var i = 0; i !== stride; ++ i ) {
			result[ i ] = values[ offset + i ];
		}
		return result;
	},
	interpolate_: function (                     ) {
		throw new Error( 'call to abstract method' );
	},
	intervalChanged_: function (                  ) {
	}
} );
Object.assign( Interpolant.prototype, {
	beforeStart_: Interpolant.prototype.copySampleValue_,
	afterEnd_: Interpolant.prototype.copySampleValue_,
} );
function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	this._weightPrev = - 0;
	this._offsetPrev = - 0;
	this._weightNext = - 0;
	this._offsetNext = - 0;
}
CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {
	constructor: CubicInterpolant,
	DefaultSettings_: {
		endingStart: ZeroCurvatureEnding,
		endingEnd: ZeroCurvatureEnding
	},
	intervalChanged_: function ( i1, t0, t1 ) {
		var pp = this.parameterPositions,
			iPrev = i1 - 2,
			iNext = i1 + 1,
			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];
		if ( tPrev === undefined ) {
			switch ( this.getSettings_().endingStart ) {
				case ZeroSlopeEnding:
					iPrev = i1;
					tPrev = 2 * t0 - t1;
					break;
				case WrapAroundEnding:
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];
					break;
				default:
					iPrev = i1;
					tPrev = t1;
			}
		}
		if ( tNext === undefined ) {
			switch ( this.getSettings_().endingEnd ) {
				case ZeroSlopeEnding:
					iNext = i1;
					tNext = 2 * t1 - t0;
					break;
				case WrapAroundEnding:
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];
					break;
				default:
					iNext = i1 - 1;
					tNext = t0;
			}
		}
		var halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;
		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;
	},
	interpolate_: function ( i1, t0, t, t1 ) {
		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,
			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;
		var sP = - wP * ppp + 2 * wP * pp - wP * p;
		var s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
		var s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
		var sN = wN * ppp - wN * pp;
		for ( var i = 0; i !== stride; ++ i ) {
			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];
		}
		return result;
	}
} );
function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
}
LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {
	constructor: LinearInterpolant,
	interpolate_: function ( i1, t0, t, t1 ) {
		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset1 = i1 * stride,
			offset0 = offset1 - stride,
			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;
		for ( var i = 0; i !== stride; ++ i ) {
			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;
		}
		return result;
	}
} );
function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
}
DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {
	constructor: DiscreteInterpolant,
	interpolate_: function ( i1                  ) {
		return this.copySampleValue_( i1 - 1 );
	}
} );
var KeyframeTrackPrototype;
KeyframeTrackPrototype = {
	TimeBufferType: Float32Array,
	ValueBufferType: Float32Array,
	DefaultInterpolation: InterpolateLinear,
	InterpolantFactoryMethodDiscrete: function ( result ) {
		return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );
	},
	InterpolantFactoryMethodLinear: function ( result ) {
		return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );
	},
	InterpolantFactoryMethodSmooth: function ( result ) {
		return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );
	},
	setInterpolation: function ( interpolation ) {
		var factoryMethod;
		switch ( interpolation ) {
			case InterpolateDiscrete:
				factoryMethod = this.InterpolantFactoryMethodDiscrete;
				break;
			case InterpolateLinear:
				factoryMethod = this.InterpolantFactoryMethodLinear;
				break;
			case InterpolateSmooth:
				factoryMethod = this.InterpolantFactoryMethodSmooth;
				break;
		}
		if ( factoryMethod === undefined ) {
			var message = "unsupported interpolation for " +
					this.ValueTypeName + " keyframe track named " + this.name;
			if ( this.createInterpolant === undefined ) {
				if ( interpolation !== this.DefaultInterpolation ) {
					this.setInterpolation( this.DefaultInterpolation );
				} else {
					throw new Error( message );
				}
			}
			console.warn( 'THREE.KeyframeTrackPrototype:', message );
			return;
		}
		this.createInterpolant = factoryMethod;
	},
	getInterpolation: function () {
		switch ( this.createInterpolant ) {
			case this.InterpolantFactoryMethodDiscrete:
				return InterpolateDiscrete;
			case this.InterpolantFactoryMethodLinear:
				return InterpolateLinear;
			case this.InterpolantFactoryMethodSmooth:
				return InterpolateSmooth;
		}
	},
	getValueSize: function () {
		return this.values.length / this.times.length;
	},
	shift: function ( timeOffset ) {
		if ( timeOffset !== 0.0 ) {
			var times = this.times;
			for ( var i = 0, n = times.length; i !== n; ++ i ) {
				times[ i ] += timeOffset;
			}
		}
		return this;
	},
	scale: function ( timeScale ) {
		if ( timeScale !== 1.0 ) {
			var times = this.times;
			for ( var i = 0, n = times.length; i !== n; ++ i ) {
				times[ i ] *= timeScale;
			}
		}
		return this;
	},
	trim: function ( startTime, endTime ) {
		var times = this.times,
			nKeys = times.length,
			from = 0,
			to = nKeys - 1;
		while ( from !== nKeys && times[ from ] < startTime ) ++ from;
		while ( to !== - 1 && times[ to ] > endTime ) -- to;
		++ to;
		if ( from !== 0 || to !== nKeys ) {
			if ( from >= to ) to = Math.max( to, 1 ), from = to - 1;
			var stride = this.getValueSize();
			this.times = AnimationUtils.arraySlice( times, from, to );
			this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );
		}
		return this;
	},
	validate: function () {
		var valid = true;
		var valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {
			console.error( 'THREE.KeyframeTrackPrototype: Invalid value size in track.', this );
			valid = false;
		}
		var times = this.times,
			values = this.values,
			nKeys = times.length;
		if ( nKeys === 0 ) {
			console.error( 'THREE.KeyframeTrackPrototype: Track is empty.', this );
			valid = false;
		}
		var prevTime = null;
		for ( var i = 0; i !== nKeys; i ++ ) {
			var currTime = times[ i ];
			if ( typeof currTime === 'number' && isNaN( currTime ) ) {
				console.error( 'THREE.KeyframeTrackPrototype: Time is not a valid number.', this, i, currTime );
				valid = false;
				break;
			}
			if ( prevTime !== null && prevTime > currTime ) {
				console.error( 'THREE.KeyframeTrackPrototype: Out of order keys.', this, i, currTime, prevTime );
				valid = false;
				break;
			}
			prevTime = currTime;
		}
		if ( values !== undefined ) {
			if ( AnimationUtils.isTypedArray( values ) ) {
				for ( var i = 0, n = values.length; i !== n; ++ i ) {
					var value = values[ i ];
					if ( isNaN( value ) ) {
						console.error( 'THREE.KeyframeTrackPrototype: Value is not a valid number.', this, i, value );
						valid = false;
						break;
					}
				}
			}
		}
		return valid;
	},
	optimize: function () {
		var times = this.times,
			values = this.values,
			stride = this.getValueSize(),
			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
			writeIndex = 1,
			lastIndex = times.length - 1;
		for ( var i = 1; i < lastIndex; ++ i ) {
			var keep = false;
			var time = times[ i ];
			var timeNext = times[ i + 1 ];
			if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {
				if ( ! smoothInterpolation ) {
					var offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;
					for ( var j = 0; j !== stride; ++ j ) {
						var value = values[ offset + j ];
						if ( value !== values[ offsetP + j ] ||
								value !== values[ offsetN + j ] ) {
							keep = true;
							break;
						}
					}
				} else keep = true;
			}
			if ( keep ) {
				if ( i !== writeIndex ) {
					times[ writeIndex ] = times[ i ];
					var readOffset = i * stride,
						writeOffset = writeIndex * stride;
					for ( var j = 0; j !== stride; ++ j )
						values[ writeOffset + j ] = values[ readOffset + j ];
				}
				++ writeIndex;
			}
		}
		if ( lastIndex > 0 ) {
			times[ writeIndex ] = times[ lastIndex ];
			for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )
				values[ writeOffset + j ] = values[ readOffset + j ];
			++ writeIndex;
		}
		if ( writeIndex !== times.length ) {
			this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
			this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );
		}
		return this;
	}
};
function KeyframeTrackConstructor( name, times, values, interpolation ) {
	if ( name === undefined ) throw new Error( 'track name is undefined' );
	if ( times === undefined || times.length === 0 ) {
		throw new Error( 'no keyframes in track named ' + name );
	}
	this.name = name;
	this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
	this.values = AnimationUtils.convertArray( values, this.ValueBufferType );
	this.setInterpolation( interpolation || this.DefaultInterpolation );
	this.validate();
	this.optimize();
}
function VectorKeyframeTrack( name, times, values, interpolation ) {
	KeyframeTrackConstructor.call( this, name, times, values, interpolation );
}
VectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrackPrototype ), {
	constructor: VectorKeyframeTrack,
	ValueTypeName: 'vector'
} );
function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
}
QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {
	constructor: QuaternionLinearInterpolant,
	interpolate_: function ( i1, t0, t, t1 ) {
		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = i1 * stride,
			alpha = ( t - t0 ) / ( t1 - t0 );
		for ( var end = offset + stride; offset !== end; offset += 4 ) {
			Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );
		}
		return result;
	}
} );
function QuaternionKeyframeTrack( name, times, values, interpolation ) {
	KeyframeTrackConstructor.call( this, name, times, values, interpolation );
}
QuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrackPrototype ), {
	constructor: QuaternionKeyframeTrack,
	ValueTypeName: 'quaternion',
	DefaultInterpolation: InterpolateLinear,
	InterpolantFactoryMethodLinear: function ( result ) {
		return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );
	},
	InterpolantFactoryMethodSmooth: undefined
} );
function NumberKeyframeTrack( name, times, values, interpolation ) {
	KeyframeTrackConstructor.call( this, name, times, values, interpolation );
}
NumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrackPrototype ), {
	constructor: NumberKeyframeTrack,
	ValueTypeName: 'number'
} );
function StringKeyframeTrack( name, times, values, interpolation ) {
	KeyframeTrackConstructor.call( this, name, times, values, interpolation );
}
StringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrackPrototype ), {
	constructor: StringKeyframeTrack,
	ValueTypeName: 'string',
	ValueBufferType: Array,
	DefaultInterpolation: InterpolateDiscrete,
	InterpolantFactoryMethodLinear: undefined,
	InterpolantFactoryMethodSmooth: undefined
} );
function BooleanKeyframeTrack( name, times, values ) {
	KeyframeTrackConstructor.call( this, name, times, values );
}
BooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrackPrototype ), {
	constructor: BooleanKeyframeTrack,
	ValueTypeName: 'bool',
	ValueBufferType: Array,
	DefaultInterpolation: InterpolateDiscrete,
	InterpolantFactoryMethodLinear: undefined,
	InterpolantFactoryMethodSmooth: undefined
} );
function ColorKeyframeTrack( name, times, values, interpolation ) {
	KeyframeTrackConstructor.call( this, name, times, values, interpolation );
}
ColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrackPrototype ), {
	constructor: ColorKeyframeTrack,
	ValueTypeName: 'color'
} );
function KeyframeTrack( name, times, values, interpolation ) {
	KeyframeTrackConstructor.apply( this, name, times, values, interpolation );
}
KeyframeTrack.prototype = KeyframeTrackPrototype;
KeyframeTrackPrototype.constructor = KeyframeTrack;
Object.assign( KeyframeTrack, {
	parse: function ( json ) {
		if ( json.type === undefined ) {
			throw new Error( 'track type undefined, can not parse' );
		}
		var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );
		if ( json.times === undefined ) {
			var times = [], values = [];
			AnimationUtils.flattenJSON( json.keys, times, values, 'value' );
			json.times = times;
			json.values = values;
		}
		if ( trackType.parse !== undefined ) {
			return trackType.parse( json );
		} else {
			return new trackType( json.name, json.times, json.values, json.interpolation );
		}
	},
	toJSON: function ( track ) {
		var trackType = track.constructor;
		var json;
		if ( trackType.toJSON !== undefined ) {
			json = trackType.toJSON( track );
		} else {
			json = {
				'name': track.name,
				'times': AnimationUtils.convertArray( track.times, Array ),
				'values': AnimationUtils.convertArray( track.values, Array )
			};
			var interpolation = track.getInterpolation();
			if ( interpolation !== track.DefaultInterpolation ) {
				json.interpolation = interpolation;
			}
		}
		json.type = track.ValueTypeName;
		return json;
	},
	_getTrackTypeForValueTypeName: function ( typeName ) {
		switch ( typeName.toLowerCase() ) {
			case 'scalar':
			case 'double':
			case 'float':
			case 'number':
			case 'integer':
				return NumberKeyframeTrack;
			case 'vector':
			case 'vector2':
			case 'vector3':
			case 'vector4':
				return VectorKeyframeTrack;
			case 'color':
				return ColorKeyframeTrack;
			case 'quaternion':
				return QuaternionKeyframeTrack;
			case 'bool':
			case 'boolean':
				return BooleanKeyframeTrack;
			case 'string':
				return StringKeyframeTrack;
		}
		throw new Error( 'Unsupported typeName: ' + typeName );
	}
} );
function AnimationClip( name, duration, tracks ) {
	this.name = name;
	this.tracks = tracks;
	this.duration = ( duration !== undefined ) ? duration : - 1;
	this.uuid = _Math.generateUUID();
	if ( this.duration < 0 ) {
		this.resetDuration();
	}
	this.optimize();
}
Object.assign( AnimationClip, {
	parse: function ( json ) {
		var tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );
		for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {
			tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );
		}
		return new AnimationClip( json.name, json.duration, tracks );
	},
	toJSON: function ( clip ) {
		var tracks = [],
			clipTracks = clip.tracks;
		var json = {
			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks
		};
		for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {
			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );
		}
		return json;
	},
	CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {
		var numMorphTargets = morphTargetSequence.length;
		var tracks = [];
		for ( var i = 0; i < numMorphTargets; i ++ ) {
			var times = [];
			var values = [];
			times.push(
				( i + numMorphTargets - 1 ) % numMorphTargets,
				i,
				( i + 1 ) % numMorphTargets );
			values.push( 0, 1, 0 );
			var order = AnimationUtils.getKeyframeOrder( times );
			times = AnimationUtils.sortedArray( times, 1, order );
			values = AnimationUtils.sortedArray( values, 1, order );
			if ( ! noLoop && times[ 0 ] === 0 ) {
				times.push( numMorphTargets );
				values.push( values[ 0 ] );
			}
			tracks.push(
				new NumberKeyframeTrack(
					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
					times, values
				).scale( 1.0 / fps ) );
		}
		return new AnimationClip( name, - 1, tracks );
	},
	findByName: function ( objectOrClipArray, name ) {
		var clipArray = objectOrClipArray;
		if ( ! Array.isArray( objectOrClipArray ) ) {
			var o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;
		}
		for ( var i = 0; i < clipArray.length; i ++ ) {
			if ( clipArray[ i ].name === name ) {
				return clipArray[ i ];
			}
		}
		return null;
	},
	CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {
		var animationToMorphTargets = {};
		var pattern = /^([\w-]*?)([\d]+)$/;
		for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {
			var morphTarget = morphTargets[ i ];
			var parts = morphTarget.name.match( pattern );
			if ( parts && parts.length > 1 ) {
				var name = parts[ 1 ];
				var animationMorphTargets = animationToMorphTargets[ name ];
				if ( ! animationMorphTargets ) {
					animationToMorphTargets[ name ] = animationMorphTargets = [];
				}
				animationMorphTargets.push( morphTarget );
			}
		}
		var clips = [];
		for ( var name in animationToMorphTargets ) {
			clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );
		}
		return clips;
	},
	parseAnimation: function ( animation, bones ) {
		if ( ! animation ) {
			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
			return null;
		}
		var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {
			if ( animationKeys.length !== 0 ) {
				var times = [];
				var values = [];
				AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );
				if ( times.length !== 0 ) {
					destTracks.push( new trackType( trackName, times, values ) );
				}
			}
		};
		var tracks = [];
		var clipName = animation.name || 'default';
		var duration = animation.length || - 1;
		var fps = animation.fps || 30;
		var hierarchyTracks = animation.hierarchy || [];
		for ( var h = 0; h < hierarchyTracks.length; h ++ ) {
			var animationKeys = hierarchyTracks[ h ].keys;
			if ( ! animationKeys || animationKeys.length === 0 ) continue;
			if ( animationKeys[ 0 ].morphTargets ) {
				var morphTargetNames = {};
				for ( var k = 0; k < animationKeys.length; k ++ ) {
					if ( animationKeys[ k ].morphTargets ) {
						for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {
							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;
						}
					}
				}
				for ( var morphTargetName in morphTargetNames ) {
					var times = [];
					var values = [];
					for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {
						var animationKey = animationKeys[ k ];
						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );
					}
					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );
				}
				duration = morphTargetNames.length * ( fps || 1.0 );
			} else {
				var boneName = '.bones[' + bones[ h ].name + ']';
				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.position',
					animationKeys, 'pos', tracks );
				addNonemptyTrack(
					QuaternionKeyframeTrack, boneName + '.quaternion',
					animationKeys, 'rot', tracks );
				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.scale',
					animationKeys, 'scl', tracks );
			}
		}
		if ( tracks.length === 0 ) {
			return null;
		}
		var clip = new AnimationClip( clipName, duration, tracks );
		return clip;
	}
} );
Object.assign( AnimationClip.prototype, {
	resetDuration: function () {
		var tracks = this.tracks, duration = 0;
		for ( var i = 0, n = tracks.length; i !== n; ++ i ) {
			var track = this.tracks[ i ];
			duration = Math.max( duration, track.times[ track.times.length - 1 ] );
		}
		this.duration = duration;
	},
	trim: function () {
		for ( var i = 0; i < this.tracks.length; i ++ ) {
			this.tracks[ i ].trim( 0, this.duration );
		}
		return this;
	},
	optimize: function () {
		for ( var i = 0; i < this.tracks.length; i ++ ) {
			this.tracks[ i ].optimize();
		}
		return this;
	}
} );
function MaterialLoader( manager ) {
	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	this.textures = {};
}
Object.assign( MaterialLoader.prototype, {
	load: function ( url, onLoad, onProgress, onError ) {
		var scope = this;
		var loader = new FileLoader( scope.manager );
		loader.load( url, function ( text ) {
			onLoad( scope.parse( JSON.parse( text ) ) );
		}, onProgress, onError );
	},
	setTextures: function ( value ) {
		this.textures = value;
	},
	parse: function ( json ) {
		var textures = this.textures;
		function getTexture( name ) {
			if ( textures[ name ] === undefined ) {
				console.warn( 'THREE.MaterialLoader: Undefined texture', name );
			}
			return textures[ name ];
		}
		var material = new Materials[ json.type ]();
		if ( json.uuid !== undefined ) material.uuid = json.uuid;
		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined ) material.color.setHex( json.color );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metalness !== undefined ) material.metalness = json.metalness;
		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;
		if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;
		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
		if ( json.fog !== undefined ) material.fog = json.fog;
		if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;
		if ( json.rotation !== undefined ) material.rotation = json.rotation;
		if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
		if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
		if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
		if ( json.scale !== undefined ) material.scale = json.scale;
		if ( json.skinning !== undefined ) material.skinning = json.skinning;
		if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
		if ( json.dithering !== undefined ) material.dithering = json.dithering;
		if ( json.visible !== undefined ) material.visible = json.visible;
		if ( json.userData !== undefined ) material.userData = json.userData;
		if ( json.shading !== undefined ) material.flatShading = json.shading === 1;
		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;
		if ( json.map !== undefined ) material.map = getTexture( json.map );
		if ( json.alphaMap !== undefined ) {
			material.alphaMap = getTexture( json.alphaMap );
			material.transparent = true;
		}
		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;
		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
		if ( json.normalScale !== undefined ) {
			var normalScale = json.normalScale;
			if ( Array.isArray( normalScale ) === false ) {
				normalScale = [ normalScale, normalScale ];
			}
			material.normalScale = new Vector2().fromArray( normalScale );
		}
		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;
		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );
		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;
		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );
		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;
		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;
		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );
		return material;
	}
} );
function BufferGeometryLoader( manager ) {
	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
}
Object.assign( BufferGeometryLoader.prototype, {
	load: function ( url, onLoad, onProgress, onError ) {
		var scope = this;
		var loader = new FileLoader( scope.manager );
		loader.load( url, function ( text ) {
			onLoad( scope.parse( JSON.parse( text ) ) );
		}, onProgress, onError );
	},
	parse: function ( json ) {
		var geometry = new BufferGeometry();
		var index = json.data.index;
		if ( index !== undefined ) {
			var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );
		}
		var attributes = json.data.attributes;
		for ( var key in attributes ) {
			var attribute = attributes[ key ];
			var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );
			geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );
		}
		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
		if ( groups !== undefined ) {
			for ( var i = 0, n = groups.length; i !== n; ++ i ) {
				var group = groups[ i ];
				geometry.addGroup( group.start, group.count, group.materialIndex );
			}
		}
		var boundingSphere = json.data.boundingSphere;
		if ( boundingSphere !== undefined ) {
			var center = new Vector3();
			if ( boundingSphere.center !== undefined ) {
				center.fromArray( boundingSphere.center );
			}
			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );
		}
		return geometry;
	}
} );
var TYPED_ARRAYS = {
	Int8Array: Int8Array,
	Uint8Array: Uint8Array,
	Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
	Int16Array: Int16Array,
	Uint16Array: Uint16Array,
	Int32Array: Int32Array,
	Uint32Array: Uint32Array,
	Float32Array: Float32Array,
	Float64Array: Float64Array
};
function Loader() {
	this.onLoadStart = function () {};
	this.onLoadProgress = function () {};
	this.onLoadComplete = function () {};
}
Loader.Handlers = {
	handlers: [],
	add: function ( regex, loader ) {
		this.handlers.push( regex, loader );
	},
	get: function ( file ) {
		var handlers = this.handlers;
		for ( var i = 0, l = handlers.length; i < l; i += 2 ) {
			var regex = handlers[ i ];
			var loader = handlers[ i + 1 ];
			if ( regex.test( file ) ) {
				return loader;
			}
		}
		return null;
	}
};
Object.assign( Loader.prototype, {
	crossOrigin: undefined,
	extractUrlBase: function ( url ) {
		var parts = url.split( '/' );
		if ( parts.length === 1 ) return './';
		parts.pop();
		return parts.join( '/' ) + '/';
	},
	initMaterials: function ( materials, texturePath, crossOrigin ) {
		var array = [];
		for ( var i = 0; i < materials.length; ++ i ) {
			array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );
		}
		return array;
	},
	createMaterial: ( function () {
		var BlendingMode = {
			NoBlending: NoBlending,
			NormalBlending: NormalBlending,
			AdditiveBlending: AdditiveBlending,
			SubtractiveBlending: SubtractiveBlending,
			MultiplyBlending: MultiplyBlending,
			CustomBlending: CustomBlending
		};
		var color = new Color();
		var textureLoader = new TextureLoader();
		var materialLoader = new MaterialLoader();
		return function createMaterial( m, texturePath, crossOrigin ) {
			var textures = {};
			function loadTexture( path, repeat, offset, wrap, anisotropy ) {
				var fullPath = texturePath + path;
				var loader = Loader.Handlers.get( fullPath );
				var texture;
				if ( loader !== null ) {
					texture = loader.load( fullPath );
				} else {
					textureLoader.setCrossOrigin( crossOrigin );
					texture = textureLoader.load( fullPath );
				}
				if ( repeat !== undefined ) {
					texture.repeat.fromArray( repeat );
					if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
					if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;
				}
				if ( offset !== undefined ) {
					texture.offset.fromArray( offset );
				}
				if ( wrap !== undefined ) {
					if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
					if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;
					if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
					if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;
				}
				if ( anisotropy !== undefined ) {
					texture.anisotropy = anisotropy;
				}
				var uuid = _Math.generateUUID();
				textures[ uuid ] = texture;
				return uuid;
			}
			var json = {
				uuid: _Math.generateUUID(),
				type: 'MeshLambertMaterial'
			};
			for ( var name in m ) {
				var value = m[ name ];
				switch ( name ) {
					case 'DbgColor':
					case 'DbgIndex':
					case 'opticalDensity':
					case 'illumination':
						break;
					case 'DbgName':
						json.name = value;
						break;
					case 'blending':
						json.blending = BlendingMode[ value ];
						break;
					case 'colorAmbient':
					case 'mapAmbient':
						console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
						break;
					case 'colorDiffuse':
						json.color = color.fromArray( value ).getHex();
						break;
					case 'colorSpecular':
						json.specular = color.fromArray( value ).getHex();
						break;
					case 'colorEmissive':
						json.emissive = color.fromArray( value ).getHex();
						break;
					case 'specularCoef':
						json.shininess = value;
						break;
					case 'shading':
						if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
						if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
						if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
						break;
					case 'mapDiffuse':
						json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
						break;
					case 'mapDiffuseRepeat':
					case 'mapDiffuseOffset':
					case 'mapDiffuseWrap':
					case 'mapDiffuseAnisotropy':
						break;
					case 'mapEmissive':
						json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
						break;
					case 'mapEmissiveRepeat':
					case 'mapEmissiveOffset':
					case 'mapEmissiveWrap':
					case 'mapEmissiveAnisotropy':
						break;
					case 'mapLight':
						json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
						break;
					case 'mapLightRepeat':
					case 'mapLightOffset':
					case 'mapLightWrap':
					case 'mapLightAnisotropy':
						break;
					case 'mapAO':
						json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
						break;
					case 'mapAORepeat':
					case 'mapAOOffset':
					case 'mapAOWrap':
					case 'mapAOAnisotropy':
						break;
					case 'mapBump':
						json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
						break;
					case 'mapBumpScale':
						json.bumpScale = value;
						break;
					case 'mapBumpRepeat':
					case 'mapBumpOffset':
					case 'mapBumpWrap':
					case 'mapBumpAnisotropy':
						break;
					case 'mapNormal':
						json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
						break;
					case 'mapNormalFactor':
						json.normalScale = [ value, value ];
						break;
					case 'mapNormalRepeat':
					case 'mapNormalOffset':
					case 'mapNormalWrap':
					case 'mapNormalAnisotropy':
						break;
					case 'mapSpecular':
						json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
						break;
					case 'mapSpecularRepeat':
					case 'mapSpecularOffset':
					case 'mapSpecularWrap':
					case 'mapSpecularAnisotropy':
						break;
					case 'mapMetalness':
						json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
						break;
					case 'mapMetalnessRepeat':
					case 'mapMetalnessOffset':
					case 'mapMetalnessWrap':
					case 'mapMetalnessAnisotropy':
						break;
					case 'mapRoughness':
						json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
						break;
					case 'mapRoughnessRepeat':
					case 'mapRoughnessOffset':
					case 'mapRoughnessWrap':
					case 'mapRoughnessAnisotropy':
						break;
					case 'mapAlpha':
						json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
						break;
					case 'mapAlphaRepeat':
					case 'mapAlphaOffset':
					case 'mapAlphaWrap':
					case 'mapAlphaAnisotropy':
						break;
					case 'flipSided':
						json.side = BackSide;
						break;
					case 'doubleSided':
						json.side = DoubleSide;
						break;
					case 'transparency':
						console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
						json.opacity = value;
						break;
					case 'depthTest':
					case 'depthWrite':
					case 'colorWrite':
					case 'opacity':
					case 'reflectivity':
					case 'transparent':
					case 'visible':
					case 'wireframe':
						json[ name ] = value;
						break;
					case 'vertexColors':
						if ( value === true ) json.vertexColors = VertexColors;
						if ( value === 'face' ) json.vertexColors = FaceColors;
						break;
					default:
						console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
						break;
				}
			}
			if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
			if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;
			if ( json.opacity < 1 ) json.transparent = true;
			materialLoader.setTextures( textures );
			return materialLoader.parse( json );
		};
	} )()
} );
function JSONLoader( manager ) {
	if ( typeof manager === 'boolean' ) {
		console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
		manager = undefined;
	}
	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	this.withCredentials = false;
}
Object.assign( JSONLoader.prototype, {
	load: function ( url, onLoad, onProgress, onError ) {
		var scope = this;
		var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );
		var loader = new FileLoader( this.manager );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {
			var json = JSON.parse( text );
			var metadata = json.metadata;
			if ( metadata !== undefined ) {
				var type = metadata.type;
				if ( type !== undefined ) {
					if ( type.toLowerCase() === 'object' ) {
						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
						return;
					}
					if ( type.toLowerCase() === 'scene' ) {
						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
						return;
					}
				}
			}
			var object = scope.parse( json, texturePath );
			onLoad( object.geometry, object.materials );
		}, onProgress, onError );
	},
	setTexturePath: function ( value ) {
		this.texturePath = value;
	},
	parse: ( function () {
		function parseModel( json, geometry ) {
			function isBitSet( value, position ) {
				return value & ( 1 << position );
			}
			var i, j, fi,
				offset, zLength,
				colorIndex, normalIndex, uvIndex, materialIndex,
				type,
				isQuad,
				hasMaterial,
				hasFaceVertexUv,
				hasFaceNormal, hasFaceVertexNormal,
				hasFaceColor, hasFaceVertexColor,
				vertex, face, faceA, faceB, hex, normal,
				uvLayer, uv, u, v,
				faces = json.faces,
				vertices = json.vertices,
				normals = json.normals,
				colors = json.colors,
				scale = json.scale,
				nUvLayers = 0;
			if ( json.uvs !== undefined ) {
				for ( i = 0; i < json.uvs.length; i ++ ) {
					if ( json.uvs[ i ].length ) nUvLayers ++;
				}
				for ( i = 0; i < nUvLayers; i ++ ) {
					geometry.faceVertexUvs[ i ] = [];
				}
			}
			offset = 0;
			zLength = vertices.length;
			while ( offset < zLength ) {
				vertex = new Vector3();
				vertex.x = vertices[ offset ++ ] * scale;
				vertex.y = vertices[ offset ++ ] * scale;
				vertex.z = vertices[ offset ++ ] * scale;
				geometry.vertices.push( vertex );
			}
			offset = 0;
			zLength = faces.length;
			while ( offset < zLength ) {
				type = faces[ offset ++ ];
				isQuad = isBitSet( type, 0 );
				hasMaterial = isBitSet( type, 1 );
				hasFaceVertexUv = isBitSet( type, 3 );
				hasFaceNormal = isBitSet( type, 4 );
				hasFaceVertexNormal = isBitSet( type, 5 );
				hasFaceColor = isBitSet( type, 6 );
				hasFaceVertexColor = isBitSet( type, 7 );
				if ( isQuad ) {
					faceA = new Face3();
					faceA.a = faces[ offset ];
					faceA.b = faces[ offset + 1 ];
					faceA.c = faces[ offset + 3 ];
					faceB = new Face3();
					faceB.a = faces[ offset + 1 ];
					faceB.b = faces[ offset + 2 ];
					faceB.c = faces[ offset + 3 ];
					offset += 4;
					if ( hasMaterial ) {
						materialIndex = faces[ offset ++ ];
						faceA.materialIndex = materialIndex;
						faceB.materialIndex = materialIndex;
					}
					fi = geometry.faces.length;
					if ( hasFaceVertexUv ) {
						for ( i = 0; i < nUvLayers; i ++ ) {
							uvLayer = json.uvs[ i ];
							geometry.faceVertexUvs[ i ][ fi ] = [];
							geometry.faceVertexUvs[ i ][ fi + 1 ] = [];
							for ( j = 0; j < 4; j ++ ) {
								uvIndex = faces[ offset ++ ];
								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];
								uv = new Vector2( u, v );
								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );
							}
						}
					}
					if ( hasFaceNormal ) {
						normalIndex = faces[ offset ++ ] * 3;
						faceA.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);
						faceB.normal.copy( faceA.normal );
					}
					if ( hasFaceVertexNormal ) {
						for ( i = 0; i < 4; i ++ ) {
							normalIndex = faces[ offset ++ ] * 3;
							normal = new Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);
							if ( i !== 2 ) faceA.vertexNormals.push( normal );
							if ( i !== 0 ) faceB.vertexNormals.push( normal );
						}
					}
					if ( hasFaceColor ) {
						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];
						faceA.color.setHex( hex );
						faceB.color.setHex( hex );
					}
					if ( hasFaceVertexColor ) {
						for ( i = 0; i < 4; i ++ ) {
							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];
							if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
							if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );
						}
					}
					geometry.faces.push( faceA );
					geometry.faces.push( faceB );
				} else {
					face = new Face3();
					face.a = faces[ offset ++ ];
					face.b = faces[ offset ++ ];
					face.c = faces[ offset ++ ];
					if ( hasMaterial ) {
						materialIndex = faces[ offset ++ ];
						face.materialIndex = materialIndex;
					}
					fi = geometry.faces.length;
					if ( hasFaceVertexUv ) {
						for ( i = 0; i < nUvLayers; i ++ ) {
							uvLayer = json.uvs[ i ];
							geometry.faceVertexUvs[ i ][ fi ] = [];
							for ( j = 0; j < 3; j ++ ) {
								uvIndex = faces[ offset ++ ];
								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];
								uv = new Vector2( u, v );
								geometry.faceVertexUvs[ i ][ fi ].push( uv );
							}
						}
					}
					if ( hasFaceNormal ) {
						normalIndex = faces[ offset ++ ] * 3;
						face.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);
					}
					if ( hasFaceVertexNormal ) {
						for ( i = 0; i < 3; i ++ ) {
							normalIndex = faces[ offset ++ ] * 3;
							normal = new Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);
							face.vertexNormals.push( normal );
						}
					}
					if ( hasFaceColor ) {
						colorIndex = faces[ offset ++ ];
						face.color.setHex( colors[ colorIndex ] );
					}
					if ( hasFaceVertexColor ) {
						for ( i = 0; i < 3; i ++ ) {
							colorIndex = faces[ offset ++ ];
							face.vertexColors.push( new Color( colors[ colorIndex ] ) );
						}
					}
					geometry.faces.push( face );
				}
			}
		}
		function parseSkin( json, geometry ) {
			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;
			if ( json.skinWeights ) {
				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {
					var x = json.skinWeights[ i ];
					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;
					geometry.skinWeights.push( new Vector4( x, y, z, w ) );
				}
			}
			if ( json.skinIndices ) {
				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {
					var a = json.skinIndices[ i ];
					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;
					geometry.skinIndices.push( new Vector4( a, b, c, d ) );
				}
			}
			geometry.bones = json.bones;
			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {
				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );
			}
		}
		function parseMorphing( json, geometry ) {
			var scale = json.scale;
			if ( json.morphTargets !== undefined ) {
				for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {
					geometry.morphTargets[ i ] = {};
					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
					geometry.morphTargets[ i ].vertices = [];
					var dstVertices = geometry.morphTargets[ i ].vertices;
					var srcVertices = json.morphTargets[ i ].vertices;
					for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {
						var vertex = new Vector3();
						vertex.x = srcVertices[ v ] * scale;
						vertex.y = srcVertices[ v + 1 ] * scale;
						vertex.z = srcVertices[ v + 2 ] * scale;
						dstVertices.push( vertex );
					}
				}
			}
			if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {
				console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );
				var faces = geometry.faces;
				var morphColors = json.morphColors[ 0 ].colors;
				for ( var i = 0, l = faces.length; i < l; i ++ ) {
					faces[ i ].color.fromArray( morphColors, i * 3 );
				}
			}
		}
		function parseAnimations( json, geometry ) {
			var outputAnimations = [];
			var animations = [];
			if ( json.animation !== undefined ) {
				animations.push( json.animation );
			}
			if ( json.animations !== undefined ) {
				if ( json.animations.length ) {
					animations = animations.concat( json.animations );
				} else {
					animations.push( json.animations );
				}
			}
			for ( var i = 0; i < animations.length; i ++ ) {
				var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
				if ( clip ) outputAnimations.push( clip );
			}
			if ( geometry.morphTargets ) {
				var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
				outputAnimations = outputAnimations.concat( morphAnimationClips );
			}
			if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;
		}
		return function ( json, texturePath ) {
			if ( json.data !== undefined ) {
				json = json.data;
			}
			if ( json.scale !== undefined ) {
				json.scale = 1.0 / json.scale;
			} else {
				json.scale = 1.0;
			}
			var geometry = new Geometry();
			parseModel( json, geometry );
			parseSkin( json, geometry );
			parseMorphing( json, geometry );
			parseAnimations( json, geometry );
			geometry.computeFaceNormals();
			geometry.computeBoundingSphere();
			if ( json.materials === undefined || json.materials.length === 0 ) {
				return { geometry: geometry };
			} else {
				var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );
				return { geometry: geometry, materials: materials };
			}
		};
	} )()
} );
function ObjectLoader( manager ) {
	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	this.texturePath = '';
}
Object.assign( ObjectLoader.prototype, {
	load: function ( url, onLoad, onProgress, onError ) {
		if ( this.texturePath === '' ) {
			this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );
		}
		var scope = this;
		var loader = new FileLoader( scope.manager );
		loader.load( url, function ( text ) {
			var json = null;
			try {
				json = JSON.parse( text );
			} catch ( error ) {
				if ( onError !== undefined ) onError( error );
				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );
				return;
			}
			var metadata = json.metadata;
			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {
				console.error( 'THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.' );
				return;
			}
			scope.parse( json, onLoad );
		}, onProgress, onError );
	},
	setTexturePath: function ( value ) {
		this.texturePath = value;
	},
	setCrossOrigin: function ( value ) {
		this.crossOrigin = value;
	},
	parse: function ( json, onLoad ) {
		var geometries = this.parseGeometries( json.geometries );
		var images = this.parseImages( json.images, function () {
			if ( onLoad !== undefined ) onLoad( object );
		} );
		var textures = this.parseTextures( json.textures, images );
		var materials = this.parseMaterials( json.materials, textures );
		var object = this.parseObject( json.object, geometries, materials );
		if ( json.animations ) {
			object.animations = this.parseAnimations( json.animations );
		}
		if ( json.images === undefined || json.images.length === 0 ) {
			if ( onLoad !== undefined ) onLoad( object );
		}
		return object;
	},
	parseGeometries: function ( json ) {
		var geometries = {};
		if ( json !== undefined ) {
			var geometryLoader = new JSONLoader();
			var bufferGeometryLoader = new BufferGeometryLoader();
			for ( var i = 0, l = json.length; i < l; i ++ ) {
				var geometry;
				var data = json[ i ];
				switch ( data.type ) {
					case 'PlaneGeometry':
					case 'PlaneBufferGeometry':
						geometry = new Geometries[ data.type ](
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);
						break;
					case 'BoxGeometry':
					case 'BoxBufferGeometry':
					case 'CubeGeometry':
						geometry = new Geometries[ data.type ](
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);
						break;
					case 'CircleGeometry':
					case 'CircleBufferGeometry':
						geometry = new Geometries[ data.type ](
							data.radius,
							data.segments,
							data.thetaStart,
							data.thetaLength
						);
						break;
					case 'CylinderGeometry':
					case 'CylinderBufferGeometry':
						geometry = new Geometries[ data.type ](
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);
						break;
					case 'ConeGeometry':
					case 'ConeBufferGeometry':
						geometry = new Geometries[ data.type ](
							data.radius,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);
						break;
					case 'SphereGeometry':
					case 'SphereBufferGeometry':
						geometry = new Geometries[ data.type ](
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);
						break;
					case 'DodecahedronGeometry':
					case 'DodecahedronBufferGeometry':
					case 'IcosahedronGeometry':
					case 'IcosahedronBufferGeometry':
					case 'OctahedronGeometry':
					case 'OctahedronBufferGeometry':
					case 'TetrahedronGeometry':
					case 'TetrahedronBufferGeometry':
						geometry = new Geometries[ data.type ](
							data.radius,
							data.detail
						);
						break;
					case 'RingGeometry':
					case 'RingBufferGeometry':
						geometry = new Geometries[ data.type ](
							data.innerRadius,
							data.outerRadius,
							data.thetaSegments,
							data.phiSegments,
							data.thetaStart,
							data.thetaLength
						);
						break;
					case 'TorusGeometry':
					case 'TorusBufferGeometry':
						geometry = new Geometries[ data.type ](
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);
						break;
					case 'TorusKnotGeometry':
					case 'TorusKnotBufferGeometry':
						geometry = new Geometries[ data.type ](
							data.radius,
							data.tube,
							data.tubularSegments,
							data.radialSegments,
							data.p,
							data.q
						);
						break;
					case 'LatheGeometry':
					case 'LatheBufferGeometry':
						geometry = new Geometries[ data.type ](
							data.points,
							data.segments,
							data.phiStart,
							data.phiLength
						);
						break;
					case 'PolyhedronGeometry':
					case 'PolyhedronBufferGeometry':
						geometry = new Geometries[ data.type ](
							data.vertices,
							data.indices,
							data.radius,
							data.details
						);
						break;
					case 'BufferGeometry':
						geometry = bufferGeometryLoader.parse( data );
						break;
					case 'Geometry':
						geometry = geometryLoader.parse( data, this.texturePath ).geometry;
						break;
					default:
						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );
						continue;
				}
				geometry.uuid = data.uuid;
				if ( data.name !== undefined ) geometry.name = data.name;
				geometries[ data.uuid ] = geometry;
			}
		}
		return geometries;
	},
	parseMaterials: function ( json, textures ) {
		var materials = {};
		if ( json !== undefined ) {
			var loader = new MaterialLoader();
			loader.setTextures( textures );
			for ( var i = 0, l = json.length; i < l; i ++ ) {
				var data = json[ i ];
				if ( data.type === 'MultiMaterial' ) {
					var array = [];
					for ( var j = 0; j < data.materials.length; j ++ ) {
						array.push( loader.parse( data.materials[ j ] ) );
					}
					materials[ data.uuid ] = array;
				} else {
					materials[ data.uuid ] = loader.parse( data );
				}
			}
		}
		return materials;
	},
	parseAnimations: function ( json ) {
		var animations = [];
		for ( var i = 0; i < json.length; i ++ ) {
			var clip = AnimationClip.parse( json[ i ] );
			animations.push( clip );
		}
		return animations;
	},
	parseImages: function ( json, onLoad ) {
		var scope = this;
		var images = {};
		function loadImage( url ) {
			scope.manager.itemStart( url );
			return loader.load( url, function () {
				scope.manager.itemEnd( url );
			}, undefined, function () {
				scope.manager.itemEnd( url );
				scope.manager.itemError( url );
			} );
		}
		if ( json !== undefined && json.length > 0 ) {
			var manager = new LoadingManager( onLoad );
			var loader = new ImageLoader( manager );
			loader.setCrossOrigin( this.crossOrigin );
			for ( var i = 0, l = json.length; i < l; i ++ ) {
				var image = json[ i ];
				var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;
				images[ image.uuid ] = loadImage( path );
			}
		}
		return images;
	},
	parseTextures: function ( json, images ) {
		function parseConstant( value, type ) {
			if ( typeof value === 'number' ) return value;
			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );
			return type[ value ];
		}
		var textures = {};
		if ( json !== undefined ) {
			for ( var i = 0, l = json.length; i < l; i ++ ) {
				var data = json[ i ];
				if ( data.image === undefined ) {
					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );
				}
				if ( images[ data.image ] === undefined ) {
					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );
				}
				var texture = new Texture( images[ data.image ] );
				texture.needsUpdate = true;
				texture.uuid = data.uuid;
				if ( data.name !== undefined ) texture.name = data.name;
				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );
				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
				if ( data.center !== undefined ) texture.center.fromArray( data.center );
				if ( data.rotation !== undefined ) texture.rotation = data.rotation;
				if ( data.wrap !== undefined ) {
					texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
					texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );
				}
				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
				if ( data.flipY !== undefined ) texture.flipY = data.flipY;
				textures[ data.uuid ] = texture;
			}
		}
		return textures;
	},
	parseObject: function () {
		var matrix = new Matrix4();
		return function parseObject( data, geometries, materials ) {
			var object;
			function getGeometry( name ) {
				if ( geometries[ name ] === undefined ) {
					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );
				}
				return geometries[ name ];
			}
			function getMaterial( name ) {
				if ( name === undefined ) return undefined;
				if ( Array.isArray( name ) ) {
					var array = [];
					for ( var i = 0, l = name.length; i < l; i ++ ) {
						var uuid = name[ i ];
						if ( materials[ uuid ] === undefined ) {
							console.warn( 'THREE.ObjectLoader: Undefined material', uuid );
						}
						array.push( materials[ uuid ] );
					}
					return array;
				}
				if ( materials[ name ] === undefined ) {
					console.warn( 'THREE.ObjectLoader: Undefined material', name );
				}
				return materials[ name ];
			}
			switch ( data.type ) {
				case 'Scene':
					object = new Scene();
					if ( data.background !== undefined ) {
						if ( Number.isInteger( data.background ) ) {
							object.background = new Color( data.background );
						}
					}
					if ( data.fog !== undefined ) {
						if ( data.fog.type === 'Fog' ) {
							object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );
						} else if ( data.fog.type === 'FogExp2' ) {
							object.fog = new FogExp2( data.fog.color, data.fog.density );
						}
					}
					break;
				case 'PerspectiveCamera':
					object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );
					if ( data.focus !== undefined ) object.focus = data.focus;
					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );
					break;
				case 'OrthographicCamera':
					object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );
					break;
				case 'AmbientLight':
					object = new AmbientLight( data.color, data.intensity );
					break;
				case 'DirectionalLight':
					object = new DirectionalLight( data.color, data.intensity );
					break;
				case 'PointLight':
					object = new PointLight( data.color, data.intensity, data.distance, data.decay );
					break;
				case 'RectAreaLight':
					object = new RectAreaLight( data.color, data.intensity, data.width, data.height );
					break;
				case 'SpotLight':
					object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );
					break;
				case 'HemisphereLight':
					object = new HemisphereLight( data.color, data.groundColor, data.intensity );
					break;
				case 'SkinnedMesh':
					console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );
				case 'Mesh':
					var geometry = getGeometry( data.geometry );
					var material = getMaterial( data.material );
					if ( geometry.bones && geometry.bones.length > 0 ) {
						object = new SkinnedMesh( geometry, material );
					} else {
						object = new Mesh( geometry, material );
					}
					break;
				case 'LOD':
					object = new LOD();
					break;
				case 'Line':
					object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );
					break;
				case 'LineLoop':
					object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );
					break;
				case 'LineSegments':
					object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );
					break;
				case 'PointCloud':
				case 'Points':
					object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );
					break;
				case 'Sprite':
					object = new Sprite( getMaterial( data.material ) );
					break;
				case 'Group':
					object = new Group();
					break;
				default:
					object = new Object3D();
			}
			object.uuid = data.uuid;
			if ( data.name !== undefined ) object.name = data.name;
			if ( data.matrix !== undefined ) {
				matrix.fromArray( data.matrix );
				matrix.decompose( object.position, object.quaternion, object.scale );
			} else {
				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );
			}
			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;
			if ( data.shadow ) {
				if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
				if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
				if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
				if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );
			}
			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.userData !== undefined ) object.userData = data.userData;
			if ( data.children !== undefined ) {
				var children = data.children;
				for ( var i = 0; i < children.length; i ++ ) {
					object.add( this.parseObject( children[ i ], geometries, materials ) );
				}
			}
			if ( data.type === 'LOD' ) {
				var levels = data.levels;
				for ( var l = 0; l < levels.length; l ++ ) {
					var level = levels[ l ];
					var child = object.getObjectByProperty( 'uuid', level.object );
					if ( child !== undefined ) {
						object.addLevel( child, level.distance );
					}
				}
			}
			return object;
		};
	}()
} );
var TEXTURE_MAPPING = {
	UVMapping: UVMapping,
	CubeReflectionMapping: CubeReflectionMapping,
	CubeRefractionMapping: CubeRefractionMapping,
	EquirectangularReflectionMapping: EquirectangularReflectionMapping,
	EquirectangularRefractionMapping: EquirectangularRefractionMapping,
	SphericalReflectionMapping: SphericalReflectionMapping,
	CubeUVReflectionMapping: CubeUVReflectionMapping,
	CubeUVRefractionMapping: CubeUVRefractionMapping
};
var TEXTURE_WRAPPING = {
	RepeatWrapping: RepeatWrapping,
	ClampToEdgeWrapping: ClampToEdgeWrapping,
	MirroredRepeatWrapping: MirroredRepeatWrapping
};
var TEXTURE_FILTER = {
	NearestFilter: NearestFilter,
	NearestMipMapNearestFilter: NearestMipMapNearestFilter,
	NearestMipMapLinearFilter: NearestMipMapLinearFilter,
	LinearFilter: LinearFilter,
	LinearMipMapNearestFilter: LinearMipMapNearestFilter,
	LinearMipMapLinearFilter: LinearMipMapLinearFilter
};
function CatmullRom( t, p0, p1, p2, p3 ) {
	var v0 = ( p2 - p0 ) * 0.5;
	var v1 = ( p3 - p1 ) * 0.5;
	var t2 = t * t;
	var t3 = t * t2;
	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
}
function QuadraticBezierP0( t, p ) {
	var k = 1 - t;
	return k * k * p;
}
function QuadraticBezierP1( t, p ) {
	return 2 * ( 1 - t ) * t * p;
}
function QuadraticBezierP2( t, p ) {
	return t * t * p;
}
function QuadraticBezier( t, p0, p1, p2 ) {
	return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
		QuadraticBezierP2( t, p2 );
}
function CubicBezierP0( t, p ) {
	var k = 1 - t;
	return k * k * k * p;
}
function CubicBezierP1( t, p ) {
	var k = 1 - t;
	return 3 * k * k * t * p;
}
function CubicBezierP2( t, p ) {
	return 3 * ( 1 - t ) * t * t * p;
}
function CubicBezierP3( t, p ) {
	return t * t * t * p;
}
function CubicBezier( t, p0, p1, p2, p3 ) {
	return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
		CubicBezierP3( t, p3 );
}
function Curve() {
	this.type = 'Curve';
	this.arcLengthDivisions = 200;
}
Object.assign( Curve.prototype, {
	getPoint: function (                         ) {
		console.warn( 'THREE.Curve: .getPoint() not implemented.' );
		return null;
	},
	getPointAt: function ( u, optionalTarget ) {
		var t = this.getUtoTmapping( u );
		return this.getPoint( t, optionalTarget );
	},
	getPoints: function ( divisions ) {
		if ( divisions === undefined ) divisions = 5;
		var points = [];
		for ( var d = 0; d <= divisions; d ++ ) {
			points.push( this.getPoint( d / divisions ) );
		}
		return points;
	},
	getSpacedPoints: function ( divisions ) {
		if ( divisions === undefined ) divisions = 5;
		var points = [];
		for ( var d = 0; d <= divisions; d ++ ) {
			points.push( this.getPointAt( d / divisions ) );
		}
		return points;
	},
	getLength: function () {
		var lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];
	},
	getLengths: function ( divisions ) {
		if ( divisions === undefined ) divisions = this.arcLengthDivisions;
		if ( this.cacheArcLengths &&
			( this.cacheArcLengths.length === divisions + 1 ) &&
			! this.needsUpdate ) {
			return this.cacheArcLengths;
		}
		this.needsUpdate = false;
		var cache = [];
		var current, last = this.getPoint( 0 );
		var p, sum = 0;
		cache.push( 0 );
		for ( p = 1; p <= divisions; p ++ ) {
			current = this.getPoint( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;
		}
		this.cacheArcLengths = cache;
		return cache;
	},
	updateArcLengths: function () {
		this.needsUpdate = true;
		this.getLengths();
	},
	getUtoTmapping: function ( u, distance ) {
		var arcLengths = this.getLengths();
		var i = 0, il = arcLengths.length;
		var targetArcLength;
		if ( distance ) {
			targetArcLength = distance;
		} else {
			targetArcLength = u * arcLengths[ il - 1 ];
		}
		var low = 0, high = il - 1, comparison;
		while ( low <= high ) {
			i = Math.floor( low + ( high - low ) / 2 );
			comparison = arcLengths[ i ] - targetArcLength;
			if ( comparison < 0 ) {
				low = i + 1;
			} else if ( comparison > 0 ) {
				high = i - 1;
			} else {
				high = i;
				break;
			}
		}
		i = high;
		if ( arcLengths[ i ] === targetArcLength ) {
			return i / ( il - 1 );
		}
		var lengthBefore = arcLengths[ i ];
		var lengthAfter = arcLengths[ i + 1 ];
		var segmentLength = lengthAfter - lengthBefore;
		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;
		var t = ( i + segmentFraction ) / ( il - 1 );
		return t;
	},
	getTangent: function ( t ) {
		var delta = 0.0001;
		var t1 = t - delta;
		var t2 = t + delta;
		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;
		var pt1 = this.getPoint( t1 );
		var pt2 = this.getPoint( t2 );
		var vec = pt2.clone().sub( pt1 );
		return vec.normalize();
	},
	getTangentAt: function ( u ) {
		var t = this.getUtoTmapping( u );
		return this.getTangent( t );
	},
	computeFrenetFrames: function ( segments, closed ) {
		var normal = new Vector3();
		var tangents = [];
		var normals = [];
		var binormals = [];
		var vec = new Vector3();
		var mat = new Matrix4();
		var i, u, theta;
		for ( i = 0; i <= segments; i ++ ) {
			u = i / segments;
			tangents[ i ] = this.getTangentAt( u );
			tangents[ i ].normalize();
		}
		normals[ 0 ] = new Vector3();
		binormals[ 0 ] = new Vector3();
		var min = Number.MAX_VALUE;
		var tx = Math.abs( tangents[ 0 ].x );
		var ty = Math.abs( tangents[ 0 ].y );
		var tz = Math.abs( tangents[ 0 ].z );
		if ( tx <= min ) {
			min = tx;
			normal.set( 1, 0, 0 );
		}
		if ( ty <= min ) {
			min = ty;
			normal.set( 0, 1, 0 );
		}
		if ( tz <= min ) {
			normal.set( 0, 0, 1 );
		}
		vec.crossVectors( tangents[ 0 ], normal ).normalize();
		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
		for ( i = 1; i <= segments; i ++ ) {
			normals[ i ] = normals[ i - 1 ].clone();
			binormals[ i ] = binormals[ i - 1 ].clone();
			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );
			if ( vec.length() > Number.EPSILON ) {
				vec.normalize();
				theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) );
				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );
			}
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
		}
		if ( closed === true ) {
			theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
			theta /= segments;
			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {
				theta = - theta;
			}
			for ( i = 1; i <= segments; i ++ ) {
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
			}
		}
		return {
			tangents: tangents,
			normals: normals,
			binormals: binormals
		};
	},
	clone: function () {
		return new this.constructor().copy( this );
	},
	copy: function ( source ) {
		this.arcLengthDivisions = source.arcLengthDivisions;
		return this;
	}
} );
function LineCurve( v1, v2 ) {
	Curve.call( this );
	this.type = 'LineCurve';
	this.v1 = v1 || new Vector2();
	this.v2 = v2 || new Vector2();
}
LineCurve.prototype = Object.create( Curve.prototype );
LineCurve.prototype.constructor = LineCurve;
LineCurve.prototype.isLineCurve = true;
LineCurve.prototype.getPoint = function ( t, optionalTarget ) {
	var point = optionalTarget || new Vector2();
	if ( t === 1 ) {
		point.copy( this.v2 );
	} else {
		point.copy( this.v2 ).sub( this.v1 );
		point.multiplyScalar( t ).add( this.v1 );
	}
	return point;
};
LineCurve.prototype.getPointAt = function ( u, optionalTarget ) {
	return this.getPoint( u, optionalTarget );
};
LineCurve.prototype.getTangent = function (         ) {
	var tangent = this.v2.clone().sub( this.v1 );
	return tangent.normalize();
};
LineCurve.prototype.copy = function ( source ) {
	Curve.prototype.copy.call( this, source );
	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );
	return this;
};
function CurvePath() {
	Curve.call( this );
	this.type = 'CurvePath';
	this.curves = [];
	this.autoClose = false;
}
CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {
	constructor: CurvePath,
	add: function ( curve ) {
		this.curves.push( curve );
	},
	closePath: function () {
		var startPoint = this.curves[ 0 ].getPoint( 0 );
		var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );
		if ( ! startPoint.equals( endPoint ) ) {
			this.curves.push( new LineCurve( endPoint, startPoint ) );
		}
	},
	getPoint: function ( t ) {
		var d = t * this.getLength();
		var curveLengths = this.getCurveLengths();
		var i = 0;
		while ( i < curveLengths.length ) {
			if ( curveLengths[ i ] >= d ) {
				var diff = curveLengths[ i ] - d;
				var curve = this.curves[ i ];
				var segmentLength = curve.getLength();
				var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
				return curve.getPointAt( u );
			}
			i ++;
		}
		return null;
	},
	getLength: function () {
		var lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];
	},
	updateArcLengths: function () {
		this.needsUpdate = true;
		this.cacheLengths = null;
		this.getCurveLengths();
	},
	getCurveLengths: function () {
		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {
			return this.cacheLengths;
		}
		var lengths = [], sums = 0;
		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {
			sums += this.curves[ i ].getLength();
			lengths.push( sums );
		}
		this.cacheLengths = lengths;
		return lengths;
	},
	getSpacedPoints: function ( divisions ) {
		if ( divisions === undefined ) divisions = 40;
		var points = [];
		for ( var i = 0; i <= divisions; i ++ ) {
			points.push( this.getPoint( i / divisions ) );
		}
		if ( this.autoClose ) {
			points.push( points[ 0 ] );
		}
		return points;
	},
	getPoints: function ( divisions ) {
		divisions = divisions || 12;
		var points = [], last;
		for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {
			var curve = curves[ i ];
			var resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
				: ( curve && curve.isLineCurve ) ? 1
					: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
						: divisions;
			var pts = curve.getPoints( resolution );
			for ( var j = 0; j < pts.length; j ++ ) {
				var point = pts[ j ];
				if ( last && last.equals( point ) ) continue;
				points.push( point );
				last = point;
			}
		}
		if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {
			points.push( points[ 0 ] );
		}
		return points;
	},
	copy: function ( source ) {
		Curve.prototype.copy.call( this, source );
		this.curves = [];
		for ( var i = 0, l = source.curves.length; i < l; i ++ ) {
			var curve = source.curves[ i ];
			this.curves.push( curve.clone() );
		}
		this.autoClose = source.autoClose;
		return this;
	}
} );
function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	Curve.call( this );
	this.type = 'EllipseCurve';
	this.aX = aX || 0;
	this.aY = aY || 0;
	this.xRadius = xRadius || 1;
	this.yRadius = yRadius || 1;
	this.aStartAngle = aStartAngle ||Â 0;
	this.aEndAngle = aEndAngle || 2 * Math.PI;
	this.aClockwise = aClockwise || false;
	this.aRotation = aRotation || 0;
}
EllipseCurve.prototype = Object.create( Curve.prototype );
EllipseCurve.prototype.constructor = EllipseCurve;
EllipseCurve.prototype.isEllipseCurve = true;
EllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {
	var point = optionalTarget || new Vector2();
	var twoPi = Math.PI * 2;
	var deltaAngle = this.aEndAngle - this.aStartAngle;
	var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;
	while ( deltaAngle < 0 ) deltaAngle += twoPi;
	while ( deltaAngle > twoPi ) deltaAngle -= twoPi;
	if ( deltaAngle < Number.EPSILON ) {
		if ( samePoints ) {
			deltaAngle = 0;
		} else {
			deltaAngle = twoPi;
		}
	}
	if ( this.aClockwise === true && ! samePoints ) {
		if ( deltaAngle === twoPi ) {
			deltaAngle = - twoPi;
		} else {
			deltaAngle = deltaAngle - twoPi;
		}
	}
	var angle = this.aStartAngle + t * deltaAngle;
	var x = this.aX + this.xRadius * Math.cos( angle );
	var y = this.aY + this.yRadius * Math.sin( angle );
	if ( this.aRotation !== 0 ) {
		var cos = Math.cos( this.aRotation );
		var sin = Math.sin( this.aRotation );
		var tx = x - this.aX;
		var ty = y - this.aY;
		x = tx * cos - ty * sin + this.aX;
		y = tx * sin + ty * cos + this.aY;
	}
	return point.set( x, y );
};
EllipseCurve.prototype.copy = function ( source ) {
	Curve.prototype.copy.call( this, source );
	this.aX = source.aX;
	this.aY = source.aY;
	this.xRadius = source.xRadius;
	this.yRadius = source.yRadius;
	this.aStartAngle = source.aStartAngle;
	this.aEndAngle = source.aEndAngle;
	this.aClockwise = source.aClockwise;
	this.aRotation = source.aRotation;
	return this;
};
function SplineCurve( points                        ) {
	Curve.call( this );
	this.type = 'SplineCurve';
	this.points = points || [];
}
SplineCurve.prototype = Object.create( Curve.prototype );
SplineCurve.prototype.constructor = SplineCurve;
SplineCurve.prototype.isSplineCurve = true;
SplineCurve.prototype.getPoint = function ( t, optionalTarget ) {
	var point = optionalTarget || new Vector2();
	var points = this.points;
	var p = ( points.length - 1 ) * t;
	var intPoint = Math.floor( p );
	var weight = p - intPoint;
	var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
	var p1 = points[ intPoint ];
	var p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
	var p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];
	point.set(
		CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
		CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
	);
	return point;
};
SplineCurve.prototype.copy = function ( source ) {
	Curve.prototype.copy.call( this, source );
	this.points = [];
	for ( var i = 0, l = source.points.length; i < l; i ++ ) {
		var point = source.points[ i ];
		this.points.push( point.clone() );
	}
	return this;
};
function CubicBezierCurve( v0, v1, v2, v3 ) {
	Curve.call( this );
	this.type = 'CubicBezierCurve';
	this.v0 = v0 || new Vector2();
	this.v1 = v1 || new Vector2();
	this.v2 = v2 || new Vector2();
	this.v3 = v3 || new Vector2();
}
CubicBezierCurve.prototype = Object.create( Curve.prototype );
CubicBezierCurve.prototype.constructor = CubicBezierCurve;
CubicBezierCurve.prototype.isCubicBezierCurve = true;
CubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {
	var point = optionalTarget || new Vector2();
	var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
	point.set(
		CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
		CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
	);
	return point;
};
CubicBezierCurve.prototype.copy = function ( source ) {
	Curve.prototype.copy.call( this, source );
	this.v0.copy( source.v0 );
	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );
	this.v3.copy( source.v3 );
	return this;
};
function QuadraticBezierCurve( v0, v1, v2 ) {
	Curve.call( this );
	this.type = 'QuadraticBezierCurve';
	this.v0 = v0 || new Vector2();
	this.v1 = v1 || new Vector2();
	this.v2 = v2 || new Vector2();
}
QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
QuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {
	var point = optionalTarget || new Vector2();
	var v0 = this.v0, v1 = this.v1, v2 = this.v2;
	point.set(
		QuadraticBezier( t, v0.x, v1.x, v2.x ),
		QuadraticBezier( t, v0.y, v1.y, v2.y )
	);
	return point;
};
QuadraticBezierCurve.prototype.copy = function ( source ) {
	Curve.prototype.copy.call( this, source );
	this.v0.copy( source.v0 );
	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );
	return this;
};
var PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {
	setFromPoints: function ( points ) {
		this.moveTo( points[ 0 ].x, points[ 0 ].y );
		for ( var i = 1, l = points.length; i < l; i ++ ) {
			this.lineTo( points[ i ].x, points[ i ].y );
		}
	},
	moveTo: function ( x, y ) {
		this.currentPoint.set( x, y );
	},
	lineTo: function ( x, y ) {
		var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
		this.curves.push( curve );
		this.currentPoint.set( x, y );
	},
	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
		var curve = new QuadraticBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCPx, aCPy ),
			new Vector2( aX, aY )
		);
		this.curves.push( curve );
		this.currentPoint.set( aX, aY );
	},
	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
		var curve = new CubicBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCP1x, aCP1y ),
			new Vector2( aCP2x, aCP2y ),
			new Vector2( aX, aY )
		);
		this.curves.push( curve );
		this.currentPoint.set( aX, aY );
	},
	splineThru: function ( pts                     ) {
		var npts = [ this.currentPoint.clone() ].concat( pts );
		var curve = new SplineCurve( npts );
		this.curves.push( curve );
		this.currentPoint.copy( pts[ pts.length - 1 ] );
	},
	arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
		var x0 = this.currentPoint.x;
		var y0 = this.currentPoint.y;
		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );
	},
	absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	},
	ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
		var x0 = this.currentPoint.x;
		var y0 = this.currentPoint.y;
		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
	},
	absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
		var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
		if ( this.curves.length > 0 ) {
			var firstPoint = curve.getPoint( 0 );
			if ( ! firstPoint.equals( this.currentPoint ) ) {
				this.lineTo( firstPoint.x, firstPoint.y );
			}
		}
		this.curves.push( curve );
		var lastPoint = curve.getPoint( 1 );
		this.currentPoint.copy( lastPoint );
	},
	copy: function ( source ) {
		CurvePath.prototype.copy.call( this, source );
		this.currentPoint.copy( source.currentPoint );
		return this;
	}
} );
function Path( points ) {
	CurvePath.call( this );
	this.type = 'Path';
	this.currentPoint = new Vector2();
	if ( points ) {
		this.setFromPoints( points );
	}
}
Path.prototype = PathPrototype;
PathPrototype.constructor = Path;
function Shape( points ) {
	Path.call( this, points );
	this.type = 'Shape';
	this.holes = [];
}
Shape.prototype = Object.assign( Object.create( PathPrototype ), {
	constructor: Shape,
	getPointsHoles: function ( divisions ) {
		var holesPts = [];
		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {
			holesPts[ i ] = this.holes[ i ].getPoints( divisions );
		}
		return holesPts;
	},
	extractPoints: function ( divisions ) {
		return {
			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )
		};
	},
	copy: function ( source ) {
		Path.prototype.copy.call( this, source );
		this.holes = [];
		for ( var i = 0, l = source.holes.length; i < l; i ++ ) {
			var hole = source.holes[ i ];
			this.holes.push( hole.clone() );
		}
		return this;
	}
} );
function ShapePath() {
	this.type = 'ShapePath';
	this.subPaths = [];
	this.currentPath = null;
}
Object.assign( ShapePath.prototype, {
	moveTo: function ( x, y ) {
		this.currentPath = new Path();
		this.subPaths.push( this.currentPath );
		this.currentPath.moveTo( x, y );
	},
	lineTo: function ( x, y ) {
		this.currentPath.lineTo( x, y );
	},
	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );
	},
	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );
	},
	splineThru: function ( pts ) {
		this.currentPath.splineThru( pts );
	},
	toShapes: function ( isCCW, noHoles ) {
		function toShapesNoHoles( inSubpaths ) {
			var shapes = [];
			for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {
				var tmpPath = inSubpaths[ i ];
				var tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push( tmpShape );
			}
			return shapes;
		}
		function isPointInsidePolygon( inPt, inPolygon ) {
			var polyLen = inPolygon.length;
			var inside = false;
			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
				var edgeLowPt = inPolygon[ p ];
				var edgeHighPt = inPolygon[ q ];
				var edgeDx = edgeHighPt.x - edgeLowPt.x;
				var edgeDy = edgeHighPt.y - edgeLowPt.y;
				if ( Math.abs( edgeDy ) > Number.EPSILON ) {
					if ( edgeDy < 0 ) {
						edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
					}
					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;
					if ( inPt.y === edgeLowPt.y ) {
						if ( inPt.x === edgeLowPt.x )		return	true;
					} else {
						var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;
					}
				} else {
					if ( inPt.y !== edgeLowPt.y ) 		continue;
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;
				}
			}
			return	inside;
		}
		var isClockWise = ShapeUtils.isClockWise;
		var subPaths = this.subPaths;
		if ( subPaths.length === 0 ) return [];
		if ( noHoles === true )	return	toShapesNoHoles( subPaths );
		var solid, tmpPath, tmpShape, shapes = [];
		if ( subPaths.length === 1 ) {
			tmpPath = subPaths[ 0 ];
			tmpShape = new Shape();
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;
		}
		var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;
		var betterShapeHoles = [];
		var newShapes = [];
		var newShapeHoles = [];
		var mainIdx = 0;
		var tmpPoints;
		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];
		for ( var i = 0, l = subPaths.length; i < l; i ++ ) {
			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;
			if ( solid ) {
				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;
				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.curves = tmpPath.curves;
				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];
			} else {
				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );
			}
		}
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );
		if ( newShapes.length > 1 ) {
			var ambiguous = false;
			var toChange = [];
			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
				betterShapeHoles[ sIdx ] = [];
			}
			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
				var sho = newShapeHoles[ sIdx ];
				for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
					var ho = sho[ hIdx ];
					var hole_unassigned = true;
					for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {
							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {
								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );
							} else {
								ambiguous = true;
							}
						}
					}
					if ( hole_unassigned ) {
						betterShapeHoles[ sIdx ].push( ho );
					}
				}
			}
			if ( toChange.length > 0 ) {
				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;
			}
		}
		var tmpHoles;
		for ( var i = 0, il = newShapes.length; i < il; i ++ ) {
			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];
			for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
				tmpShape.holes.push( tmpHoles[ j ].h );
			}
		}
		return shapes;
	}
} );
function Font( data ) {
	this.type = 'Font';
	this.data = data;
}
Object.assign( Font.prototype, {
	isFont: true,
	generateShapes: function ( text, size, divisions ) {
		function createPaths( text ) {
			var chars = String( text ).split( '' );
			var scale = size / data.resolution;
			var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;
			var offsetX = 0, offsetY = 0;
			var paths = [];
			for ( var i = 0; i < chars.length; i ++ ) {
				var char = chars[ i ];
				if ( char === '\n' ) {
					offsetX = 0;
					offsetY -= line_height;
				} else {
					var ret = createPath( char, scale, offsetX, offsetY );
					offsetX += ret.offsetX;
					paths.push( ret.path );
				}
			}
			return paths;
		}
		function createPath( c, scale, offsetX, offsetY ) {
			var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];
			if ( ! glyph ) return;
			var path = new ShapePath();
			var pts = [];
			var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;
			if ( glyph.o ) {
				var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
				for ( var i = 0, l = outline.length; i < l; ) {
					var action = outline[ i ++ ];
					switch ( action ) {
						case 'm':
							x = outline[ i ++ ] * scale + offsetX;
							y = outline[ i ++ ] * scale + offsetY;
							path.moveTo( x, y );
							break;
						case 'l':
							x = outline[ i ++ ] * scale + offsetX;
							y = outline[ i ++ ] * scale + offsetY;
							path.lineTo( x, y );
							break;
						case 'q':
							cpx = outline[ i ++ ] * scale + offsetX;
							cpy = outline[ i ++ ] * scale + offsetY;
							cpx1 = outline[ i ++ ] * scale + offsetX;
							cpy1 = outline[ i ++ ] * scale + offsetY;
							path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );
							laste = pts[ pts.length - 1 ];
							if ( laste ) {
								cpx0 = laste.x;
								cpy0 = laste.y;
								
							}
							break;
						case 'b':
							cpx = outline[ i ++ ] * scale + offsetX;
							cpy = outline[ i ++ ] * scale + offsetY;
							cpx1 = outline[ i ++ ] * scale + offsetX;
							cpy1 = outline[ i ++ ] * scale + offsetY;
							cpx2 = outline[ i ++ ] * scale + offsetX;
							cpy2 = outline[ i ++ ] * scale + offsetY;
							path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );
							laste = pts[ pts.length - 1 ];
							if ( laste ) {
								cpx0 = laste.x;
								cpy0 = laste.y;
								
							}
							break;
					}
				}
			}
			return { offsetX: glyph.ha * scale, path: path };
		}
		if ( size === undefined ) size = 100;
		if ( divisions === undefined ) divisions = 4;
		var data = this.data;
		var paths = createPaths( text );
		var shapes = [];
		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {
			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );
		}
		return shapes;
	}
} );
function FontLoader( manager ) {
	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
}
Object.assign( FontLoader.prototype, {
	load: function ( url, onLoad, onProgress, onError ) {
		var scope = this;
		var loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.load( url, function ( text ) {
			var json;
			try {
				json = JSON.parse( text );
			} catch ( e ) {
				console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
				json = JSON.parse( text.substring( 65, text.length - 2 ) );
			}
			var font = scope.parse( json );
			if ( onLoad ) onLoad( font );
		}, onProgress, onError );
	},
	parse: function ( json ) {
		return new Font( json );
	},
	setPath: function ( value ) {
		this.path = value;
		return this;
	}
} );
var context;
var AudioContext = {
	getContext: function () {
		if ( context === undefined ) {
			context = new ( window.AudioContext || window.webkitAudioContext )();
		}
		return context;
	},
	setContext: function ( value ) {
		context = value;
	}
};
function AudioLoader( manager ) {
	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
}
Object.assign( AudioLoader.prototype, {
	load: function ( url, onLoad, onProgress, onError ) {
		var loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.load( url, function ( buffer ) {
			var context = AudioContext.getContext();
			context.decodeAudioData( buffer, function ( audioBuffer ) {
				onLoad( audioBuffer );
			} );
		}, onProgress, onError );
	}
} );
function StereoCamera() {
	this.type = 'StereoCamera';
	this.aspect = 1;
	this.eyeSep = 0.064;
	this.cameraL = new PerspectiveCamera();
	this.cameraL.layers.enable( 1 );
	this.cameraL.matrixAutoUpdate = false;
	this.cameraR = new PerspectiveCamera();
	this.cameraR.layers.enable( 2 );
	this.cameraR.matrixAutoUpdate = false;
}
Object.assign( StereoCamera.prototype, {
	update: ( function () {
		var instance, focus, fov, aspect, near, far, zoom, eyeSep;
		var eyeRight = new Matrix4();
		var eyeLeft = new Matrix4();
		return function update( camera ) {
			var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
												aspect !== camera.aspect * this.aspect || near !== camera.near ||
												far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;
			if ( needsUpdate ) {
				instance = this;
				focus = camera.focus;
				fov = camera.fov;
				aspect = camera.aspect * this.aspect;
				near = camera.near;
				far = camera.far;
				zoom = camera.zoom;
				var projectionMatrix = camera.projectionMatrix.clone();
				eyeSep = this.eyeSep / 2;
				var eyeSepOnProjection = eyeSep * near / focus;
				var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
				var xmin, xmax;
				eyeLeft.elements[ 12 ] = - eyeSep;
				eyeRight.elements[ 12 ] = eyeSep;
				xmin = - ymax * aspect + eyeSepOnProjection;
				xmax = ymax * aspect + eyeSepOnProjection;
				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
				this.cameraL.projectionMatrix.copy( projectionMatrix );
				xmin = - ymax * aspect - eyeSepOnProjection;
				xmax = ymax * aspect - eyeSepOnProjection;
				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
				this.cameraR.projectionMatrix.copy( projectionMatrix );
			}
			this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
			this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );
		};
	} )()
} );
function CubeCamera( near, far, cubeResolution ) {
	Object3D.call( this );
	this.type = 'CubeCamera';
	var fov = 90, aspect = 1;
	var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
	cameraPX.up.set( 0, - 1, 0 );
	cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
	this.add( cameraPX );
	var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
	cameraNX.up.set( 0, - 1, 0 );
	cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
	this.add( cameraNX );
	var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
	this.add( cameraPY );
	var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
	cameraNY.up.set( 0, 0, - 1 );
	cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
	this.add( cameraNY );
	var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.up.set( 0, - 1, 0 );
	cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );
	var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.up.set( 0, - 1, 0 );
	cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
	this.add( cameraNZ );
	var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };
	this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
	this.renderTarget.texture.name = "CubeCamera";
	this.update = function ( renderer, scene ) {
		if ( this.parent === null ) this.updateMatrixWorld();
		var renderTarget = this.renderTarget;
		var generateMipmaps = renderTarget.texture.generateMipmaps;
		renderTarget.texture.generateMipmaps = false;
		renderTarget.activeCubeFace = 0;
		renderer.render( scene, cameraPX, renderTarget );
		renderTarget.activeCubeFace = 1;
		renderer.render( scene, cameraNX, renderTarget );
		renderTarget.activeCubeFace = 2;
		renderer.render( scene, cameraPY, renderTarget );
		renderTarget.activeCubeFace = 3;
		renderer.render( scene, cameraNY, renderTarget );
		renderTarget.activeCubeFace = 4;
		renderer.render( scene, cameraPZ, renderTarget );
		renderTarget.texture.generateMipmaps = generateMipmaps;
		renderTarget.activeCubeFace = 5;
		renderer.render( scene, cameraNZ, renderTarget );
		renderer.setRenderTarget( null );
	};
	this.clear = function ( renderer, color, depth, stencil ) {
		var renderTarget = this.renderTarget;
		for ( var i = 0; i < 6; i ++ ) {
			renderTarget.activeCubeFace = i;
			renderer.setRenderTarget( renderTarget );
			renderer.clear( color, depth, stencil );
		}
		renderer.setRenderTarget( null );
	};
}
CubeCamera.prototype = Object.create( Object3D.prototype );
CubeCamera.prototype.constructor = CubeCamera;
function AudioListener() {
	Object3D.call( this );
	this.type = 'AudioListener';
	this.context = AudioContext.getContext();
	this.gain = this.context.createGain();
	this.gain.connect( this.context.destination );
	this.filter = null;
}
AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {
	constructor: AudioListener,
	getInput: function () {
		return this.gain;
	},
	removeFilter: function ( ) {
		if ( this.filter !== null ) {
			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
			this.gain.connect( this.context.destination );
			this.filter = null;
		}
	},
	getFilter: function () {
		return this.filter;
	},
	setFilter: function ( value ) {
		if ( this.filter !== null ) {
			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
		} else {
			this.gain.disconnect( this.context.destination );
		}
		this.filter = value;
		this.gain.connect( this.filter );
		this.filter.connect( this.context.destination );
	},
	getMasterVolume: function () {
		return this.gain.gain.value;
	},
	setMasterVolume: function ( value ) {
		this.gain.gain.value = value;
	},
	updateMatrixWorld: ( function () {
		var position = new Vector3();
		var quaternion = new Quaternion();
		var scale = new Vector3();
		var orientation = new Vector3();
		return function updateMatrixWorld( force ) {
			Object3D.prototype.updateMatrixWorld.call( this, force );
			var listener = this.context.listener;
			var up = this.up;
			this.matrixWorld.decompose( position, quaternion, scale );
			orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );
			if ( listener.positionX ) {
				listener.positionX.setValueAtTime( position.x, this.context.currentTime );
				listener.positionY.setValueAtTime( position.y, this.context.currentTime );
				listener.positionZ.setValueAtTime( position.z, this.context.currentTime );
				listener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );
				listener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );
				listener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );
				listener.upX.setValueAtTime( up.x, this.context.currentTime );
				listener.upY.setValueAtTime( up.y, this.context.currentTime );
				listener.upZ.setValueAtTime( up.z, this.context.currentTime );
			} else {
				listener.setPosition( position.x, position.y, position.z );
				listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );
			}
		};
	} )()
} );
function Audio( listener ) {
	Object3D.call( this );
	this.type = 'Audio';
	this.context = listener.context;
	this.gain = this.context.createGain();
	this.gain.connect( listener.getInput() );
	this.autoplay = false;
	this.buffer = null;
	this.loop = false;
	this.startTime = 0;
	this.offset = 0;
	this.playbackRate = 1;
	this.isPlaying = false;
	this.hasPlaybackControl = true;
	this.sourceType = 'empty';
	this.filters = [];
}
Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {
	constructor: Audio,
	getOutput: function () {
		return this.gain;
	},
	setNodeSource: function ( audioNode ) {
		this.hasPlaybackControl = false;
		this.sourceType = 'audioNode';
		this.source = audioNode;
		this.connect();
		return this;
	},
	setBuffer: function ( audioBuffer ) {
		this.buffer = audioBuffer;
		this.sourceType = 'buffer';
		if ( this.autoplay ) this.play();
		return this;
	},
	play: function () {
		if ( this.isPlaying === true ) {
			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;
		}
		if ( this.hasPlaybackControl === false ) {
			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;
		}
		var source = this.context.createBufferSource();
		source.buffer = this.buffer;
		source.loop = this.loop;
		source.onended = this.onEnded.bind( this );
		source.playbackRate.setValueAtTime( this.playbackRate, this.startTime );
		this.startTime = this.context.currentTime;
		source.start( this.startTime, this.offset );
		this.isPlaying = true;
		this.source = source;
		return this.connect();
	},
	pause: function () {
		if ( this.hasPlaybackControl === false ) {
			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;
		}
		if ( this.isPlaying === true ) {
			this.source.stop();
			this.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;
			this.isPlaying = false;
		}
		return this;
	},
	stop: function () {
		if ( this.hasPlaybackControl === false ) {
			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;
		}
		this.source.stop();
		this.offset = 0;
		this.isPlaying = false;
		return this;
	},
	connect: function () {
		if ( this.filters.length > 0 ) {
			this.source.connect( this.filters[ 0 ] );
			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {
				this.filters[ i - 1 ].connect( this.filters[ i ] );
			}
			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );
		} else {
			this.source.connect( this.getOutput() );
		}
		return this;
	},
	disconnect: function () {
		if ( this.filters.length > 0 ) {
			this.source.disconnect( this.filters[ 0 ] );
			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {
				this.filters[ i - 1 ].disconnect( this.filters[ i ] );
			}
			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );
		} else {
			this.source.disconnect( this.getOutput() );
		}
		return this;
	},
	getFilters: function () {
		return this.filters;
	},
	setFilters: function ( value ) {
		if ( ! value ) value = [];
		if ( this.isPlaying === true ) {
			this.disconnect();
			this.filters = value;
			this.connect();
		} else {
			this.filters = value;
		}
		return this;
	},
	getFilter: function () {
		return this.getFilters()[ 0 ];
	},
	setFilter: function ( filter ) {
		return this.setFilters( filter ? [ filter ] : [] );
	},
	setPlaybackRate: function ( value ) {
		if ( this.hasPlaybackControl === false ) {
			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;
		}
		this.playbackRate = value;
		if ( this.isPlaying === true ) {
			this.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );
		}
		return this;
	},
	getPlaybackRate: function () {
		return this.playbackRate;
	},
	onEnded: function () {
		this.isPlaying = false;
	},
	getLoop: function () {
		if ( this.hasPlaybackControl === false ) {
			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return false;
		}
		return this.loop;
	},
	setLoop: function ( value ) {
		if ( this.hasPlaybackControl === false ) {
			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;
		}
		this.loop = value;
		if ( this.isPlaying === true ) {
			this.source.loop = this.loop;
		}
		return this;
	},
	getVolume: function () {
		return this.gain.gain.value;
	},
	setVolume: function ( value ) {
		this.gain.gain.value = value;
		return this;
	}
} );
function PositionalAudio( listener ) {
	Audio.call( this, listener );
	this.panner = this.context.createPanner();
	this.panner.connect( this.gain );
}
PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {
	constructor: PositionalAudio,
	getOutput: function () {
		return this.panner;
	},
	getRefDistance: function () {
		return this.panner.refDistance;
	},
	setRefDistance: function ( value ) {
		this.panner.refDistance = value;
	},
	getRolloffFactor: function () {
		return this.panner.rolloffFactor;
	},
	setRolloffFactor: function ( value ) {
		this.panner.rolloffFactor = value;
	},
	getDistanceModel: function () {
		return this.panner.distanceModel;
	},
	setDistanceModel: function ( value ) {
		this.panner.distanceModel = value;
	},
	getMaxDistance: function () {
		return this.panner.maxDistance;
	},
	setMaxDistance: function ( value ) {
		this.panner.maxDistance = value;
	},
	updateMatrixWorld: ( function () {
		var position = new Vector3();
		return function updateMatrixWorld( force ) {
			Object3D.prototype.updateMatrixWorld.call( this, force );
			position.setFromMatrixPosition( this.matrixWorld );
			this.panner.setPosition( position.x, position.y, position.z );
		};
	} )()
} );
function AudioAnalyser( audio, fftSize ) {
	this.analyser = audio.context.createAnalyser();
	this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
	this.data = new Uint8Array( this.analyser.frequencyBinCount );
	audio.getOutput().connect( this.analyser );
}
Object.assign( AudioAnalyser.prototype, {
	getFrequencyData: function () {
		this.analyser.getByteFrequencyData( this.data );
		return this.data;
	},
	getAverageFrequency: function () {
		var value = 0, data = this.getFrequencyData();
		for ( var i = 0; i < data.length; i ++ ) {
			value += data[ i ];
		}
		return value / data.length;
	}
} );
function PropertyMixer( binding, typeName, valueSize ) {
	this.binding = binding;
	this.valueSize = valueSize;
	var bufferType = Float64Array,
		mixFunction;
	switch ( typeName ) {
		case 'quaternion':
			mixFunction = this._slerp;
			break;
		case 'string':
		case 'bool':
			bufferType = Array;
			mixFunction = this._select;
			break;
		default:
			mixFunction = this._lerp;
	}
	this.buffer = new bufferType( valueSize * 4 );
	this._mixBufferRegion = mixFunction;
	this.cumulativeWeight = 0;
	this.useCount = 0;
	this.referenceCount = 0;
}
Object.assign( PropertyMixer.prototype, {
	accumulate: function ( accuIndex, weight ) {
		var buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride,
			currentWeight = this.cumulativeWeight;
		if ( currentWeight === 0 ) {
			for ( var i = 0; i !== stride; ++ i ) {
				buffer[ offset + i ] = buffer[ i ];
			}
			currentWeight = weight;
		} else {
			currentWeight += weight;
			var mix = weight / currentWeight;
			this._mixBufferRegion( buffer, offset, 0, mix, stride );
		}
		this.cumulativeWeight = currentWeight;
	},
	apply: function ( accuIndex ) {
		var stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,
			weight = this.cumulativeWeight,
			binding = this.binding;
		this.cumulativeWeight = 0;
		if ( weight < 1 ) {
			var originalValueOffset = stride * 3;
			this._mixBufferRegion(
				buffer, offset, originalValueOffset, 1 - weight, stride );
		}
		for ( var i = stride, e = stride + stride; i !== e; ++ i ) {
			if ( buffer[ i ] !== buffer[ i + stride ] ) {
				binding.setValue( buffer, offset );
				break;
			}
		}
	},
	saveOriginalState: function () {
		var binding = this.binding;
		var buffer = this.buffer,
			stride = this.valueSize,
			originalValueOffset = stride * 3;
		binding.getValue( buffer, originalValueOffset );
		for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {
			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];
		}
		this.cumulativeWeight = 0;
	},
	restoreOriginalState: function () {
		var originalValueOffset = this.valueSize * 3;
		this.binding.setValue( this.buffer, originalValueOffset );
	},
	_select: function ( buffer, dstOffset, srcOffset, t, stride ) {
		if ( t >= 0.5 ) {
			for ( var i = 0; i !== stride; ++ i ) {
				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];
			}
		}
	},
	_slerp: function ( buffer, dstOffset, srcOffset, t ) {
		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );
	},
	_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {
		var s = 1 - t;
		for ( var i = 0; i !== stride; ++ i ) {
			var j = dstOffset + i;
			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;
		}
	}
} );
function Composite( targetGroup, path, optionalParsedPath ) {
	var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );
	this._targetGroup = targetGroup;
	this._bindings = targetGroup.subscribe_( path, parsedPath );
}
Object.assign( Composite.prototype, {
	getValue: function ( array, offset ) {
		this.bind();
		var firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];
		if ( binding !== undefined ) binding.getValue( array, offset );
	},
	setValue: function ( array, offset ) {
		var bindings = this._bindings;
		for ( var i = this._targetGroup.nCachedObjects_,
				  n = bindings.length; i !== n; ++ i ) {
			bindings[ i ].setValue( array, offset );
		}
	},
	bind: function () {
		var bindings = this._bindings;
		for ( var i = this._targetGroup.nCachedObjects_,
				  n = bindings.length; i !== n; ++ i ) {
			bindings[ i ].bind();
		}
	},
	unbind: function () {
		var bindings = this._bindings;
		for ( var i = this._targetGroup.nCachedObjects_,
				  n = bindings.length; i !== n; ++ i ) {
			bindings[ i ].unbind();
		}
	}
} );
function PropertyBinding( rootNode, path, parsedPath ) {
	this.path = path;
	this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );
	this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;
	this.rootNode = rootNode;
}
Object.assign( PropertyBinding, {
	Composite: Composite,
	create: function ( root, path, parsedPath ) {
		if ( ! ( root && root.isAnimationObjectGroup ) ) {
			return new PropertyBinding( root, path, parsedPath );
		} else {
			return new PropertyBinding.Composite( root, path, parsedPath );
		}
	},
	sanitizeNodeName: function ( name ) {
		return name.replace( /\s/g, '_' ).replace( /[^\w-]/g, '' );
	},
	parseTrackName: function () {
		var directoryRe = /((?:[\w-]+[\/:])*)/;
		var nodeRe = /([\w-\.]+)?/;
		var objectRe = /(?:\.([\w-]+)(?:\[(.+)\])?)?/;
		var propertyRe = /\.([\w-]+)(?:\[(.+)\])?/;
		var trackRe = new RegExp( ''
			+ '^'
			+ directoryRe.source
			+ nodeRe.source
			+ objectRe.source
			+ propertyRe.source
			+ '$'
		);
		var supportedObjectNames = [ 'material', 'materials', 'bones' ];
		return function ( trackName ) {
			var matches = trackRe.exec( trackName );
			if ( ! matches ) {
				throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );
			}
			var results = {
				nodeName: matches[ 2 ],
				objectName: matches[ 3 ],
				objectIndex: matches[ 4 ],
				propertyName: matches[ 5 ],
				propertyIndex: matches[ 6 ]
			};
			var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );
			if ( lastDot !== undefined && lastDot !== - 1 ) {
				var objectName = results.nodeName.substring( lastDot + 1 );
				if ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {
					results.nodeName = results.nodeName.substring( 0, lastDot );
					results.objectName = objectName;
				}
			}
			if ( results.propertyName === null || results.propertyName.length === 0 ) {
				throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );
			}
			return results;
		};
	}(),
	findNode: function ( root, nodeName ) {
		if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {
			return root;
		}
		if ( root.skeleton ) {
			var searchSkeleton = function ( skeleton ) {
				for ( var i = 0; i < skeleton.bones.length; i ++ ) {
					var bone = skeleton.bones[ i ];
					if ( bone.name === nodeName ) {
						return bone;
					}
				}
				return null;
			};
			var bone = searchSkeleton( root.skeleton );
			if ( bone ) {
				return bone;
			}
		}
		if ( root.children ) {
			var searchNodeSubtree = function ( children ) {
				for ( var i = 0; i < children.length; i ++ ) {
					var childNode = children[ i ];
					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {
						return childNode;
					}
					var result = searchNodeSubtree( childNode.children );
					if ( result ) return result;
				}
				return null;
			};
			var subTreeNode = searchNodeSubtree( root.children );
			if ( subTreeNode ) {
				return subTreeNode;
			}
		}
		return null;
	}
} );
Object.assign( PropertyBinding.prototype, {
	_getValue_unavailable: function () {},
	_setValue_unavailable: function () {},
	BindingType: {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	},
	Versioning: {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	},
	GetterByBindingType: [
		function getValue_direct( buffer, offset ) {
			buffer[ offset ] = this.node[ this.propertyName ];
		},
		function getValue_array( buffer, offset ) {
			var source = this.resolvedProperty;
			for ( var i = 0, n = source.length; i !== n; ++ i ) {
				buffer[ offset ++ ] = source[ i ];
			}
		},
		function getValue_arrayElement( buffer, offset ) {
			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];
		},
		function getValue_toArray( buffer, offset ) {
			this.resolvedProperty.toArray( buffer, offset );
		}
	],
	SetterByBindingTypeAndVersioning: [
		[
			function setValue_direct( buffer, offset ) {
				this.targetObject[ this.propertyName ] = buffer[ offset ];
			},
			function setValue_direct_setNeedsUpdate( buffer, offset ) {
				this.targetObject[ this.propertyName ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;
			},
			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {
				this.targetObject[ this.propertyName ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;
			}
		], [
			function setValue_array( buffer, offset ) {
				var dest = this.resolvedProperty;
				for ( var i = 0, n = dest.length; i !== n; ++ i ) {
					dest[ i ] = buffer[ offset ++ ];
				}
			},
			function setValue_array_setNeedsUpdate( buffer, offset ) {
				var dest = this.resolvedProperty;
				for ( var i = 0, n = dest.length; i !== n; ++ i ) {
					dest[ i ] = buffer[ offset ++ ];
				}
				this.targetObject.needsUpdate = true;
			},
			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {
				var dest = this.resolvedProperty;
				for ( var i = 0, n = dest.length; i !== n; ++ i ) {
					dest[ i ] = buffer[ offset ++ ];
				}
				this.targetObject.matrixWorldNeedsUpdate = true;
			}
		], [
			function setValue_arrayElement( buffer, offset ) {
				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
			},
			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {
				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;
			},
			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {
				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;
			}
		], [
			function setValue_fromArray( buffer, offset ) {
				this.resolvedProperty.fromArray( buffer, offset );
			},
			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {
				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.needsUpdate = true;
			},
			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {
				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.matrixWorldNeedsUpdate = true;
			}
		]
	],
	getValue: function getValue_unbound( targetArray, offset ) {
		this.bind();
		this.getValue( targetArray, offset );
	},
	setValue: function getValue_unbound( sourceArray, offset ) {
		this.bind();
		this.setValue( sourceArray, offset );
	},
	bind: function () {
		var targetObject = this.node,
			parsedPath = this.parsedPath,
			objectName = parsedPath.objectName,
			propertyName = parsedPath.propertyName,
			propertyIndex = parsedPath.propertyIndex;
		if ( ! targetObject ) {
			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;
			this.node = targetObject;
		}
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;
		if ( ! targetObject ) {
			console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
			return;
		}
		if ( objectName ) {
			var objectIndex = parsedPath.objectIndex;
			switch ( objectName ) {
				case 'materials':
					if ( ! targetObject.material ) {
						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;
					}
					if ( ! targetObject.material.materials ) {
						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
						return;
					}
					targetObject = targetObject.material.materials;
					break;
				case 'bones':
					if ( ! targetObject.skeleton ) {
						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
						return;
					}
					targetObject = targetObject.skeleton.bones;
					for ( var i = 0; i < targetObject.length; i ++ ) {
						if ( targetObject[ i ].name === objectIndex ) {
							objectIndex = i;
							break;
						}
					}
					break;
				default:
					if ( targetObject[ objectName ] === undefined ) {
						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
						return;
					}
					targetObject = targetObject[ objectName ];
			}
			if ( objectIndex !== undefined ) {
				if ( targetObject[ objectIndex ] === undefined ) {
					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
					return;
				}
				targetObject = targetObject[ objectIndex ];
			}
		}
		var nodeProperty = targetObject[ propertyName ];
		if ( nodeProperty === undefined ) {
			var nodeName = parsedPath.nodeName;
			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
				'.' + propertyName + ' but it wasn\'t found.', targetObject );
			return;
		}
		var versioning = this.Versioning.None;
		if ( targetObject.needsUpdate !== undefined ) {
			versioning = this.Versioning.NeedsUpdate;
			this.targetObject = targetObject;
		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) {
			versioning = this.Versioning.MatrixWorldNeedsUpdate;
			this.targetObject = targetObject;
		}
		var bindingType = this.BindingType.Direct;
		if ( propertyIndex !== undefined ) {
			if ( propertyName === "morphTargetInfluences" ) {
				if ( ! targetObject.geometry ) {
					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
					return;
				}
				if ( targetObject.geometry.isBufferGeometry ) {
					if ( ! targetObject.geometry.morphAttributes ) {
						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
						return;
					}
					for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {
						if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {
							propertyIndex = i;
							break;
						}
					}
				} else {
					if ( ! targetObject.geometry.morphTargets ) {
						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );
						return;
					}
					for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {
						if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {
							propertyIndex = i;
							break;
						}
					}
				}
			}
			bindingType = this.BindingType.ArrayElement;
			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;
		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
			bindingType = this.BindingType.HasFromToArray;
			this.resolvedProperty = nodeProperty;
		} else if ( Array.isArray( nodeProperty ) ) {
			bindingType = this.BindingType.EntireArray;
			this.resolvedProperty = nodeProperty;
		} else {
			this.propertyName = propertyName;
		}
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];
	},
	unbind: function () {
		this.node = null;
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;
	}
} );
Object.assign( PropertyBinding.prototype, {
	_getValue_unbound: PropertyBinding.prototype.getValue,
	_setValue_unbound: PropertyBinding.prototype.setValue,
} );
function AnimationObjectGroup() {
	this.uuid = _Math.generateUUID();
	this._objects = Array.prototype.slice.call( arguments );
	this.nCachedObjects_ = 0;
	var indices = {};
	this._indicesByUUID = indices;
	for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
		indices[ arguments[ i ].uuid ] = i;
	}
	this._paths = [];
	this._parsedPaths = [];
	this._bindings = [];
	this._bindingsIndicesByPath = {};
	var scope = this;
	this.stats = {
		objects: {
			get total() {
				return scope._objects.length;
			},
			get inUse() {
				return this.total - scope.nCachedObjects_;
			}
		},
		get bindingsPerObject() {
			return scope._bindings.length;
		}
	};
}
Object.assign( AnimationObjectGroup.prototype, {
	isAnimationObjectGroup: true,
	add: function () {
		var objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			paths = this._paths,
			parsedPaths = this._parsedPaths,
			bindings = this._bindings,
			nBindings = bindings.length;
		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ],
				knownObject = undefined;
			if ( index === undefined ) {
				index = nObjects ++;
				indicesByUUID[ uuid ] = index;
				objects.push( object );
				for ( var j = 0, m = nBindings; j !== m; ++ j ) {
					bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );
				}
			} else if ( index < nCachedObjects ) {
				knownObject = objects[ index ];
				var firstActiveIndex = -- nCachedObjects,
					lastCachedObject = objects[ firstActiveIndex ];
				indicesByUUID[ lastCachedObject.uuid ] = index;
				objects[ index ] = lastCachedObject;
				indicesByUUID[ uuid ] = firstActiveIndex;
				objects[ firstActiveIndex ] = object;
				for ( var j = 0, m = nBindings; j !== m; ++ j ) {
					var bindingsForPath = bindings[ j ],
						lastCached = bindingsForPath[ firstActiveIndex ],
						binding = bindingsForPath[ index ];
					bindingsForPath[ index ] = lastCached;
					if ( binding === undefined ) {
						binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );
					}
					bindingsForPath[ firstActiveIndex ] = binding;
				}
			} else if ( objects[ index ] !== knownObject ) {
				console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
						'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );
			}
		}
		this.nCachedObjects_ = nCachedObjects;
	},
	remove: function () {
		var objects = this._objects,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;
		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];
			if ( index !== undefined && index >= nCachedObjects ) {
				var lastCachedIndex = nCachedObjects ++,
					firstActiveObject = objects[ lastCachedIndex ];
				indicesByUUID[ firstActiveObject.uuid ] = index;
				objects[ index ] = firstActiveObject;
				indicesByUUID[ uuid ] = lastCachedIndex;
				objects[ lastCachedIndex ] = object;
				for ( var j = 0, m = nBindings; j !== m; ++ j ) {
					var bindingsForPath = bindings[ j ],
						firstActive = bindingsForPath[ lastCachedIndex ],
						binding = bindingsForPath[ index ];
					bindingsForPath[ index ] = firstActive;
					bindingsForPath[ lastCachedIndex ] = binding;
				}
			}
		}
		this.nCachedObjects_ = nCachedObjects;
	},
	uncache: function () {
		var objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;
		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];
			if ( index !== undefined ) {
				delete indicesByUUID[ uuid ];
				if ( index < nCachedObjects ) {
					var firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ],
						lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;
					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = lastObject;
					objects.pop();
					for ( var j = 0, m = nBindings; j !== m; ++ j ) {
						var bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							last = bindingsForPath[ lastIndex ];
						bindingsForPath[ index ] = lastCached;
						bindingsForPath[ firstActiveIndex ] = last;
						bindingsForPath.pop();
					}
				} else {
					var lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];
					indicesByUUID[ lastObject.uuid ] = index;
					objects[ index ] = lastObject;
					objects.pop();
					for ( var j = 0, m = nBindings; j !== m; ++ j ) {
						var bindingsForPath = bindings[ j ];
						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
						bindingsForPath.pop();
					}
				}
			}
		}
		this.nCachedObjects_ = nCachedObjects;
	},
	subscribe_: function ( path, parsedPath ) {
		var indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ],
			bindings = this._bindings;
		if ( index !== undefined ) return bindings[ index ];
		var paths = this._paths,
			parsedPaths = this._parsedPaths,
			objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			bindingsForPath = new Array( nObjects );
		index = bindings.length;
		indicesByPath[ path ] = index;
		paths.push( path );
		parsedPaths.push( parsedPath );
		bindings.push( bindingsForPath );
		for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {
			var object = objects[ i ];
			bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );
		}
		return bindingsForPath;
	},
	unsubscribe_: function ( path ) {
		var indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ];
		if ( index !== undefined ) {
			var paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				lastBindingsIndex = bindings.length - 1,
				lastBindings = bindings[ lastBindingsIndex ],
				lastBindingsPath = path[ lastBindingsIndex ];
			indicesByPath[ lastBindingsPath ] = index;
			bindings[ index ] = lastBindings;
			bindings.pop();
			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
			parsedPaths.pop();
			paths[ index ] = paths[ lastBindingsIndex ];
			paths.pop();
		}
	}
} );
function AnimationAction( mixer, clip, localRoot ) {
	this._mixer = mixer;
	this._clip = clip;
	this._localRoot = localRoot || null;
	var tracks = clip.tracks,
		nTracks = tracks.length,
		interpolants = new Array( nTracks );
	var interpolantSettings = {
		endingStart: ZeroCurvatureEnding,
		endingEnd: ZeroCurvatureEnding
	};
	for ( var i = 0; i !== nTracks; ++ i ) {
		var interpolant = tracks[ i ].createInterpolant( null );
		interpolants[ i ] = interpolant;
		interpolant.settings = interpolantSettings;
	}
	this._interpolantSettings = interpolantSettings;
	this._interpolants = interpolants;
	this._propertyBindings = new Array( nTracks );
	this._cacheIndex = null;
	this._byClipCacheIndex = null;
	this._timeScaleInterpolant = null;
	this._weightInterpolant = null;
	this.loop = LoopRepeat;
	this._loopCount = - 1;
	this._startTime = null;
	this.time = 0;
	this.timeScale = 1;
	this._effectiveTimeScale = 1;
	this.weight = 1;
	this._effectiveWeight = 1;
	this.repetitions = Infinity;
	this.paused = false;
	this.enabled = true;
	this.clampWhenFinished 	= false;
	this.zeroSlopeAtStart 	= true;
	this.zeroSlopeAtEnd		= true;
}
Object.assign( AnimationAction.prototype, {
	play: function () {
		this._mixer._activateAction( this );
		return this;
	},
	stop: function () {
		this._mixer._deactivateAction( this );
		return this.reset();
	},
	reset: function () {
		this.paused = false;
		this.enabled = true;
		this.time = 0;
		this._loopCount = - 1;
		this._startTime = null;
		return this.stopFading().stopWarping();
	},
	isRunning: function () {
		return this.enabled && ! this.paused && this.timeScale !== 0 &&
				this._startTime === null && this._mixer._isActiveAction( this );
	},
	isScheduled: function () {
		return this._mixer._isActiveAction( this );
	},
	startAt: function ( time ) {
		this._startTime = time;
		return this;
	},
	setLoop: function ( mode, repetitions ) {
		this.loop = mode;
		this.repetitions = repetitions;
		return this;
	},
	setEffectiveWeight: function ( weight ) {
		this.weight = weight;
		this._effectiveWeight = this.enabled ? weight : 0;
		return this.stopFading();
	},
	getEffectiveWeight: function () {
		return this._effectiveWeight;
	},
	fadeIn: function ( duration ) {
		return this._scheduleFading( duration, 0, 1 );
	},
	fadeOut: function ( duration ) {
		return this._scheduleFading( duration, 1, 0 );
	},
	crossFadeFrom: function ( fadeOutAction, duration, warp ) {
		fadeOutAction.fadeOut( duration );
		this.fadeIn( duration );
		if ( warp ) {
			var fadeInDuration = this._clip.duration,
				fadeOutDuration = fadeOutAction._clip.duration,
				startEndRatio = fadeOutDuration / fadeInDuration,
				endStartRatio = fadeInDuration / fadeOutDuration;
			fadeOutAction.warp( 1.0, startEndRatio, duration );
			this.warp( endStartRatio, 1.0, duration );
		}
		return this;
	},
	crossFadeTo: function ( fadeInAction, duration, warp ) {
		return fadeInAction.crossFadeFrom( this, duration, warp );
	},
	stopFading: function () {
		var weightInterpolant = this._weightInterpolant;
		if ( weightInterpolant !== null ) {
			this._weightInterpolant = null;
			this._mixer._takeBackControlInterpolant( weightInterpolant );
		}
		return this;
	},
	setEffectiveTimeScale: function ( timeScale ) {
		this.timeScale = timeScale;
		this._effectiveTimeScale = this.paused ? 0 : timeScale;
		return this.stopWarping();
	},
	getEffectiveTimeScale: function () {
		return this._effectiveTimeScale;
	},
	setDuration: function ( duration ) {
		this.timeScale = this._clip.duration / duration;
		return this.stopWarping();
	},
	syncWith: function ( action ) {
		this.time = action.time;
		this.timeScale = action.timeScale;
		return this.stopWarping();
	},
	halt: function ( duration ) {
		return this.warp( this._effectiveTimeScale, 0, duration );
	},
	warp: function ( startTimeScale, endTimeScale, duration ) {
		var mixer = this._mixer, now = mixer.time,
			interpolant = this._timeScaleInterpolant,
			timeScale = this.timeScale;
		if ( interpolant === null ) {
			interpolant = mixer._lendControlInterpolant();
			this._timeScaleInterpolant = interpolant;
		}
		var times = interpolant.parameterPositions,
			values = interpolant.sampleValues;
		times[ 0 ] = now;
		times[ 1 ] = now + duration;
		values[ 0 ] = startTimeScale / timeScale;
		values[ 1 ] = endTimeScale / timeScale;
		return this;
	},
	stopWarping: function () {
		var timeScaleInterpolant = this._timeScaleInterpolant;
		if ( timeScaleInterpolant !== null ) {
			this._timeScaleInterpolant = null;
			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );
		}
		return this;
	},
	getMixer: function () {
		return this._mixer;
	},
	getClip: function () {
		return this._clip;
	},
	getRoot: function () {
		return this._localRoot || this._mixer._root;
	},
	_update: function ( time, deltaTime, timeDirection, accuIndex ) {
		if ( ! this.enabled ) {
			this._updateWeight( time );
			return;
		}
		var startTime = this._startTime;
		if ( startTime !== null ) {
			var timeRunning = ( time - startTime ) * timeDirection;
			if ( timeRunning < 0 || timeDirection === 0 ) {
				return;
			}
			this._startTime = null;
			deltaTime = timeDirection * timeRunning;
		}
		deltaTime *= this._updateTimeScale( time );
		var clipTime = this._updateTime( deltaTime );
		var weight = this._updateWeight( time );
		if ( weight > 0 ) {
			var interpolants = this._interpolants;
			var propertyMixers = this._propertyBindings;
			for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {
				interpolants[ j ].evaluate( clipTime );
				propertyMixers[ j ].accumulate( accuIndex, weight );
			}
		}
	},
	_updateWeight: function ( time ) {
		var weight = 0;
		if ( this.enabled ) {
			weight = this.weight;
			var interpolant = this._weightInterpolant;
			if ( interpolant !== null ) {
				var interpolantValue = interpolant.evaluate( time )[ 0 ];
				weight *= interpolantValue;
				if ( time > interpolant.parameterPositions[ 1 ] ) {
					this.stopFading();
					if ( interpolantValue === 0 ) {
						this.enabled = false;
					}
				}
			}
		}
		this._effectiveWeight = weight;
		return weight;
	},
	_updateTimeScale: function ( time ) {
		var timeScale = 0;
		if ( ! this.paused ) {
			timeScale = this.timeScale;
			var interpolant = this._timeScaleInterpolant;
			if ( interpolant !== null ) {
				var interpolantValue = interpolant.evaluate( time )[ 0 ];
				timeScale *= interpolantValue;
				if ( time > interpolant.parameterPositions[ 1 ] ) {
					this.stopWarping();
					if ( timeScale === 0 ) {
						this.paused = true;
					} else {
						this.timeScale = timeScale;
					}
				}
			}
		}
		this._effectiveTimeScale = timeScale;
		return timeScale;
	},
	_updateTime: function ( deltaTime ) {
		var time = this.time + deltaTime;
		if ( deltaTime === 0 ) return time;
		var duration = this._clip.duration,
			loop = this.loop,
			loopCount = this._loopCount;
		if ( loop === LoopOnce ) {
			if ( loopCount === - 1 ) {
				this._loopCount = 0;
				this._setEndings( true, true, false );
			}
			handle_stop: {
				if ( time >= duration ) {
					time = duration;
				} else if ( time < 0 ) {
					time = 0;
				} else break handle_stop;
				if ( this.clampWhenFinished ) this.paused = true;
				else this.enabled = false;
				this._mixer.dispatchEvent( {
					type: 'finished', action: this,
					direction: deltaTime < 0 ? - 1 : 1
				} );
			}
		} else {
			var pingPong = ( loop === LoopPingPong );
			if ( loopCount === - 1 ) {
				if ( deltaTime >= 0 ) {
					loopCount = 0;
					this._setEndings( true, this.repetitions === 0, pingPong );
				} else {
					this._setEndings( this.repetitions === 0, true, pingPong );
				}
			}
			if ( time >= duration || time < 0 ) {
				var loopDelta = Math.floor( time / duration );
				time -= duration * loopDelta;
				loopCount += Math.abs( loopDelta );
				var pending = this.repetitions - loopCount;
				if ( pending < 0 ) {
					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;
					time = deltaTime > 0 ? duration : 0;
					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime > 0 ? 1 : - 1
					} );
				} else {
					if ( pending === 0 ) {
						var atStart = deltaTime < 0;
						this._setEndings( atStart, ! atStart, pingPong );
					} else {
						this._setEndings( false, false, pingPong );
					}
					this._loopCount = loopCount;
					this._mixer.dispatchEvent( {
						type: 'loop', action: this, loopDelta: loopDelta
					} );
				}
			}
			if ( pingPong && ( loopCount & 1 ) === 1 ) {
				this.time = time;
				return duration - time;
			}
		}
		this.time = time;
		return time;
	},
	_setEndings: function ( atStart, atEnd, pingPong ) {
		var settings = this._interpolantSettings;
		if ( pingPong ) {
			settings.endingStart 	= ZeroSlopeEnding;
			settings.endingEnd		= ZeroSlopeEnding;
		} else {
			if ( atStart ) {
				settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
			} else {
				settings.endingStart = WrapAroundEnding;
			}
			if ( atEnd ) {
				settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
			} else {
				settings.endingEnd 	 = WrapAroundEnding;
			}
		}
	},
	_scheduleFading: function ( duration, weightNow, weightThen ) {
		var mixer = this._mixer, now = mixer.time,
			interpolant = this._weightInterpolant;
		if ( interpolant === null ) {
			interpolant = mixer._lendControlInterpolant();
			this._weightInterpolant = interpolant;
		}
		var times = interpolant.parameterPositions,
			values = interpolant.sampleValues;
		times[ 0 ] = now; 				values[ 0 ] = weightNow;
		times[ 1 ] = now + duration;	values[ 1 ] = weightThen;
		return this;
	}
} );
function AnimationMixer( root ) {
	this._root = root;
	this._initMemoryManager();
	this._accuIndex = 0;
	this.time = 0;
	this.timeScale = 1.0;
}
Object.assign( AnimationMixer.prototype, EventDispatcher.prototype, {
	_bindAction: function ( action, prototypeAction ) {
		var root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingsByName = bindingsByRoot[ rootUuid ];
		if ( bindingsByName === undefined ) {
			bindingsByName = {};
			bindingsByRoot[ rootUuid ] = bindingsByName;
		}
		for ( var i = 0; i !== nTracks; ++ i ) {
			var track = tracks[ i ],
				trackName = track.name,
				binding = bindingsByName[ trackName ];
			if ( binding !== undefined ) {
				bindings[ i ] = binding;
			} else {
				binding = bindings[ i ];
				if ( binding !== undefined ) {
					if ( binding._cacheIndex === null ) {
						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );
					}
					continue;
				}
				var path = prototypeAction && prototypeAction.
					_propertyBindings[ i ].binding.parsedPath;
				binding = new PropertyMixer(
					PropertyBinding.create( root, trackName, path ),
					track.ValueTypeName, track.getValueSize() );
				++ binding.referenceCount;
				this._addInactiveBinding( binding, rootUuid, trackName );
				bindings[ i ] = binding;
			}
			interpolants[ i ].resultBuffer = binding.buffer;
		}
	},
	_activateAction: function ( action ) {
		if ( ! this._isActiveAction( action ) ) {
			if ( action._cacheIndex === null ) {
				var rootUuid = ( action._localRoot || this._root ).uuid,
					clipUuid = action._clip.uuid,
					actionsForClip = this._actionsByClip[ clipUuid ];
				this._bindAction( action,
					actionsForClip && actionsForClip.knownActions[ 0 ] );
				this._addInactiveAction( action, clipUuid, rootUuid );
			}
			var bindings = action._propertyBindings;
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
				var binding = bindings[ i ];
				if ( binding.useCount ++ === 0 ) {
					this._lendBinding( binding );
					binding.saveOriginalState();
				}
			}
			this._lendAction( action );
		}
	},
	_deactivateAction: function ( action ) {
		if ( this._isActiveAction( action ) ) {
			var bindings = action._propertyBindings;
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
				var binding = bindings[ i ];
				if ( -- binding.useCount === 0 ) {
					binding.restoreOriginalState();
					this._takeBackBinding( binding );
				}
			}
			this._takeBackAction( action );
		}
	},
	_initMemoryManager: function () {
		this._actions = [];
		this._nActiveActions = 0;
		this._actionsByClip = {};
		this._bindings = [];
		this._nActiveBindings = 0;
		this._bindingsByRootAndName = {};
		this._controlInterpolants = [];
		this._nActiveControlInterpolants = 0;
		var scope = this;
		this.stats = {
			actions: {
				get total() {
					return scope._actions.length;
				},
				get inUse() {
					return scope._nActiveActions;
				}
			},
			bindings: {
				get total() {
					return scope._bindings.length;
				},
				get inUse() {
					return scope._nActiveBindings;
				}
			},
			controlInterpolants: {
				get total() {
					return scope._controlInterpolants.length;
				},
				get inUse() {
					return scope._nActiveControlInterpolants;
				}
			}
		};
	},
	_isActiveAction: function ( action ) {
		var index = action._cacheIndex;
		return index !== null && index < this._nActiveActions;
	},
	_addInactiveAction: function ( action, clipUuid, rootUuid ) {
		var actions = this._actions,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];
		if ( actionsForClip === undefined ) {
			actionsForClip = {
				knownActions: [ action ],
				actionByRoot: {}
			};
			action._byClipCacheIndex = 0;
			actionsByClip[ clipUuid ] = actionsForClip;
		} else {
			var knownActions = actionsForClip.knownActions;
			action._byClipCacheIndex = knownActions.length;
			knownActions.push( action );
		}
		action._cacheIndex = actions.length;
		actions.push( action );
		actionsForClip.actionByRoot[ rootUuid ] = action;
	},
	_removeInactiveAction: function ( action ) {
		var actions = this._actions,
			lastInactiveAction = actions[ actions.length - 1 ],
			cacheIndex = action._cacheIndex;
		lastInactiveAction._cacheIndex = cacheIndex;
		actions[ cacheIndex ] = lastInactiveAction;
		actions.pop();
		action._cacheIndex = null;
		var clipUuid = action._clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ],
			knownActionsForClip = actionsForClip.knownActions,
			lastKnownAction =
				knownActionsForClip[ knownActionsForClip.length - 1 ],
			byClipCacheIndex = action._byClipCacheIndex;
		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		knownActionsForClip.pop();
		action._byClipCacheIndex = null;
		var actionByRoot = actionsForClip.actionByRoot,
			rootUuid = ( action._localRoot || this._root ).uuid;
		delete actionByRoot[ rootUuid ];
		if ( knownActionsForClip.length === 0 ) {
			delete actionsByClip[ clipUuid ];
		}
		this._removeInactiveBindingsForAction( action );
	},
	_removeInactiveBindingsForAction: function ( action ) {
		var bindings = action._propertyBindings;
		for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
			var binding = bindings[ i ];
			if ( -- binding.referenceCount === 0 ) {
				this._removeInactiveBinding( binding );
			}
		}
	},
	_lendAction: function ( action ) {
		var actions = this._actions,
			prevIndex = action._cacheIndex,
			lastActiveIndex = this._nActiveActions ++,
			firstInactiveAction = actions[ lastActiveIndex ];
		action._cacheIndex = lastActiveIndex;
		actions[ lastActiveIndex ] = action;
		firstInactiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = firstInactiveAction;
	},
	_takeBackAction: function ( action ) {
		var actions = this._actions,
			prevIndex = action._cacheIndex,
			firstInactiveIndex = -- this._nActiveActions,
			lastActiveAction = actions[ firstInactiveIndex ];
		action._cacheIndex = firstInactiveIndex;
		actions[ firstInactiveIndex ] = action;
		lastActiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = lastActiveAction;
	},
	_addInactiveBinding: function ( binding, rootUuid, trackName ) {
		var bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],
			bindings = this._bindings;
		if ( bindingByName === undefined ) {
			bindingByName = {};
			bindingsByRoot[ rootUuid ] = bindingByName;
		}
		bindingByName[ trackName ] = binding;
		binding._cacheIndex = bindings.length;
		bindings.push( binding );
	},
	_removeInactiveBinding: function ( binding ) {
		var bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],
			lastInactiveBinding = bindings[ bindings.length - 1 ],
			cacheIndex = binding._cacheIndex;
		lastInactiveBinding._cacheIndex = cacheIndex;
		bindings[ cacheIndex ] = lastInactiveBinding;
		bindings.pop();
		delete bindingByName[ trackName ];
		remove_empty_map: {
			for ( var _ in bindingByName ) break remove_empty_map;
			delete bindingsByRoot[ rootUuid ];
		}
	},
	_lendBinding: function ( binding ) {
		var bindings = this._bindings,
			prevIndex = binding._cacheIndex,
			lastActiveIndex = this._nActiveBindings ++,
			firstInactiveBinding = bindings[ lastActiveIndex ];
		binding._cacheIndex = lastActiveIndex;
		bindings[ lastActiveIndex ] = binding;
		firstInactiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = firstInactiveBinding;
	},
	_takeBackBinding: function ( binding ) {
		var bindings = this._bindings,
			prevIndex = binding._cacheIndex,
			firstInactiveIndex = -- this._nActiveBindings,
			lastActiveBinding = bindings[ firstInactiveIndex ];
		binding._cacheIndex = firstInactiveIndex;
		bindings[ firstInactiveIndex ] = binding;
		lastActiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = lastActiveBinding;
	},
	_lendControlInterpolant: function () {
		var interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants ++,
			interpolant = interpolants[ lastActiveIndex ];
		if ( interpolant === undefined ) {
			interpolant = new LinearInterpolant(
				new Float32Array( 2 ), new Float32Array( 2 ),
				1, this._controlInterpolantsResultBuffer );
			interpolant.__cacheIndex = lastActiveIndex;
			interpolants[ lastActiveIndex ] = interpolant;
		}
		return interpolant;
	},
	_takeBackControlInterpolant: function ( interpolant ) {
		var interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,
			firstInactiveIndex = -- this._nActiveControlInterpolants,
			lastActiveInterpolant = interpolants[ firstInactiveIndex ];
		interpolant.__cacheIndex = firstInactiveIndex;
		interpolants[ firstInactiveIndex ] = interpolant;
		lastActiveInterpolant.__cacheIndex = prevIndex;
		interpolants[ prevIndex ] = lastActiveInterpolant;
	},
	_controlInterpolantsResultBuffer: new Float32Array( 1 ),
	clipAction: function ( clip, optionalRoot ) {
		var root = optionalRoot || this._root,
			rootUuid = root.uuid,
			clipObject = typeof clip === 'string' ?
				AnimationClip.findByName( root, clip ) : clip,
			clipUuid = clipObject !== null ? clipObject.uuid : clip,
			actionsForClip = this._actionsByClip[ clipUuid ],
			prototypeAction = null;
		if ( actionsForClip !== undefined ) {
			var existingAction =
					actionsForClip.actionByRoot[ rootUuid ];
			if ( existingAction !== undefined ) {
				return existingAction;
			}
			prototypeAction = actionsForClip.knownActions[ 0 ];
			if ( clipObject === null )
				clipObject = prototypeAction._clip;
		}
		if ( clipObject === null ) return null;
		var newAction = new AnimationAction( this, clipObject, optionalRoot );
		this._bindAction( newAction, prototypeAction );
		this._addInactiveAction( newAction, clipUuid, rootUuid );
		return newAction;
	},
	existingAction: function ( clip, optionalRoot ) {
		var root = optionalRoot || this._root,
			rootUuid = root.uuid,
			clipObject = typeof clip === 'string' ?
				AnimationClip.findByName( root, clip ) : clip,
			clipUuid = clipObject ? clipObject.uuid : clip,
			actionsForClip = this._actionsByClip[ clipUuid ];
		if ( actionsForClip !== undefined ) {
			return actionsForClip.actionByRoot[ rootUuid ] || null;
		}
		return null;
	},
	stopAllAction: function () {
		var actions = this._actions,
			nActions = this._nActiveActions,
			bindings = this._bindings,
			nBindings = this._nActiveBindings;
		this._nActiveActions = 0;
		this._nActiveBindings = 0;
		for ( var i = 0; i !== nActions; ++ i ) {
			actions[ i ].reset();
		}
		for ( var i = 0; i !== nBindings; ++ i ) {
			bindings[ i ].useCount = 0;
		}
		return this;
	},
	update: function ( deltaTime ) {
		deltaTime *= this.timeScale;
		var actions = this._actions,
			nActions = this._nActiveActions,
			time = this.time += deltaTime,
			timeDirection = Math.sign( deltaTime ),
			accuIndex = this._accuIndex ^= 1;
		for ( var i = 0; i !== nActions; ++ i ) {
			var action = actions[ i ];
			action._update( time, deltaTime, timeDirection, accuIndex );
		}
		var bindings = this._bindings,
			nBindings = this._nActiveBindings;
		for ( var i = 0; i !== nBindings; ++ i ) {
			bindings[ i ].apply( accuIndex );
		}
		return this;
	},
	getRoot: function () {
		return this._root;
	},
	uncacheClip: function ( clip ) {
		var actions = this._actions,
			clipUuid = clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];
		if ( actionsForClip !== undefined ) {
			var actionsToRemove = actionsForClip.knownActions;
			for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {
				var action = actionsToRemove[ i ];
				this._deactivateAction( action );
				var cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[ actions.length - 1 ];
				action._cacheIndex = null;
				action._byClipCacheIndex = null;
				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();
				this._removeInactiveBindingsForAction( action );
			}
			delete actionsByClip[ clipUuid ];
		}
	},
	uncacheRoot: function ( root ) {
		var rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;
		for ( var clipUuid in actionsByClip ) {
			var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
				action = actionByRoot[ rootUuid ];
			if ( action !== undefined ) {
				this._deactivateAction( action );
				this._removeInactiveAction( action );
			}
		}
		var bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ];
		if ( bindingByName !== undefined ) {
			for ( var trackName in bindingByName ) {
				var binding = bindingByName[ trackName ];
				binding.restoreOriginalState();
				this._removeInactiveBinding( binding );
			}
		}
	},
	uncacheAction: function ( clip, optionalRoot ) {
		var action = this.existingAction( clip, optionalRoot );
		if ( action !== null ) {
			this._deactivateAction( action );
			this._removeInactiveAction( action );
		}
	}
} );
function Uniform( value ) {
	if ( typeof value === 'string' ) {
		console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
		value = arguments[ 1 ];
	}
	this.value = value;
}
Uniform.prototype.clone = function () {
	return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );
};
function InstancedBufferGeometry() {
	BufferGeometry.call( this );
	this.type = 'InstancedBufferGeometry';
	this.maxInstancedCount = undefined;
}
InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {
	constructor: InstancedBufferGeometry,
	isInstancedBufferGeometry: true,
	copy: function ( source ) {
		BufferGeometry.prototype.copy.call( this, source );
		this.maxInstancedCount = source.maxInstancedCount;
		return this;
	},
	clone: function () {
		return new this.constructor().copy( this );
	}
} );
function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {
	this.uuid = _Math.generateUUID();
	this.data = interleavedBuffer;
	this.itemSize = itemSize;
	this.offset = offset;
	this.normalized = normalized === true;
}
Object.defineProperties( InterleavedBufferAttribute.prototype, {
	count: {
		get: function () {
			return this.data.count;
		}
	},
	array: {
		get: function () {
			return this.data.array;
		}
	}
} );
Object.assign( InterleavedBufferAttribute.prototype, {
	isInterleavedBufferAttribute: true,
	setX: function ( index, x ) {
		this.data.array[ index * this.data.stride + this.offset ] = x;
		return this;
	},
	setY: function ( index, y ) {
		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;
		return this;
	},
	setZ: function ( index, z ) {
		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;
		return this;
	},
	setW: function ( index, w ) {
		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;
		return this;
	},
	getX: function ( index ) {
		return this.data.array[ index * this.data.stride + this.offset ];
	},
	getY: function ( index ) {
		return this.data.array[ index * this.data.stride + this.offset + 1 ];
	},
	getZ: function ( index ) {
		return this.data.array[ index * this.data.stride + this.offset + 2 ];
	},
	getW: function ( index ) {
		return this.data.array[ index * this.data.stride + this.offset + 3 ];
	},
	setXY: function ( index, x, y ) {
		index = index * this.data.stride + this.offset;
		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		return this;
	},
	setXYZ: function ( index, x, y, z ) {
		index = index * this.data.stride + this.offset;
		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		return this;
	},
	setXYZW: function ( index, x, y, z, w ) {
		index = index * this.data.stride + this.offset;
		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;
		return this;
	}
} );
function InterleavedBuffer( array, stride ) {
	this.uuid = _Math.generateUUID();
	this.array = array;
	this.stride = stride;
	this.count = array !== undefined ? array.length / stride : 0;
	this.dynamic = false;
	this.updateRange = { offset: 0, count: - 1 };
	this.onUploadCallback = function () {};
	this.version = 0;
}
Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {
	set: function ( value ) {
		if ( value === true ) this.version ++;
	}
} );
Object.assign( InterleavedBuffer.prototype, {
	isInterleavedBuffer: true,
	setArray: function ( array ) {
		if ( Array.isArray( array ) ) {
			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
		}
		this.count = array !== undefined ? array.length / this.stride : 0;
		this.array = array;
	},
	setDynamic: function ( value ) {
		this.dynamic = value;
		return this;
	},
	copy: function ( source ) {
		this.array = new source.array.constructor( source.array );
		this.count = source.count;
		this.stride = source.stride;
		this.dynamic = source.dynamic;
		return this;
	},
	copyAt: function ( index1, attribute, index2 ) {
		index1 *= this.stride;
		index2 *= attribute.stride;
		for ( var i = 0, l = this.stride; i < l; i ++ ) {
			this.array[ index1 + i ] = attribute.array[ index2 + i ];
		}
		return this;
	},
	set: function ( value, offset ) {
		if ( offset === undefined ) offset = 0;
		this.array.set( value, offset );
		return this;
	},
	clone: function () {
		return new this.constructor().copy( this );
	},
	onUpload: function ( callback ) {
		this.onUploadCallback = callback;
		return this;
	}
} );
function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {
	InterleavedBuffer.call( this, array, stride );
	this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {
	constructor: InstancedInterleavedBuffer,
	isInstancedInterleavedBuffer: true,
	copy: function ( source ) {
		InterleavedBuffer.prototype.copy.call( this, source );
		this.meshPerAttribute = source.meshPerAttribute;
		return this;
	}
} );
function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {
	BufferAttribute.call( this, array, itemSize );
	this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {
	constructor: InstancedBufferAttribute,
	isInstancedBufferAttribute: true,
	copy: function ( source ) {
		BufferAttribute.prototype.copy.call( this, source );
		this.meshPerAttribute = source.meshPerAttribute;
		return this;
	}
} );
function Raycaster( origin, direction, near, far ) {
	this.ray = new Ray( origin, direction );
	this.near = near || 0;
	this.far = far || Infinity;
	this.params = {
		Mesh: {},
		Line: {},
		LOD: {},
		Points: { threshold: 1 },
		Sprite: {}
	};
	Object.defineProperties( this.params, {
		PointCloud: {
			get: function () {
				console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
				return this.Points;
			}
		}
	} );
}
function ascSort( a, b ) {
	return a.distance - b.distance;
}
function intersectObject( object, raycaster, intersects, recursive ) {
	if ( object.visible === false ) return;
	object.raycast( raycaster, intersects );
	if ( recursive === true ) {
		var children = object.children;
		for ( var i = 0, l = children.length; i < l; i ++ ) {
			intersectObject( children[ i ], raycaster, intersects, true );
		}
	}
}
Object.assign( Raycaster.prototype, {
	linePrecision: 1,
	set: function ( origin, direction ) {
		this.ray.set( origin, direction );
	},
	setFromCamera: function ( coords, camera ) {
		if ( ( camera && camera.isPerspectiveCamera ) ) {
			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
		} else if ( ( camera && camera.isOrthographicCamera ) ) {
			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera );
			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
		} else {
			console.error( 'THREE.Raycaster: Unsupported camera type.' );
		}
	},
	intersectObject: function ( object, recursive ) {
		var intersects = [];
		intersectObject( object, this, intersects, recursive );
		intersects.sort( ascSort );
		return intersects;
	},
	intersectObjects: function ( objects, recursive ) {
		var intersects = [];
		if ( Array.isArray( objects ) === false ) {
			console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
			return intersects;
		}
		for ( var i = 0, l = objects.length; i < l; i ++ ) {
			intersectObject( objects[ i ], this, intersects, recursive );
		}
		intersects.sort( ascSort );
		return intersects;
	}
} );
function Clock( autoStart ) {
	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;
	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;
	this.running = false;
}
Object.assign( Clock.prototype, {
	start: function () {
		this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now();
		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;
	},
	stop: function () {
		this.getElapsedTime();
		this.running = false;
		this.autoStart = false;
	},
	getElapsedTime: function () {
		this.getDelta();
		return this.elapsedTime;
	},
	getDelta: function () {
		var diff = 0;
		if ( this.autoStart && ! this.running ) {
			this.start();
			return 0;
		}
		if ( this.running ) {
			var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();
			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;
			this.elapsedTime += diff;
		}
		return diff;
	}
} );
function Spherical( radius, phi, theta ) {
	this.radius = ( radius !== undefined ) ? radius : 1.0;
	this.phi = ( phi !== undefined ) ? phi : 0;
	this.theta = ( theta !== undefined ) ? theta : 0;
	return this;
}
Object.assign( Spherical.prototype, {
	set: function ( radius, phi, theta ) {
		this.radius = radius;
		this.phi = phi;
		this.theta = theta;
		return this;
	},
	clone: function () {
		return new this.constructor().copy( this );
	},
	copy: function ( other ) {
		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;
		return this;
	},
	makeSafe: function () {
		var EPS = 0.000001;
		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );
		return this;
	},
	setFromVector3: function ( vec3 ) {
		this.radius = vec3.length();
		if ( this.radius === 0 ) {
			this.theta = 0;
			this.phi = 0;
		} else {
			this.theta = Math.atan2( vec3.x, vec3.z );
			this.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) );
		}
		return this;
	}
} );
function Cylindrical( radius, theta, y ) {
	this.radius = ( radius !== undefined ) ? radius : 1.0;
	this.theta = ( theta !== undefined ) ? theta : 0;
	this.y = ( y !== undefined ) ? y : 0;
	return this;
}
Object.assign( Cylindrical.prototype, {
	set: function ( radius, theta, y ) {
		this.radius = radius;
		this.theta = theta;
		this.y = y;
		return this;
	},
	clone: function () {
		return new this.constructor().copy( this );
	},
	copy: function ( other ) {
		this.radius = other.radius;
		this.theta = other.theta;
		this.y = other.y;
		return this;
	},
	setFromVector3: function ( vec3 ) {
		this.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );
		this.theta = Math.atan2( vec3.x, vec3.z );
		this.y = vec3.y;
		return this;
	}
} );
function ImmediateRenderObject( material ) {
	Object3D.call( this );
	this.material = material;
	this.render = function (                      ) {};
}
ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
function VertexNormalsHelper( object, size, hex, linewidth ) {
	this.object = object;
	this.size = ( size !== undefined ) ? size : 1;
	var color = ( hex !== undefined ) ? hex : 0xff0000;
	var width = ( linewidth !== undefined ) ? linewidth : 1;
	var nNormals = 0;
	var objGeometry = this.object.geometry;
	if ( objGeometry && objGeometry.isGeometry ) {
		nNormals = objGeometry.faces.length * 3;
	} else if ( objGeometry && objGeometry.isBufferGeometry ) {
		nNormals = objGeometry.attributes.normal.count;
	}
	var geometry = new BufferGeometry();
	var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );
	geometry.addAttribute( 'position', positions );
	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );
	this.matrixAutoUpdate = false;
	this.update();
}
VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;
VertexNormalsHelper.prototype.update = ( function () {
	var v1 = new Vector3();
	var v2 = new Vector3();
	var normalMatrix = new Matrix3();
	return function update() {
		var keys = [ 'a', 'b', 'c' ];
		this.object.updateMatrixWorld( true );
		normalMatrix.getNormalMatrix( this.object.matrixWorld );
		var matrixWorld = this.object.matrixWorld;
		var position = this.geometry.attributes.position;
		var objGeometry = this.object.geometry;
		if ( objGeometry && objGeometry.isGeometry ) {
			var vertices = objGeometry.vertices;
			var faces = objGeometry.faces;
			var idx = 0;
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
				var face = faces[ i ];
				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
					var vertex = vertices[ face[ keys[ j ] ] ];
					var normal = face.vertexNormals[ j ];
					v1.copy( vertex ).applyMatrix4( matrixWorld );
					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
					position.setXYZ( idx, v1.x, v1.y, v1.z );
					idx = idx + 1;
					position.setXYZ( idx, v2.x, v2.y, v2.z );
					idx = idx + 1;
				}
			}
		} else if ( objGeometry && objGeometry.isBufferGeometry ) {
			var objPos = objGeometry.attributes.position;
			var objNorm = objGeometry.attributes.normal;
			var idx = 0;
			for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {
				v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );
				v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );
				v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
				position.setXYZ( idx, v1.x, v1.y, v1.z );
				idx = idx + 1;
				position.setXYZ( idx, v2.x, v2.y, v2.z );
				idx = idx + 1;
			}
		}
		position.needsUpdate = true;
	};
}() );
function SpotLightHelper( light, color ) {
	Object3D.call( this );
	this.light = light;
	this.light.updateMatrixWorld();
	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;
	this.color = color;
	var geometry = new BufferGeometry();
	var positions = [
		0, 0, 0, 	0, 0, 1,
		0, 0, 0, 	1, 0, 1,
		0, 0, 0,	- 1, 0, 1,
		0, 0, 0, 	0, 1, 1,
		0, 0, 0, 	0, - 1, 1
	];
	for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {
		var p1 = ( i / l ) * Math.PI * 2;
		var p2 = ( j / l ) * Math.PI * 2;
		positions.push(
			Math.cos( p1 ), Math.sin( p1 ), 1,
			Math.cos( p2 ), Math.sin( p2 ), 1
		);
	}
	geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
	var material = new LineBasicMaterial( { fog: false } );
	this.cone = new LineSegments( geometry, material );
	this.add( this.cone );
	this.update();
}
SpotLightHelper.prototype = Object.create( Object3D.prototype );
SpotLightHelper.prototype.constructor = SpotLightHelper;
SpotLightHelper.prototype.dispose = function () {
	this.cone.geometry.dispose();
	this.cone.material.dispose();
};
SpotLightHelper.prototype.update = function () {
	var vector = new Vector3();
	var vector2 = new Vector3();
	return function update() {
		this.light.updateMatrixWorld();
		var coneLength = this.light.distance ? this.light.distance : 1000;
		var coneWidth = coneLength * Math.tan( this.light.angle );
		this.cone.scale.set( coneWidth, coneWidth, coneLength );
		vector.setFromMatrixPosition( this.light.matrixWorld );
		vector2.setFromMatrixPosition( this.light.target.matrixWorld );
		this.cone.lookAt( vector2.sub( vector ) );
		if ( this.color !== undefined ) {
			this.cone.material.color.set( this.color );
		} else {
			this.cone.material.color.copy( this.light.color );
		}
	};
}();
function getBoneList( object ) {
	var boneList = [];
	if ( object && object.isBone ) {
		boneList.push( object );
	}
	for ( var i = 0; i < object.children.length; i ++ ) {
		boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );
	}
	return boneList;
}
function SkeletonHelper( object ) {
	var bones = getBoneList( object );
	var geometry = new BufferGeometry();
	var vertices = [];
	var colors = [];
	var color1 = new Color( 0, 0, 1 );
	var color2 = new Color( 0, 1, 0 );
	for ( var i = 0; i < bones.length; i ++ ) {
		var bone = bones[ i ];
		if ( bone.parent && bone.parent.isBone ) {
			vertices.push( 0, 0, 0 );
			vertices.push( 0, 0, 0 );
			colors.push( color1.r, color1.g, color1.b );
			colors.push( color2.r, color2.g, color2.b );
		}
	}
	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );
	LineSegments.call( this, geometry, material );
	this.root = object;
	this.bones = bones;
	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;
}
SkeletonHelper.prototype = Object.create( LineSegments.prototype );
SkeletonHelper.prototype.constructor = SkeletonHelper;
SkeletonHelper.prototype.updateMatrixWorld = function () {
	var vector = new Vector3();
	var boneMatrix = new Matrix4();
	var matrixWorldInv = new Matrix4();
	return function updateMatrixWorld( force ) {
		var bones = this.bones;
		var geometry = this.geometry;
		var position = geometry.getAttribute( 'position' );
		matrixWorldInv.getInverse( this.root.matrixWorld );
		for ( var i = 0, j = 0; i < bones.length; i ++ ) {
			var bone = bones[ i ];
			if ( bone.parent && bone.parent.isBone ) {
				boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
				vector.setFromMatrixPosition( boneMatrix );
				position.setXYZ( j, vector.x, vector.y, vector.z );
				boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
				vector.setFromMatrixPosition( boneMatrix );
				position.setXYZ( j + 1, vector.x, vector.y, vector.z );
				j += 2;
			}
		}
		geometry.getAttribute( 'position' ).needsUpdate = true;
		Object3D.prototype.updateMatrixWorld.call( this, force );
	};
}();
function PointLightHelper( light, sphereSize, color ) {
	this.light = light;
	this.light.updateMatrixWorld();
	this.color = color;
	var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
	var material = new MeshBasicMaterial( { wireframe: true, fog: false } );
	Mesh.call( this, geometry, material );
	this.matrix = this.light.matrixWorld;
	this.matrixAutoUpdate = false;
	this.update();
}
PointLightHelper.prototype = Object.create( Mesh.prototype );
PointLightHelper.prototype.constructor = PointLightHelper;
PointLightHelper.prototype.dispose = function () {
	this.geometry.dispose();
	this.material.dispose();
};
PointLightHelper.prototype.update = function () {
	if ( this.color !== undefined ) {
		this.material.color.set( this.color );
	} else {
		this.material.color.copy( this.light.color );
	}
};
function RectAreaLightHelper( light, color ) {
	Object3D.call( this );
	this.light = light;
	this.light.updateMatrixWorld();
	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;
	this.color = color;
	var material = new LineBasicMaterial( { fog: false } );
	var geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 5 * 3 ), 3 ) );
	this.line = new Line( geometry, material );
	this.add( this.line );
	this.update();
}
RectAreaLightHelper.prototype = Object.create( Object3D.prototype );
RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;
RectAreaLightHelper.prototype.dispose = function () {
	this.children[ 0 ].geometry.dispose();
	this.children[ 0 ].material.dispose();
};
RectAreaLightHelper.prototype.update = function () {
	var hx = this.light.width * 0.5;
	var hy = this.light.height * 0.5;
	var position = this.line.geometry.attributes.position;
	var array = position.array;
	array[ 0 ] = hx; array[ 1 ] = - hy; array[ 2 ] = 0;
	array[ 3 ] = hx; array[ 4 ] = hy; array[ 5 ] = 0;
	array[ 6 ] = - hx; array[ 7 ] = hy; array[ 8 ] = 0;
	array[ 9 ] = - hx; array[ 10 ] = - hy; array[ 11 ] = 0;
	array[ 12 ] = hx; array[ 13 ] = - hy; array[ 14 ] = 0;
	position.needsUpdate = true;
	if ( this.color !== undefined ) {
		this.line.material.color.set( this.color );
	} else {
		this.line.material.color.copy( this.light.color );
	}
};
function HemisphereLightHelper( light, size, color ) {
	Object3D.call( this );
	this.light = light;
	this.light.updateMatrixWorld();
	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;
	this.color = color;
	var geometry = new OctahedronBufferGeometry( size );
	geometry.rotateY( Math.PI * 0.5 );
	this.material = new MeshBasicMaterial( { wireframe: true, fog: false } );
	if ( this.color === undefined ) this.material.vertexColors = VertexColors;
	var position = geometry.getAttribute( 'position' );
	var colors = new Float32Array( position.count * 3 );
	geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );
	this.add( new Mesh( geometry, this.material ) );
	this.update();
}
HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
HemisphereLightHelper.prototype.dispose = function () {
	this.children[ 0 ].geometry.dispose();
	this.children[ 0 ].material.dispose();
};
HemisphereLightHelper.prototype.update = function () {
	var vector = new Vector3();
	var color1 = new Color();
	var color2 = new Color();
	return function update() {
		var mesh = this.children[ 0 ];
		if ( this.color !== undefined ) {
			this.material.color.set( this.color );
		} else {
			var colors = mesh.geometry.getAttribute( 'color' );
			color1.copy( this.light.color );
			color2.copy( this.light.groundColor );
			for ( var i = 0, l = colors.count; i < l; i ++ ) {
				var color = ( i < ( l / 2 ) ) ? color1 : color2;
				colors.setXYZ( i, color.r, color.g, color.b );
			}
			colors.needsUpdate = true;
		}
		mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
	};
}();
function GridHelper( size, divisions, color1, color2 ) {
	size = size || 10;
	divisions = divisions || 10;
	color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
	color2 = new Color( color2 !== undefined ? color2 : 0x888888 );
	var center = divisions / 2;
	var step = size / divisions;
	var halfSize = size / 2;
	var vertices = [], colors = [];
	for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {
		vertices.push( - halfSize, 0, k, halfSize, 0, k );
		vertices.push( k, 0, - halfSize, k, 0, halfSize );
		var color = i === center ? color1 : color2;
		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;
	}
	var geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	var material = new LineBasicMaterial( { vertexColors: VertexColors } );
	LineSegments.call( this, geometry, material );
}
GridHelper.prototype = Object.create( LineSegments.prototype );
GridHelper.prototype.constructor = GridHelper;
function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {
	radius = radius || 10;
	radials = radials || 16;
	circles = circles || 8;
	divisions = divisions || 64;
	color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
	color2 = new Color( color2 !== undefined ? color2 : 0x888888 );
	var vertices = [];
	var colors = [];
	var x, z;
	var v, i, j, r, color;
	for ( i = 0; i <= radials; i ++ ) {
		v = ( i / radials ) * ( Math.PI * 2 );
		x = Math.sin( v ) * radius;
		z = Math.cos( v ) * radius;
		vertices.push( 0, 0, 0 );
		vertices.push( x, 0, z );
		color = ( i & 1 ) ? color1 : color2;
		colors.push( color.r, color.g, color.b );
		colors.push( color.r, color.g, color.b );
	}
	for ( i = 0; i <= circles; i ++ ) {
		color = ( i & 1 ) ? color1 : color2;
		r = radius - ( radius / circles * i );
		for ( j = 0; j < divisions; j ++ ) {
			v = ( j / divisions ) * ( Math.PI * 2 );
			x = Math.sin( v ) * r;
			z = Math.cos( v ) * r;
			vertices.push( x, 0, z );
			colors.push( color.r, color.g, color.b );
			v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );
			x = Math.sin( v ) * r;
			z = Math.cos( v ) * r;
			vertices.push( x, 0, z );
			colors.push( color.r, color.g, color.b );
		}
	}
	var geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	var material = new LineBasicMaterial( { vertexColors: VertexColors } );
	LineSegments.call( this, geometry, material );
}
PolarGridHelper.prototype = Object.create( LineSegments.prototype );
PolarGridHelper.prototype.constructor = PolarGridHelper;
function FaceNormalsHelper( object, size, hex, linewidth ) {
	this.object = object;
	this.size = ( size !== undefined ) ? size : 1;
	var color = ( hex !== undefined ) ? hex : 0xffff00;
	var width = ( linewidth !== undefined ) ? linewidth : 1;
	var nNormals = 0;
	var objGeometry = this.object.geometry;
	if ( objGeometry && objGeometry.isGeometry ) {
		nNormals = objGeometry.faces.length;
	} else {
		console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );
	}
	var geometry = new BufferGeometry();
	var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );
	geometry.addAttribute( 'position', positions );
	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );
	this.matrixAutoUpdate = false;
	this.update();
}
FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;
FaceNormalsHelper.prototype.update = ( function () {
	var v1 = new Vector3();
	var v2 = new Vector3();
	var normalMatrix = new Matrix3();
	return function update() {
		this.object.updateMatrixWorld( true );
		normalMatrix.getNormalMatrix( this.object.matrixWorld );
		var matrixWorld = this.object.matrixWorld;
		var position = this.geometry.attributes.position;
		var objGeometry = this.object.geometry;
		var vertices = objGeometry.vertices;
		var faces = objGeometry.faces;
		var idx = 0;
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
			var face = faces[ i ];
			var normal = face.normal;
			v1.copy( vertices[ face.a ] )
				.add( vertices[ face.b ] )
				.add( vertices[ face.c ] )
				.divideScalar( 3 )
				.applyMatrix4( matrixWorld );
			v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
			position.setXYZ( idx, v1.x, v1.y, v1.z );
			idx = idx + 1;
			position.setXYZ( idx, v2.x, v2.y, v2.z );
			idx = idx + 1;
		}
		position.needsUpdate = true;
	};
}() );
function DirectionalLightHelper( light, size, color ) {
	Object3D.call( this );
	this.light = light;
	this.light.updateMatrixWorld();
	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;
	this.color = color;
	if ( size === undefined ) size = 1;
	var geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( [
		- size, size, 0,
		size, size, 0,
		size, - size, 0,
		- size, - size, 0,
		- size, size, 0
	], 3 ) );
	var material = new LineBasicMaterial( { fog: false } );
	this.lightPlane = new Line( geometry, material );
	this.add( this.lightPlane );
	geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );
	this.targetLine = new Line( geometry, material );
	this.add( this.targetLine );
	this.update();
}
DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
DirectionalLightHelper.prototype.dispose = function () {
	this.lightPlane.geometry.dispose();
	this.lightPlane.material.dispose();
	this.targetLine.geometry.dispose();
	this.targetLine.material.dispose();
};
DirectionalLightHelper.prototype.update = function () {
	var v1 = new Vector3();
	var v2 = new Vector3();
	var v3 = new Vector3();
	return function update() {
		v1.setFromMatrixPosition( this.light.matrixWorld );
		v2.setFromMatrixPosition( this.light.target.matrixWorld );
		v3.subVectors( v2, v1 );
		this.lightPlane.lookAt( v3 );
		if ( this.color !== undefined ) {
			this.lightPlane.material.color.set( this.color );
			this.targetLine.material.color.set( this.color );
		} else {
			this.lightPlane.material.color.copy( this.light.color );
			this.targetLine.material.color.copy( this.light.color );
		}
		this.targetLine.lookAt( v3 );
		this.targetLine.scale.z = v3.length();
	};
}();
function CameraHelper( camera ) {
	var geometry = new BufferGeometry();
	var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );
	var vertices = [];
	var colors = [];
	var pointMap = {};
	var colorFrustum = new Color( 0xffaa00 );
	var colorCone = new Color( 0xff0000 );
	var colorUp = new Color( 0x00aaff );
	var colorTarget = new Color( 0xffffff );
	var colorCross = new Color( 0x333333 );
	addLine( 'n1', 'n2', colorFrustum );
	addLine( 'n2', 'n4', colorFrustum );
	addLine( 'n4', 'n3', colorFrustum );
	addLine( 'n3', 'n1', colorFrustum );
	addLine( 'f1', 'f2', colorFrustum );
	addLine( 'f2', 'f4', colorFrustum );
	addLine( 'f4', 'f3', colorFrustum );
	addLine( 'f3', 'f1', colorFrustum );
	addLine( 'n1', 'f1', colorFrustum );
	addLine( 'n2', 'f2', colorFrustum );
	addLine( 'n3', 'f3', colorFrustum );
	addLine( 'n4', 'f4', colorFrustum );
	addLine( 'p', 'n1', colorCone );
	addLine( 'p', 'n2', colorCone );
	addLine( 'p', 'n3', colorCone );
	addLine( 'p', 'n4', colorCone );
	addLine( 'u1', 'u2', colorUp );
	addLine( 'u2', 'u3', colorUp );
	addLine( 'u3', 'u1', colorUp );
	addLine( 'c', 't', colorTarget );
	addLine( 'p', 'c', colorCross );
	addLine( 'cn1', 'cn2', colorCross );
	addLine( 'cn3', 'cn4', colorCross );
	addLine( 'cf1', 'cf2', colorCross );
	addLine( 'cf3', 'cf4', colorCross );
	function addLine( a, b, color ) {
		addPoint( a, color );
		addPoint( b, color );
	}
	function addPoint( id, color ) {
		vertices.push( 0, 0, 0 );
		colors.push( color.r, color.g, color.b );
		if ( pointMap[ id ] === undefined ) {
			pointMap[ id ] = [];
		}
		pointMap[ id ].push( ( vertices.length / 3 ) - 1 );
	}
	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	LineSegments.call( this, geometry, material );
	this.camera = camera;
	if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();
	this.matrix = camera.matrixWorld;
	this.matrixAutoUpdate = false;
	this.pointMap = pointMap;
	this.update();
}
CameraHelper.prototype = Object.create( LineSegments.prototype );
CameraHelper.prototype.constructor = CameraHelper;
CameraHelper.prototype.update = function () {
	var geometry, pointMap;
	var vector = new Vector3();
	var camera = new Camera();
	function setPoint( point, x, y, z ) {
		vector.set( x, y, z ).unproject( camera );
		var points = pointMap[ point ];
		if ( points !== undefined ) {
			var position = geometry.getAttribute( 'position' );
			for ( var i = 0, l = points.length; i < l; i ++ ) {
				position.setXYZ( points[ i ], vector.x, vector.y, vector.z );
			}
		}
	}
	return function update() {
		geometry = this.geometry;
		pointMap = this.pointMap;
		var w = 1, h = 1;
		camera.projectionMatrix.copy( this.camera.projectionMatrix );
		setPoint( 'c', 0, 0, - 1 );
		setPoint( 't', 0, 0, 1 );
		setPoint( 'n1', - w, - h, - 1 );
		setPoint( 'n2', w, - h, - 1 );
		setPoint( 'n3', - w, h, - 1 );
		setPoint( 'n4', w, h, - 1 );
		setPoint( 'f1', - w, - h, 1 );
		setPoint( 'f2', w, - h, 1 );
		setPoint( 'f3', - w, h, 1 );
		setPoint( 'f4', w, h, 1 );
		setPoint( 'u1', w * 0.7, h * 1.1, - 1 );
		setPoint( 'u2', - w * 0.7, h * 1.1, - 1 );
		setPoint( 'u3', 0, h * 2, - 1 );
		setPoint( 'cf1', - w, 0, 1 );
		setPoint( 'cf2', w, 0, 1 );
		setPoint( 'cf3', 0, - h, 1 );
		setPoint( 'cf4', 0, h, 1 );
		setPoint( 'cn1', - w, 0, - 1 );
		setPoint( 'cn2', w, 0, - 1 );
		setPoint( 'cn3', 0, - h, - 1 );
		setPoint( 'cn4', 0, h, - 1 );
		geometry.getAttribute( 'position' ).needsUpdate = true;
	};
}();
function BoxHelper( object, color ) {
	this.object = object;
	if ( color === undefined ) color = 0xffff00;
	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
	var positions = new Float32Array( 8 * 3 );
	var geometry = new BufferGeometry();
	geometry.setIndex( new BufferAttribute( indices, 1 ) );
	geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );
	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );
	this.matrixAutoUpdate = false;
	this.update();
}
BoxHelper.prototype = Object.create( LineSegments.prototype );
BoxHelper.prototype.constructor = BoxHelper;
BoxHelper.prototype.update = ( function () {
	var box = new Box3();
	return function update( object ) {
		if ( object !== undefined ) {
			console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );
		}
		if ( this.object !== undefined ) {
			box.setFromObject( this.object );
		}
		if ( box.isEmpty() ) return;
		var min = box.min;
		var max = box.max;
		var position = this.geometry.attributes.position;
		var array = position.array;
		array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
		array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
		array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
		array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;
		position.needsUpdate = true;
		this.geometry.computeBoundingSphere();
	};
} )();
BoxHelper.prototype.setFromObject = function ( object ) {
	this.object = object;
	this.update();
	return this;
};
function Box3Helper( box, hex ) {
	this.type = 'Box3Helper';
	this.box = box;
	var color = ( hex !== undefined ) ? hex : 0xffff00;
	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
	var positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];
	var geometry = new BufferGeometry();
	geometry.setIndex( new BufferAttribute( indices, 1 ) );
	geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );
	this.geometry.computeBoundingSphere();
}
Box3Helper.prototype = Object.create( LineSegments.prototype );
Box3Helper.prototype.constructor = Box3Helper;
Box3Helper.prototype.updateMatrixWorld = function ( force ) {
	var box = this.box;
	if ( box.isEmpty() ) return;
	box.getCenter( this.position );
	box.getSize( this.scale );
	this.scale.multiplyScalar( 0.5 );
	Object3D.prototype.updateMatrixWorld.call( this, force );
};
function PlaneHelper( plane, size, hex ) {
	this.type = 'PlaneHelper';
	this.plane = plane;
	this.size = ( size === undefined ) ? 1 : size;
	var color = ( hex !== undefined ) ? hex : 0xffff00;
	var positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];
	var geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
	geometry.computeBoundingSphere();
	Line.call( this, geometry, new LineBasicMaterial( { color: color } ) );
	var positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];
	var geometry2 = new BufferGeometry();
	geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
	geometry2.computeBoundingSphere();
	this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );
}
PlaneHelper.prototype = Object.create( Line.prototype );
PlaneHelper.prototype.constructor = PlaneHelper;
PlaneHelper.prototype.updateMatrixWorld = function ( force ) {
	var scale = - this.plane.constant;
	if ( Math.abs( scale ) < 1e-8 ) scale = 1e-8;
	this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );
	this.lookAt( this.plane.normal );
	Object3D.prototype.updateMatrixWorld.call( this, force );
};
var lineGeometry;
var coneGeometry;
function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {
	Object3D.call( this );
	if ( color === undefined ) color = 0xffff00;
	if ( length === undefined ) length = 1;
	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	if ( lineGeometry === undefined ) {
		lineGeometry = new BufferGeometry();
		lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );
		coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
		coneGeometry.translate( 0, - 0.5, 0 );
	}
	this.position.copy( origin );
	this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
	this.line.matrixAutoUpdate = false;
	this.add( this.line );
	this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
	this.cone.matrixAutoUpdate = false;
	this.add( this.cone );
	this.setDirection( dir );
	this.setLength( length, headLength, headWidth );
}
ArrowHelper.prototype = Object.create( Object3D.prototype );
ArrowHelper.prototype.constructor = ArrowHelper;
ArrowHelper.prototype.setDirection = ( function () {
	var axis = new Vector3();
	var radians;
	return function setDirection( dir ) {
		if ( dir.y > 0.99999 ) {
			this.quaternion.set( 0, 0, 0, 1 );
		} else if ( dir.y < - 0.99999 ) {
			this.quaternion.set( 1, 0, 0, 0 );
		} else {
			axis.set( dir.z, 0, - dir.x ).normalize();
			radians = Math.acos( dir.y );
			this.quaternion.setFromAxisAngle( axis, radians );
		}
	};
}() );
ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {
	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
	this.line.updateMatrix();
	this.cone.scale.set( headWidth, headLength, headWidth );
	this.cone.position.y = length;
	this.cone.updateMatrix();
};
ArrowHelper.prototype.setColor = function ( color ) {
	this.line.material.color.copy( color );
	this.cone.material.color.copy( color );
};
function AxesHelper( size ) {
	size = size || 1;
	var vertices = [
		0, 0, 0,	size, 0, 0,
		0, 0, 0,	0, size, 0,
		0, 0, 0,	0, 0, size
	];
	var colors = [
		1, 0, 0,	1, 0.6, 0,
		0, 1, 0,	0.6, 1, 0,
		0, 0, 1,	0, 0.6, 1
	];
	var geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	var material = new LineBasicMaterial( { vertexColors: VertexColors } );
	LineSegments.call( this, geometry, material );
}
AxesHelper.prototype = Object.create( LineSegments.prototype );
AxesHelper.prototype.constructor = AxesHelper;
function CubicPoly() {
	var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
	function init( x0, x1, t0, t1 ) {
		c0 = x0;
		c1 = t0;
		c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		c3 = 2 * x0 - 2 * x1 + t0 + t1;
	}
	return {
		initCatmullRom: function ( x0, x1, x2, x3, tension ) {
			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );
		},
		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {
			var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;
			t1 *= dt1;
			t2 *= dt1;
			init( x1, x2, t1, t2 );
		},
		calc: function ( t ) {
			var t2 = t * t;
			var t3 = t2 * t;
			return c0 + c1 * t + c2 * t2 + c3 * t3;
		}
	};
}
var tmp = new Vector3();
var px = new CubicPoly();
var py = new CubicPoly();
var pz = new CubicPoly();
function CatmullRomCurve3( points, closed, curveType, tension ) {
	Curve.call( this );
	this.type = 'CatmullRomCurve3';
	this.points = points || [];
	this.closed = closed || false;
	this.curveType = curveType || 'centripetal';
	this.tension = tension || 0.5;
}
CatmullRomCurve3.prototype = Object.create( Curve.prototype );
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
CatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {
	var point = optionalTarget || new Vector3();
	var points = this.points;
	var l = points.length;
	var p = ( l - ( this.closed ? 0 : 1 ) ) * t;
	var intPoint = Math.floor( p );
	var weight = p - intPoint;
	if ( this.closed ) {
		intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;
	} else if ( weight === 0 && intPoint === l - 1 ) {
		intPoint = l - 2;
		weight = 1;
	}
	var p0, p1, p2, p3;
	if ( this.closed || intPoint > 0 ) {
		p0 = points[ ( intPoint - 1 ) % l ];
	} else {
		tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
		p0 = tmp;
	}
	p1 = points[ intPoint % l ];
	p2 = points[ ( intPoint + 1 ) % l ];
	if ( this.closed || intPoint + 2 < l ) {
		p3 = points[ ( intPoint + 2 ) % l ];
	} else {
		tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
		p3 = tmp;
	}
	if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {
		var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
		var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
		var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
		var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );
		if ( dt1 < 1e-4 ) dt1 = 1.0;
		if ( dt0 < 1e-4 ) dt0 = dt1;
		if ( dt2 < 1e-4 ) dt2 = dt1;
		px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
		py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
		pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );
	} else if ( this.curveType === 'catmullrom' ) {
		px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
		py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
		pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );
	}
	point.set(
		px.calc( weight ),
		py.calc( weight ),
		pz.calc( weight )
	);
	return point;
};
CatmullRomCurve3.prototype.copy = function ( source ) {
	Curve.prototype.copy.call( this, source );
	this.points = [];
	for ( var i = 0, l = source.points.length; i < l; i ++ ) {
		var point = source.points[ i ];
		this.points.push( point.clone() );
	}
	this.closed = source.closed;
	this.curveType = source.curveType;
	this.tension = source.tension;
	return this;
};
function CubicBezierCurve3( v0, v1, v2, v3 ) {
	Curve.call( this );
	this.type = 'CubicBezierCurve3';
	this.v0 = v0 || new Vector3();
	this.v1 = v1 || new Vector3();
	this.v2 = v2 || new Vector3();
	this.v3 = v3 || new Vector3();
}
CubicBezierCurve3.prototype = Object.create( Curve.prototype );
CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
CubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {
	var point = optionalTarget || new Vector3();
	var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
	point.set(
		CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
		CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
		CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
	);
	return point;
};
CubicBezierCurve3.prototype.copy = function ( source ) {
	Curve.prototype.copy.call( this, source );
	this.v0.copy( source.v0 );
	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );
	this.v3.copy( source.v3 );
	return this;
};
function QuadraticBezierCurve3( v0, v1, v2 ) {
	Curve.call( this );
	this.type = 'QuadraticBezierCurve3';
	this.v0 = v0 || new Vector3();
	this.v1 = v1 || new Vector3();
	this.v2 = v2 || new Vector3();
}
QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
QuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {
	var point = optionalTarget || new Vector3();
	var v0 = this.v0, v1 = this.v1, v2 = this.v2;
	point.set(
		QuadraticBezier( t, v0.x, v1.x, v2.x ),
		QuadraticBezier( t, v0.y, v1.y, v2.y ),
		QuadraticBezier( t, v0.z, v1.z, v2.z )
	);
	return point;
};
QuadraticBezierCurve3.prototype.copy = function ( source ) {
	Curve.prototype.copy.call( this, source );
	this.v0.copy( source.v0 );
	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );
	return this;
};
function LineCurve3( v1, v2 ) {
	Curve.call( this );
	this.type = 'LineCurve3';
	this.v1 = v1 || new Vector3();
	this.v2 = v2 || new Vector3();
}
LineCurve3.prototype = Object.create( Curve.prototype );
LineCurve3.prototype.constructor = LineCurve3;
LineCurve3.prototype.isLineCurve3 = true;
LineCurve3.prototype.getPoint = function ( t, optionalTarget ) {
	var point = optionalTarget || new Vector3();
	if ( t === 1 ) {
		point.copy( this.v2 );
	} else {
		point.copy( this.v2 ).sub( this.v1 );
		point.multiplyScalar( t ).add( this.v1 );
	}
	return point;
};
LineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {
	return this.getPoint( u, optionalTarget );
};
LineCurve3.prototype.copy = function ( source ) {
	Curve.prototype.copy.call( this, source );
	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );
	return this;
};
function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	this.type = 'ArcCurve';
}
ArcCurve.prototype = Object.create( EllipseCurve.prototype );
ArcCurve.prototype.constructor = ArcCurve;
ArcCurve.prototype.isArcCurve = true;
Curve.create = function ( construct, getPoint ) {
	console.log( 'THREE.Curve.create() has been deprecated' );
	construct.prototype = Object.create( Curve.prototype );
	construct.prototype.constructor = construct;
	construct.prototype.getPoint = getPoint;
	return construct;
};
Object.assign( CurvePath.prototype, {
	createPointsGeometry: function ( divisions ) {
		console.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );
		var pts = this.getPoints( divisions );
		return this.createGeometry( pts );
	},
	createSpacedPointsGeometry: function ( divisions ) {
		console.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );
		var pts = this.getSpacedPoints( divisions );
		return this.createGeometry( pts );
	},
	createGeometry: function ( points ) {
		console.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );
		var geometry = new Geometry();
		for ( var i = 0, l = points.length; i < l; i ++ ) {
			var point = points[ i ];
			geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );
		}
		return geometry;
	}
} );
Object.assign( Path.prototype, {
	fromPoints: function ( points ) {
		console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
		this.setFromPoints( points );
	}
} );
function Spline( points ) {
	console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );
	CatmullRomCurve3.call( this, points );
	this.type = 'catmullrom';
}
Spline.prototype = Object.create( CatmullRomCurve3.prototype );
Object.assign( Spline.prototype, {
	initFromArray: function (         ) {
		console.error( 'THREE.Spline: .initFromArray() has been removed.' );
	},
	getControlPointsArray: function (                      ) {
		console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );
	},
	reparametrizeByArcLength: function (                    ) {
		console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );
	}
} );
GridHelper.prototype.setColors = function () {
	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );
};
SkeletonHelper.prototype.update = function () {
	console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );
};
Object.assign( Box2.prototype, {
	center: function ( optionalTarget ) {
		console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );
	},
	empty: function () {
		console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();
	},
	isIntersectionBox: function ( box ) {
		console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );
	},
	size: function ( optionalTarget ) {
		console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
		return this.getSize( optionalTarget );
	}
} );
Object.assign( Box3.prototype, {
	center: function ( optionalTarget ) {
		console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );
	},
	empty: function () {
		console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();
	},
	isIntersectionBox: function ( box ) {
		console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );
	},
	isIntersectionSphere: function ( sphere ) {
		console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
		return this.intersectsSphere( sphere );
	},
	size: function ( optionalTarget ) {
		console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
		return this.getSize( optionalTarget );
	}
} );
Line3.prototype.center = function ( optionalTarget ) {
	console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );
};
Object.assign( _Math, {
	random16: function () {
		console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
		return Math.random();
	},
	nearestPowerOfTwo: function ( value ) {
		console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
		return _Math.floorPowerOfTwo( value );
	},
	nextPowerOfTwo: function ( value ) {
		console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
		return _Math.ceilPowerOfTwo( value );
	}
} );
Object.assign( Matrix3.prototype, {
	flattenToArrayOffset: function ( array, offset ) {
		console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
		return this.toArray( array, offset );
	},
	multiplyVector3: function ( vector ) {
		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );
	},
	multiplyVector3Array: function (         ) {
		console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );
	},
	applyToBuffer: function ( buffer                       ) {
		console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
		return this.applyToBufferAttribute( buffer );
	},
	applyToVector3Array: function (                             ) {
		console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );
	}
} );
Object.assign( Matrix4.prototype, {
	extractPosition: function ( m ) {
		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );
	},
	flattenToArrayOffset: function ( array, offset ) {
		console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
		return this.toArray( array, offset );
	},
	getPosition: function () {
		var v1;
		return function getPosition() {
			if ( v1 === undefined ) v1 = new Vector3();
			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
			return v1.setFromMatrixColumn( this, 3 );
		};
	}(),
	setRotationFromQuaternion: function ( q ) {
		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
		return this.makeRotationFromQuaternion( q );
	},
	multiplyToArray: function () {
		console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );
	},
	multiplyVector3: function ( vector ) {
		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );
	},
	multiplyVector4: function ( vector ) {
		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );
	},
	multiplyVector3Array: function (         ) {
		console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );
	},
	rotateAxis: function ( v ) {
		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
		v.transformDirection( this );
	},
	crossVector: function ( vector ) {
		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );
	},
	translate: function () {
		console.error( 'THREE.Matrix4: .translate() has been removed.' );
	},
	rotateX: function () {
		console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
	},
	rotateY: function () {
		console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
	},
	rotateZ: function () {
		console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
	},
	rotateByAxis: function () {
		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
	},
	applyToBuffer: function ( buffer                       ) {
		console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
		return this.applyToBufferAttribute( buffer );
	},
	applyToVector3Array: function (                             ) {
		console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );
	},
	makeFrustum: function ( left, right, bottom, top, near, far ) {
		console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
		return this.makePerspective( left, right, top, bottom, near, far );
	}
} );
Plane.prototype.isIntersectionLine = function ( line ) {
	console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
	return this.intersectsLine( line );
};
Quaternion.prototype.multiplyVector3 = function ( vector ) {
	console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
	return vector.applyQuaternion( this );
};
Object.assign( Ray.prototype, {
	isIntersectionBox: function ( box ) {
		console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );
	},
	isIntersectionPlane: function ( plane ) {
		console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
		return this.intersectsPlane( plane );
	},
	isIntersectionSphere: function ( sphere ) {
		console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
		return this.intersectsSphere( sphere );
	}
} );
Object.assign( Shape.prototype, {
	extractAllPoints: function ( divisions ) {
		console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
		return this.extractPoints( divisions );
	},
	extrude: function ( options ) {
		console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
		return new ExtrudeGeometry( this, options );
	},
	makeGeometry: function ( options ) {
		console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
		return new ShapeGeometry( this, options );
	}
} );
Object.assign( Vector2.prototype, {
	fromAttribute: function ( attribute, index, offset ) {
		console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );
	},
	distanceToManhattan: function ( v ) {
		console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
		return this.manhattanDistanceTo( v );
	},
	lengthManhattan: function () {
		console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
		return this.manhattanLength();
	}
} );
Object.assign( Vector3.prototype, {
	setEulerFromRotationMatrix: function () {
		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
	},
	setEulerFromQuaternion: function () {
		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
	},
	getPositionFromMatrix: function ( m ) {
		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
		return this.setFromMatrixPosition( m );
	},
	getScaleFromMatrix: function ( m ) {
		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
		return this.setFromMatrixScale( m );
	},
	getColumnFromMatrix: function ( index, matrix ) {
		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
		return this.setFromMatrixColumn( matrix, index );
	},
	applyProjection: function ( m ) {
		console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
		return this.applyMatrix4( m );
	},
	fromAttribute: function ( attribute, index, offset ) {
		console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );
	},
	distanceToManhattan: function ( v ) {
		console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
		return this.manhattanDistanceTo( v );
	},
	lengthManhattan: function () {
		console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
		return this.manhattanLength();
	}
} );
Object.assign( Vector4.prototype, {
	fromAttribute: function ( attribute, index, offset ) {
		console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );
	},
	lengthManhattan: function () {
		console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
		return this.manhattanLength();
	}
} );
Geometry.prototype.computeTangents = function () {
	console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );
};
Object.assign( Object3D.prototype, {
	getChildByName: function ( name ) {
		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name );
	},
	renderDepth: function () {
		console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
	},
	translate: function ( distance, axis ) {
		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
		return this.translateOnAxis( axis, distance );
	}
} );
Object.defineProperties( Object3D.prototype, {
	eulerOrder: {
		get: function () {
			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			return this.rotation.order;
		},
		set: function ( value ) {
			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			this.rotation.order = value;
		}
	},
	useQuaternion: {
		get: function () {
			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
		},
		set: function () {
			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
		}
	}
} );
Object.defineProperties( LOD.prototype, {
	objects: {
		get: function () {
			console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
			return this.levels;
		}
	}
} );
Object.defineProperty( Skeleton.prototype, 'useVertexTexture', {
	get: function () {
		console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );
	},
	set: function () {
		console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );
	}
} );
Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {
	get: function () {
		console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
		return this.arcLengthDivisions;
	},
	set: function ( value ) {
		console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
		this.arcLengthDivisions = value;
	}
} );
PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {
	console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
			"Use .setFocalLength and .filmGauge for a photographic setup." );
	if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
	this.setFocalLength( focalLength );
};
Object.defineProperties( Light.prototype, {
	onlyShadow: {
		set: function () {
			console.warn( 'THREE.Light: .onlyShadow has been removed.' );
		}
	},
	shadowCameraFov: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
			this.shadow.camera.fov = value;
		}
	},
	shadowCameraLeft: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
			this.shadow.camera.left = value;
		}
	},
	shadowCameraRight: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
			this.shadow.camera.right = value;
		}
	},
	shadowCameraTop: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
			this.shadow.camera.top = value;
		}
	},
	shadowCameraBottom: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
			this.shadow.camera.bottom = value;
		}
	},
	shadowCameraNear: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
			this.shadow.camera.near = value;
		}
	},
	shadowCameraFar: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
			this.shadow.camera.far = value;
		}
	},
	shadowCameraVisible: {
		set: function () {
			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );
		}
	},
	shadowBias: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
			this.shadow.bias = value;
		}
	},
	shadowDarkness: {
		set: function () {
			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );
		}
	},
	shadowMapWidth: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
			this.shadow.mapSize.width = value;
		}
	},
	shadowMapHeight: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
			this.shadow.mapSize.height = value;
		}
	}
} );
Object.defineProperties( BufferAttribute.prototype, {
	length: {
		get: function () {
			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
			return this.array.length;
		}
	}
} );
Object.assign( BufferGeometry.prototype, {
	addIndex: function ( index ) {
		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
		this.setIndex( index );
	},
	addDrawCall: function ( start, count, indexOffset ) {
		if ( indexOffset !== undefined ) {
			console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
		}
		console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
		this.addGroup( start, count );
	},
	clearDrawCalls: function () {
		console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
		this.clearGroups();
	},
	computeTangents: function () {
		console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
	},
	computeOffsets: function () {
		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );
	}
} );
Object.defineProperties( BufferGeometry.prototype, {
	drawcalls: {
		get: function () {
			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
			return this.groups;
		}
	},
	offsets: {
		get: function () {
			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
			return this.groups;
		}
	}
} );
Object.defineProperties( Uniform.prototype, {
	dynamic: {
		set: function () {
			console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );
		}
	},
	onUpdate: {
		value: function () {
			console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
			return this;
		}
	}
} );
Object.defineProperties( Material.prototype, {
	wrapAround: {
		get: function () {
			console.warn( 'THREE.Material: .wrapAround has been removed.' );
		},
		set: function () {
			console.warn( 'THREE.Material: .wrapAround has been removed.' );
		}
	},
	wrapRGB: {
		get: function () {
			console.warn( 'THREE.Material: .wrapRGB has been removed.' );
			return new Color();
		}
	},
	shading: {
		get: function () {
			console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
		},
		set: function ( value ) {
			console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
			this.flatShading = ( value === FlatShading );
		}
	}
} );
Object.defineProperties( MeshPhongMaterial.prototype, {
	metal: {
		get: function () {
			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
			return false;
		},
		set: function () {
			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );
		}
	}
} );
Object.defineProperties( ShaderMaterial.prototype, {
	derivatives: {
		get: function () {
			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			return this.extensions.derivatives;
		},
		set: function ( value ) {
			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			this.extensions.derivatives = value;
		}
	}
} );
Object.assign( WebGLRenderer.prototype, {
	getCurrentRenderTarget: function () {
		console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
		return this.getRenderTarget();
	},
	getMaxAnisotropy: function () {
		console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
		return this.capabilities.getMaxAnisotropy();
	},
	getPrecision: function () {
		console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
		return this.capabilities.precision;
	},
	resetGLState: function () {
		console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
		return this.state.reset();
	},
	supportsFloatTextures: function () {
		console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
		return this.extensions.get( 'OES_texture_float' );
	},
	supportsHalfFloatTextures: function () {
		console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
		return this.extensions.get( 'OES_texture_half_float' );
	},
	supportsStandardDerivatives: function () {
		console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
		return this.extensions.get( 'OES_standard_derivatives' );
	},
	supportsCompressedTextureS3TC: function () {
		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
		return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );
	},
	supportsCompressedTexturePVRTC: function () {
		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
		return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );
	},
	supportsBlendMinMax: function () {
		console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
		return this.extensions.get( 'EXT_blend_minmax' );
	},
	supportsVertexTextures: function () {
		console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
		return this.capabilities.vertexTextures;
	},
	supportsInstancedArrays: function () {
		console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
		return this.extensions.get( 'ANGLE_instanced_arrays' );
	},
	enableScissorTest: function ( boolean ) {
		console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
		this.setScissorTest( boolean );
	},
	initMaterial: function () {
		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
	},
	addPrePlugin: function () {
		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
	},
	addPostPlugin: function () {
		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
	},
	updateShadowMap: function () {
		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
	}
} );
Object.defineProperties( WebGLRenderer.prototype, {
	shadowMapEnabled: {
		get: function () {
			return this.shadowMap.enabled;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
			this.shadowMap.enabled = value;
		}
	},
	shadowMapType: {
		get: function () {
			return this.shadowMap.type;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
			this.shadowMap.type = value;
		}
	},
	shadowMapCullFace: {
		get: function () {
			return this.shadowMap.cullFace;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
			this.shadowMap.cullFace = value;
		}
	}
} );
Object.defineProperties( WebGLShadowMap.prototype, {
	cullFace: {
		get: function () {
			return this.renderReverseSided ? CullFaceFront : CullFaceBack;
		},
		set: function ( cullFace ) {
			var value = ( cullFace !== CullFaceBack );
			console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
			this.renderReverseSided = value;
		}
	}
} );
Object.defineProperties( WebGLRenderTarget.prototype, {
	wrapS: {
		get: function () {
			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			return this.texture.wrapS;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			this.texture.wrapS = value;
		}
	},
	wrapT: {
		get: function () {
			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			return this.texture.wrapT;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			this.texture.wrapT = value;
		}
	},
	magFilter: {
		get: function () {
			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			return this.texture.magFilter;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			this.texture.magFilter = value;
		}
	},
	minFilter: {
		get: function () {
			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			return this.texture.minFilter;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			this.texture.minFilter = value;
		}
	},
	anisotropy: {
		get: function () {
			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			return this.texture.anisotropy;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			this.texture.anisotropy = value;
		}
	},
	offset: {
		get: function () {
			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			return this.texture.offset;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			this.texture.offset = value;
		}
	},
	repeat: {
		get: function () {
			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			return this.texture.repeat;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			this.texture.repeat = value;
		}
	},
	format: {
		get: function () {
			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			return this.texture.format;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			this.texture.format = value;
		}
	},
	type: {
		get: function () {
			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			return this.texture.type;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			this.texture.type = value;
		}
	},
	generateMipmaps: {
		get: function () {
			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			return this.texture.generateMipmaps;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			this.texture.generateMipmaps = value;
		}
	}
} );
Audio.prototype.load = function ( file ) {
	console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
	var scope = this;
	var audioLoader = new AudioLoader();
	audioLoader.load( file, function ( buffer ) {
		scope.setBuffer( buffer );
	} );
	return this;
};
AudioAnalyser.prototype.getData = function () {
	console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
	return this.getFrequencyData();
};
CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {
	console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
	return this.update( renderer, scene );
};

class WebVR {
  constructor(renderer, callback) {
    this.renderer = renderer;
    this.displays = {};
    this.displays_index = 0;
    this.onVRConnectedCallback = [];
    if (!('getVRDisplays' in window.navigator)) {
      return callback(false);
    }
    navigator.getVRDisplays().then(displays => {
      displays.forEach(display => {
        if (this.displays_index == 0) {
          this.renderer.vr.setDevice(display);
        }
        this.displays[this.displays_index] = display;
        this.onVRConnectedCallback.forEach(callback => {
          callback(display, this.displays_index);
        });
        this.displays_index++;
      });
      callback(true);
    });
  }
  onVRConnected(callback) {
    this.onVRConnectedCallback.push(callback);
  }
  requestAnimationFrame(callback) {
    let display = this.renderer.vr.getDevice();
    if (display) {
      display.requestAnimationFrame(callback);
      return true;
    } else {
      return false;
    }
  }
  setDevice(index) {
    this.renderer.vr.setDevice(this.displays[index]);
  }
  enterVR() {
    let display = this.renderer.vr.getDevice();
    if (!display) throw new Error('Not found VR Device');
    display.requestPresent([{ source: this.renderer.domElement }]);
  }
}

function normalizeRot(rot) {
  if (Array.isArray(rot)) {
    if (rot.length < 4) {
      return [normalizeRotNumber(rot[0]), normalizeRotNumber(rot[1]), normalizeRotNumber(rot[2])];
    } else {
      return [normalizeRotNumber(rot[0]), normalizeRotNumber(rot[1]), normalizeRotNumber(rot[2]), normalizeRotNumber(rot[3])];
    }
  } else {
    return normalizeRot([0, 0, 0]);
  }
}
function normalizeRotNumber(rot) {
  if (typeof rot == 'number') {
    return rot / 180 * Math.PI;
  } else if (typeof rot == 'string') {
    const _rot = parseInt(/^([0-9]+)deg?$/.exec(rot)[1], 10);
    return _rot / 180 * Math.PI;
  } else {
    return 0;
  }
}
function normalizeScale(scale) {
  if (Array.isArray(scale)) {
    return [normalizeScaleNumber(scale[0]), normalizeScaleNumber(scale[1]), normalizeScaleNumber(scale[2])];
  } else {
    return normalizeScale([1, 1, 1]);
  }
}
function normalizeScaleNumber(scale) {
  if (typeof scale == 'number') {
    return scale;
  } else if (typeof scale == 'string') {
    return parseInt(/^([0-9]+)m?$/.exec(scale)[1], 10);
  } else {
    return 1;
  }
}
function normalizePos(pos) {
  if (Array.isArray(pos)) {
    return [normalizePosNumber(pos[0]), normalizePosNumber(pos[1]), normalizePosNumber(pos[2])];
  } else {
    return normalizePos([0, 0, 0]);
  }
}
function normalizePosNumber(pos) {
  if (typeof pos == 'number') {
    return pos;
  } else if (typeof rot == 'string') {
    return parseInt(/^([0-9]+)m?$/.exec(pos)[1], 10);
  } else {
    return 0;
  }
}
function normalizeSize(size, length) {
  if (Array.isArray(size)) {
    const result = [];
    for (let i = 0; i < length; i++) {
      result.push(normalizeSizeNumber(size[i]));
    }
    return result;
  } else {
    return normalizeSize([...Array(length)].map(() => 1));
  }
}
function normalizeSizeNumber(size) {
  if (typeof size == 'number') {
    return size;
  } else if (typeof size == 'string') {
    return parseInt(/^([0-9]+)m?$/.exec(size)[1], 10);
  } else {
    return 1;
  }
}
function normalizeColor(color) {
  return color;
}

class OMLElement {
  constructor(OML, property, sizeLength) {
    this.OML = OML;
    this.property = property;
    this.obj3d;
    if (!(OML instanceof Object)) {
      throw new TypeError();
    }
    if (OML.define) {
      for (let name in OML.define) {
        this.property.define[name] = OML.define[name];
      }
    }
    if (OML.version) {
      this.property.version = OML.version;
    }
    OML._rot = normalizeRot(OML.rot);
    OML._scale = normalizeScale(OML.scale);
    OML._pos = normalizePos(OML.pos);
    OML._size = normalizeSize(OML.size, sizeLength);
    OML._color = normalizeColor(OML.color);
  }
  _addObj(obj) {
    obj.castShadow = true;
    obj.receiveShadow = true;
    if (this.OML._rot.length == 4) {
      const qt = new Quaternion();
      qt.setFromAxisAngle(new Vector3(this.OML._rot[0], this.OML._rot[1], -this.OML._rot[2]), this.OML._rot[3]);
      obj.rotation.setFromQuaternion(qt);
    } else {
      obj.rotation.set(-this.OML._rot[0], -this.OML._rot[1], this.OML._rot[2]);
    }
    obj.scale.set(this.OML._scale[0], this.OML._scale[1], this.OML._scale[2]);
    obj.position.set(this.OML._pos[0], this.OML._pos[1], -this.OML._pos[2]);
    this.obj3d = obj;
  }
  destroy() {}
}

class GroupElement extends OMLElement {
  constructor(OML, property) {
    super(OML, property);
    const group = new Group();
    this.objs = [];
    super._addObj(group);
    for (let childOML of OML.group) {
      const element = createElement(childOML, {
        define: this.property.define,
        version: this.property.version
      });
      this.objs.push(element);
      group.add(element.obj3d);
    }
  }
  destroy() {
    super.destroy();
    this.objs.forEach(obj => obj.destroy());
  }
}

class CubeElement extends OMLElement {
  constructor(OML, property) {
    super(OML, property, 3);
    const obj = new Mesh(new BoxGeometry(OML._size[0], OML._size[1], OML._size[2]), new MeshPhongMaterial({ color: OML._color }));
    super._addObj(obj);
  }
}

class CylinderElement extends OMLElement {
  constructor(OML, property) {
    super(OML, property, 2);
    const obj = new Mesh(new CylinderGeometry(this.OML._size[0] / 2, this.OML._size[0] / 2, this.OML._size[1], 50), new MeshPhongMaterial({ color: this.OML._color }));
    super._addObj(obj);
  }
}

class SphereElement extends OMLElement {
  constructor(OML, property) {
    super(OML, property, 3);
    const obj = new Mesh(new SphereGeometry(OML._size[0], OML._size[1], OML._size[2]), new MeshPhongMaterial({ color: OML._color }));
    super._addObj(obj);
  }
}

class SphereElement$1 extends OMLElement {
  constructor(OML, property) {
    super(OML, property, 2);
    const obj = new Group();
    const cube = new Mesh(new PlaneGeometry(OML._size[0], OML._size[1]), new MeshPhongMaterial({ color: OML._color }));
    cube.rotation.set(-Math.PI / 2, 0, 0);
    cube.castShadow = true;
    cube.receiveShadow = true;
    obj.add(cube);
    super._addObj(obj);
  }
}

function createElement(OML, property = { define: {} }) {
  if (OML.group) {
    return new GroupElement(OML, property);
  } else if (OML.component) {
    if (Object.keys(property.define).indexOf(OML.component) == -1) {
      switch (OML.component) {
        case '@cube':
          {
            return new CubeElement(OML, property);
          }
        case '@cylinder':
          {
            return new CylinderElement(OML, property);
          }
        case '@sphere':
          {
            return new SphereElement(OML, property);
          }
        case '@plane':
          {
            return new SphereElement$1(OML, property);
          }
        case '@model':
          {
            console.error(new Error('not implemented'));
            return;
          }
        case '@text':
          {
            console.error(new Error('not implemented'));
            return;
          }
        case '@light':
          {
            console.error(new Error('not implemented'));
            return;
          }
      }
    } else {
      const _OML = Object.assign({}, property.define[OML.component]);
      for (let key in OML) {
        if (key != OML.component) {
          _OML[key] = OML[key];
        }
      }
      return createElement(_OML, property);
    }
  }
}

class OMLParser {
  constructor(scene) {
    this.scene = scene;
  }
  setOML(OML) {
    if (this.element) {
      this.element.destroy();
    }
    switch (typeof OML) {
      case 'string':
        {
          OML = JSON.parse(OML);
          break;
        }
      case 'object':
        {
          break;
        }
      default:
        {
          throw new TypeError();
        }
    }
    this.element = createElement(OML);
    this.scene.add(this.element.obj3d);
  }
}

var skybox_east = "data:image/jpeg;base64,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";

var skybox_west = "data:image/jpeg;base64,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";

var skybox_up = "data:image/jpeg;base64,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";

var skybox_down = "data:image/jpeg;base64,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";

var skybox_north = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASABIAAD/4QCMRXhpZgAATU0AKgAAAAgABQESAAMAAAABAAEAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAIdpAAQAAAABAAAAWgAAAAAAAABIAAAAAQAAAEgAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAABACgAwAEAAAAAQAABAAAAAAA/+0AOFBob3Rvc2hvcCAzLjAAOEJJTQQEAAAAAAAAOEJJTQQlAAAAAAAQ1B2M2Y8AsgTpgAmY7PhCfv/AABEIBAAEAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2wBDAAYGBgYGBgoGBgoOCgoKDhIODg4OEhcSEhISEhccFxcXFxcXHBwcHBwcHBwiIiIiIiInJycnJywsLCwsLCwsLCz/2wBDAQcHBwsKCxMKChMuHxofLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi7/3QAEAED/2gAMAwEAAhEDEQA/APTCKjIqwy1ERXcc5ARTCKmIphFMREabipDTMUwG4p2PlzS4oHpQBERTakYU0CgBAOacRS4xS44pDIiKbipCKYRzTEJSEYp6ikagBoFIeTS9BSCgBwFIzZ4pSeKVIXdGkXovWkMhphp7DHFNxTEMNRk1KRUZFMBhNNp2KRvSgRE3WmdafTCaYEbVGaeabVCG4ox3paaaAEo6UU7rQAq+9KaSjPYUgGmm4Jp+3NPAFAEOykIxU7EAVWY0AMLYqInNONMqhDaaafimmmIbirtncGLcOmen1qnSUmrjTsazX2SrH76n9BXYWeqxyQ43c4rzyM7pF3dKtmXyG+Q8Hp9KynST0LjNo2p79BcM2ciqr3afeU5xWNO6OdyZ5qvk1SpoTmdlp2oidijnGOaq3bSGY4X3rn7aYwyBx2rq7GVLx9zdelZzjyu5cZX0Op0phJajPDY5p05I4FQW6m1U7ehpWk35JNcUlrc3WxXcDGaoOm41rbQy4HNUJQIzzQgZnyZRTWfcfcDkZrQviFj39geazvOEzpGPu561tCPUiT6GTcOTFuOQQaqWMri6Rzk4PSptSj8u4aNWyOtZylkOVNdkV7pg3qemC4VsKhzxn3qKaRQmP4j0rE09HjthcMTlueatR3HngyuPu9MVyOFmbKRtwY8v5+tROFZCDWQNRJJDLtwatNcxvFuQ1Dg0VzHN6nbqr+YOfWsryYAhJ7itDUbhS5XOc1hsW6Zrtpp2OeTVyBsZOKbipMUYrYzI6KdikpiG4NJSmkoAT6UUUUAFOApvNP6UAGBTTilzSUAMIpMU/FGKYEdFPxSUCG4pMU7FFADaWlxmkoATFOVSxwKSnoSpzQBsWcyW3Hf1rSivUKOx5NcruY9TV6FCi/WsZ01uzWMzRgtmuZDcMMVfQxo5wKfpxXadxGMUtzNEgYgjFYttuxolpczbu8EYKpWDJI0hyxq3LIrA5qj35ropxSRjN3E5op3FFaEDaKXFOxQAynYpcU4LQAqcEE1otKpCg8n2qhinrwQRUNXLTsWXWPdk/lS+YA3HaojG/U96QjApWC46SVpDk1ETSgUuKdrAMpwUmnbakXI6UXAasZ709kUD3qVQSpJpmM0rjIdtO21JigCgQ0CnYxS0Y9KAEop4TjJqxbWzTNntSbtqOxHHDuGTUpgCrmtF7cgBB2prBQuB1rLnL5SC2gDtz0FWZnSMkCkT92uKqTIXfNTu9R7IqNKC+aiYjPFOZNtR4rdIzYdaSnUlUIUAd6uwlEqjUqA9amSGmWZJiOE71WLFjlqcV43GmoNxApJJA2f/0PVitROuKuFeaikFdiZhYpMKiIq04qAiqQiEimYqUim4qhDccU2pMUwigBpoApcU4CgBAuaUjHFSrTG61IyI1HjmpD1pvemAgHNNNSVG1AERpKcaTFMQGnpIygqOh60zFKuO9ACEEnmmnirTPuQLgDHeoSvFK4yDGaYwqfbiomFMRAajapCKjIqhEdRmpTUeKYhlMNSGm4pgMpKdikoATBNPxgUDikJzQAhoApKXFADhQWxSE4qFmzSsFxWaoS1BppqhDaQ06kpiG000402gBtIaWjGaYAqlmAFPkVk+U9uaYrFGDDtV4kzRGUjLDipbGjNoxTzgnikxVCHRxl2CjvXe6Rpyww7+pPeuLtYybhV/GvTbRlFsqj0rlxEnayNqSEmLNDhe1YguDGzLuFatyzJGWTvXN3KSAB2GFzyawpq5pJmqmorHHhutDXEU4Ddh1rnMNLJzwoPf0rWiRTEQpq3BISk2U9XYsiiPoa56TzLZxg8Hmt2+kGxY165rn52Zm2P2rektLGUyCeZ533ucmrunQQzPiQ/MDwPWs0ir2nq3njb17VrL4dCI7nXzRrFaCP0qFNkUeKf5M0j+W5zUV4oitiW7d6412Og5m9u3aRgnA6VTWaYLt3HFMY5JJqMmu1RSVjnbFJycnk0xqQ5pKokaTTacaZQAhNJS0lMQlJS0lMAo4oooELmikpaQxeKQ0ZpKAFpDSUlMQUUUUAIaVVLkKoyTSVp2MkEGJDgv79qUnZDSuSTWzWVvtcfNIKx61dUvvtkoI6KKzKmF7XY5WvoNxS0tFWSKvUVbFxwVHGOlU6KTVxplj7RKFKg8GhZSSA5yBVelxRZBdkkjAnC9KixTsU4KRzT2AZiinGkxQIAM0uKUCnhRSGNxTgKXApwGaQxtSovcjikC1MCeAegpMCYSbm+YYAqu3LE0880AUloMjxTgtP204UXAQCpo4S3PahIyfmxxU4m2qQBUt9iku4rRgJjNUyMVaaYBMdSaqk55NEbgxKSlpKokUYzzVtEDcqMmqqqznCjNb1nb7cMwrOcrIuKuU4rF5Wy/ArZSGOBeKlkdI1yKx553YkZxXO5ORqkkSz3POF61EuSwNVkPzetStLhSe5q+XoiblshOtZ88o3cVG1zgYqozljk1cKfcmUhXO45NOChhgUxV3HFWgAg4rR6EIpkEcGnxxM56cVZwhGWNPLDZ8n6Ucw7FcRqKs4jRM1Tyc80EtIcDpQ1cLjXYtwKv2sSqPMeokhVVy3WmvKegPFJ66IFpqz//0fY2XFVnq43IqtIMV1IxZUaoSKnIqI1ZJCRTSKlIphqgGHpTMVJim4oEMp4FGKcBQxh0qM1KelRd6QABUbdan7VEw5oAjphqTFSyWzIofI57U7gVMUlOpMUxDTTlGTgU9UyQK07aIfaCAnGePapbsNIpvbSR8t3GajK8V1V3ArQb34xxXLyEbiB0qIyuVJWK7VXerDVWc84rVEMhoIxUgWonNMRC1MNSYqxb2j3JYJ1AyKd7BYo4puKsyRNE5STg0yRVUgKc5FO4rFc0mKeaSmA2gA0/GaeBgZNK4EWKQ04moiaYDWNRGnmmGmIbTafTTTENpDS0lADTTafSYoAZinRlQ4LjIzzS7aTFADpgpcsowD0pFaQDaDgUuSQAegozikMZtxVu2t45FeSRsBBn61W607oOtDBGxb2MrukyjoK3obthiLvTNIv4fswgblgO9PSAS3W6OuSbu2pG8Vpob0cPnRjd2rNvIRtZcZ9BW9H8sVY90Tvrni9TRo5ecLFGR/FVayvo1YpNxVrVRtBZTkk1zB612wjzR1MJOzNZ7mKW5ATpVSa3EbmRuQe1Uuc1YSVjhWPGa05bbEXvuQtHhdx4J6CrFi+y4UnoDVqRYpk2r26Gs7BQ8UXurBsd3aS+ajP/ABZqKdPPgdiOMdK5KG7kgIKsT6itOXV1SAovJasHSaehqpq2pz04TfhRiqzYp0jbmJ9aYFzXWjBjaQ1JjFMpiExmmkU8mozQAgBJwKafSpY5PLbdjPGOaZtZzkCmIjop7IUODTaYhKKWlxQAlFOpKQxuKTFOpKYhuKKdSYoAbS4pQKXFADKKdSUAJS4oqZIieWOBQBEMUU8jBxSbTQMZilp+2kxQIAM07bSUtIYmaMmlxSgUANxSgU/FKBRcBoFPCmlAqQUhjdtOApaKQDgKXFNFOFIYuKKUCpY03Nz0pDEjjZzwOKuPDGiDjmrMWwJ8oxVOU5fOc1ndtlWsgMoC47Cq+d7fWkY5NaVraKy5brVNqKuCuzLYYNNq5Pb7GwOpqMwletNSQmivU8du8nQYFWLe1LEFq24rcA+wqJ1EhxhcgtLVETpzU7NtqWRgikLxWeZNzYrm5uZ3NrWCSUkY7VQIZ256CtEDPBqs2EJ9q0hoRIqE7ORxUDy5GBRM241Eq5roS6szbG09YyanSMbhVxgFAOKHIFErOixJx1qrl24FaPkMw3S1CcJwBxSTBogjhLfeOKtuqhAiVWy7HjirsEDEbjSk+rGkVvs/c1KEVRxUzRlmxmoXKpxSvcdrEU7nGBVVUZzgU8lpX2jpWlFH5fLCqb5UTa7P/9L2dhioJPSrLg1WaulGTKjCoiKtOtQEVaJZARTCKmIphFUIioxT8UAUwGgUuMVIF70hFIBhGTTdtS44pAOaQEeKay81PtprLwTQBUPWmNmpcU0iqAixS4qVFBIB4BpzxFJCvpRcLFiwKrONy7geK3I7YwSFu3UVhQSNE25a3FuROgVj0GM9qxne5cSS9DPaloufUVyRBz0rrI5o4k/nVO+a3VNyKMNSg7aDkr6nMNUOOancAnjpTcY5roRkRN8oquRmpnOTTdtNCI9tOSZ4TujOKU1C1PcBJZHlcyOck1GxzyadimnrTER4pcU4CnhSxoAaBQ1TEBRUD9KQyE1GaeajNUSMNNp5plMQMc44xgUw040lMYzFJinUYoENxRTsUlADaTFPxS7aAI8UYqXbTwlK4yILTthPWrCpk4FbVto5nCnd1qJTS3KUbmTbRyjLxg5Arp9ILhykwxmr0dkkR2AZ4q8tmExKvGBXNUqpm0YWLhIVMVhXcgVxu71dluAgOT0rFvsyKJE5PUAVlCOpUmZmsHaysvI71zZGScV0kg82IeaMY61hMAGOPXiuynorGE9yDZ60mOeKeaYa1ILKkxjHHFV5cODJ3J6UhOOhqPNJILkeDmm7TnipOKjLVQg20cYpuaXNMBpphFPJ9TTGbsKYiM0w0/60mKYiOnqxXOO9LtpQhNAEfJ5NG2pxGBTlUZ5pXHYg20mDVp0ZfpUZFFwsQYNG2pSKaaYEeKTFSfWl4oERhadt4p2aQk0AMxTTTuaKAGYoxTsUoWmIaBU6glcuSFqPFPJJAU9qTGhnen0AU8CkMZim7anwKRuKAIdtGBTiaSgQmKWnClAoGIBTwKULT8UgEA9KXBpaM0DG4pcUtKKAExThRingcUgADJArctrLKbjxWTCm6QZrpY2GzArGrJrY0gio8QRSgqj5HXFaspVck0ttEWPmSDA9KyU2lctoyPshVfMcVdtSSCOgq3dMrjYOBVNmKLtXvT5nJaitZjSyFieppIrWWVtz8Cr1tagje9TysI02ik520RSj1ZCqKvQVOZFVKpb8nnimu+RgVDVxrQhu5uDVa03ySVFcSZbBq3pysZCSOBWihaNyOa7NGRVVOetZMvAzWlcknrwKx2bcce9FNdRyZBsLHOM084QYxVpsKuFquyZGSa2TuZ2I1l2/WraMrck8CsypYkeQ7F71TihJk89xuOEqS3gd+X4FTwWAU5k5q1NJHEu0Vk5LaJSXVkJjiQiiW5CLhKpOzSHK81Hsfkt0o5O4c3YtFhs3E1mzPk4qYDcAtQyw7OnNaRSRLdwhlZPuipzcyMeTn2qGNHI+VfxoZPLBJ5qmlcWp/9P3FkqhIuDWmapTDPNdETNlU8ioWGKnIpjjirRJVNRmpiKiIqiRlOApMU8CgBw6YpmOakAwaaTg0hiY4pVWl7U5eKAG7eaZKOKn6mkdaQzPK0gTOanIqEjmrJECgHnoDSuxdsmkbrQODQBKi9q27e1EqCSHPHUetZayoSu78a6qzlt4kGCBmsajaNIoynRoyQwwGHSst4F3KpPHcdcVq6zKySI6EFTmsOS4d8jHWiCbVxSsRzQQqW8ts+lUGHFWCKYRxWyIKe3vTaneoTViInqLFTlaawxTEQGm4qQilC0CIwuamGFFJ0puaBgeeagYVMTioGOaEBCaaaeRTTVEkZFNp5puKYiVInmAVFyfbvUMkbRuUYEEetb+m3cVtt2puY54rO1Gf7TdNJtC9sVCk72sW0rXM3FBFOpMVZA2gCpAmalWMmi4yILTttWNgAo21Nx2IQtSBaeFqwi7sIeN3ek2NIWyRXnAIzW8t39mO0jatYCFraU9yKbPeSzE54HtWco8zKTsd3azpMRnvV6Vtq7R6VzmmSRmBZZOq8VZutUghYKx6+1ckoa2RspaGVNMfNcSHFQWZ81trHgGsi+eV5S/8OflNQRXE1tkjILd66lT00MnPU6G+gIUhe1csRtYg1qPqbt8rnI/rWQ8gLE+tXTi1oyZNPYYeKjJoJpOtakDeaaTTjxUZNMQhNNxQSKaWJpiF4FMJpDSUwEJpvNOpcUCGU4CpFXvSmgYwCnUlKAaAHU5VBODTRTgcUhgzEqF7Co8GpCc1o6dFE5dpB90cfWk3ZXGldmZLG8fDVX61cuCzyszdzUGKa2EyLFFSEGkApiI9uaTaamwacBRcLEIQ0pjqfIphNFwI9lGMU/JphoAMCikooAWlzQBS7aADdTSc07FGMUAMxRingUYoAaBTwKBinUAJzSUE0maAFzTgTTKeKAHgetOHXios0bjSsMlLUgJNRjmrMKb2AFJ6AXraIZ68mtAeYpCAVXiljhbK8/40gvNzHn6Vg7s1VkbCRxkYk5Iqvczn7qcAVlPdyDgHmpYRLKnPfvUeza1ZXN0REZmZvm7VJb7pX555olCKSAM4qGGVlbbnFaW00IvrqdKsiqu0dqzp33MRmqaXgX79QSz5U56mslS1Lc9C1G8ZOD2qCW45PlioLeIythjitRrdIkCr3q2lFkptoyYoXmf5uproreJLZMjqapqgTAY8U2a5CjrUzblohxSWo+dxisp3ReRyajluC5OOhqv1Nawp23IlK5P5jOcKKe0bt14FAkjRML1qUTjbk03foAQWqMd0nQdqvbooV+QCsd52J+SozM5GDQ4N7hzJbGo93wTnFZryNIeahLUbqqMEiXK5rQMiR5qq9x1U9DUAnIGBUKjc3NChrdjcuxeiiG3fnJ7CnCDLZkP4UokSFBnrVOW6ZuF4pJN7BdI0pJIoosCseSUyN7VE7lutRbsHNXCnYmU7n//1PdjVSSrRNVWOTW6M2VSMGo2ORUzCoTWiJIDURFTmoyKokjxTulHenYzQAcsaRhinDrSvSGRCnUCloAVTTm5pAKXHFIZWYVCRzVhqiIxVCICOaAKeRSKOaYgJpBI/rTwhfpSBeKQFraJLZWDZYHBBNUyuKnjynSri2gkiMuenb3qb2KtcyGqFjxUr1CwzWiJITSYp+KeqUxEQTjNQNzzVqT0FVyOKEDIcUHAFP6VGaoQ00gpTSUARsfSoyKkNMNMRGaYakNMIpiIyKQinkUmKYFvT7hLaffIMioryWOedpYwVDdqhxRiptrcd9LEWKeFzUipzVlI6bYJEaRZqXaFqboKZjPJqLjsR4zyaDinmmGgBoIU8802WXdJvUYprVGadguDMWJJpobac9aOTSGmI2rO/ABhYYBHH1pl6RGgU/Meuaxi+3mo5J3k4Yk1Ps9borm0saIuxKvlyjp0NFx5UkW4/QEVRmVRCjAjPcVU81gpQHg01DqhOXcaTgkU3cTSZpCa1sQP4FNL+lRkk0mKLABamlqCKbTEIabS0UxCUmKcBTwlICPFKPan7aABQMMHvS4paTFADcU4A08LT+AKVxjNtGKXNGSaQDMU5XYDGeKdg0wigAdwxyOlMzS44zTaYF2OCJojK7VTbAOF6U8SDyyh71AaSQMcTTM0UVQgpOtFKBQACgjNOGKcMUAM2GjbipaQmkBERR0pxyaXZTAbupM07ZSYoAAKXFGfSjNAB0pCc0hNNyaAHYoptOFACinjNNxS0AJSUtORCzAUAPSJ2GR3q5CVhBU9T3qJnMabRUALOahq5WxbJ8xiAcAVAcKcA1FyOKcqsxwozTtYVyxEV8wFulbEt5FtVU7Vmm18uMs/BqnmocVLUpNo2PMV1xwOaz5CVc4PSmxZY+1I0T8mhRswbuNJpVxnLVFS5q7E3Li3G0jYMYrfRGkjEj8cVzduFMg3c1vtdqsQA4rCquiNYPuU7yfZ8iishnLdamnkV34P41X2MxwvNaQjZESd2Nq5FCuATyarrDJuAIIq8pI4BxinJ9gihsqRxpkjk1VVHmbanQVZYfaWAORV1QkEXpUc1l5jtcqiFIevJFZ8rKXOKsXFxnhOSao4q4J7smT6IXimk0uKYeK0IDdQHx1pnSkzTsFxzOWOTTGY9qSmk+lNIVw3U3NKATT2VFXk80xH/9X3EnPSoSKlpjcV0GRWaoGFWWqEiqQiEioyKmIqMiqERYp60hFKODTEOIFMbk0ppMUhh0FA6Ug96ft4oAFpx6YoXrStjNIZXbiomqZ6jxk8UxEZHFKgXBycHHFSlaiZSvPrTAPMAVQnB7+9OJ3HJpqo0jfIM/SrsFo0iFu/YUm0gQWrpE2XXINT3F1EDmLgGquCuQetVZKnlu7lXsVJMbjiomqYioyMmtEQMC1JjAoC05uBQwKz1ARip25NQsKpCZCaYakNNxVCGYppqTFMNAEZFRmpWNMIpiIsU3FSGkxTAjxSYqQjFJigBmKcq5pwXNWEjx1pNgNVKl6U7FJipKG4zQeKfimmgCM1G2alNRsfSgRCaZinmmE1QDmkGAAMYqqzYpzt6VCeaaRLYxiTTDTyQOlRmqENJphp2KSqEIBSGncmkIoAZSGnkDFNoAZSYp9KAe1AEeKTFS7cdaTigBoFKTS8mjZQAylwak207FADAtKBT6SkMSkxTqSgBKXOOlJRQIdTSBRuxTDz1NFhgTTOtO4peKYhlJinkjtTSc0ANNJilpwBoAZilwalwBSEUARUtO25p20DrQAylA9afx2pKADgUhejbQFoAZkmjNShfagoKAICabk1KQBTDQIZTsUU8A0wGgUuKeAafsJpDIcUtT+XSFKVwI1xnmtaAxMuOBWXtoBI6UpK407E1y4ZyAeBTBIFQKo59aixS4p26BckQb2rVtljhUsxGayBxzSg54zSlG407F2eYyAkdKpH0pSckBKkZBEOeTQlbQT1JbdGJxnANWJsxKcck8VXguhGpyOagknZ/pU8rbKukhMr1JyaavzHimqGc4UZNaFvaEEs/wCVU2kSlcjaZYhtTrUe55OgJrXt9PjY+Z94j8quJAiuWI49KxdWKNFBswIrOeVtoGK3YLWO1h+bl6kkuUjUhcD6VnNdZOM8VnKpKehaioltYyzE9zUM8SICO570q3K9Aeaz7mbcCc8URUmwbViPzVjHy9arSTNIME1XySc05iOoFdShYwchM0nNITSZq7EjqSkpaBCqik5Y4prKB0OaXJpDTAiNRmpiKdFEZJAo7072EV9zYwKNrse5reTTlHL1aEMarwKydZLYtU31P//W9vbg1Gxqw+MVWaulGTIjTDTzTTVCIzURFTEUwimIhIop5FNxQAlLik708c0ANIwafxil25oxgUhkY4NL1NB4qaBBLIE6Z70MCo/WiNtjZxkZrqY9LgjJaX5gR3rmp0WOZlT7oPFTGSeg2rFpWgcNxhudv/16T7IWtjMw9cYqgzelXItQmjh8oAH3oafQLrqZ6O8RyhrQt7sqp3/hSpJamIh12sT26/WoH8srhOcd+lN67oS0GzSB3JHQ1XynO4Z9KcRxURFUkIiK96bipvm247UwDPNMQ0Co39Ks4quwoAgI4qFhVlqgf0q0Jlc0mKfijHFMRERUZqU03FMCEimkVMaYRTERYox3qTFIaAISKcqE1KqZ5NSgAUNgMVMU/wClOpQKkoYATT8YFPAxTGNICNjTKcRUTHsKYhGaoTzTyKiY0wEJxUTGhj61CzVSRLY1jUZNKabVCGnNJTiaaaYhppMUppKYBntSE0YpQuaAGUbSan2AUu2lcZEE9aX2FPIpMGgCIijbUwQ07Z60XAgxS08im0AJikpSaSgQUlFKOKAExSYpxzTcigApME0uaTdigBNtNK4pxaoyc0wFpDSUUALtFIeKM03NAC5p241HThQA7JpOaKlVRQAwA0/FTBVFNJApXGM20YoLUm6gBcCkpCwphf0osIlzTTUO40ZNOwXH4zQVFIKXNACbakCU0GnhqAHBQKk4FQ7qaWNKwyYsKaTmosmkNFhXHE03NNzS5p2C4uaXrTM0uaBXH7aXbgZpmaNxoGLnByOKCT1NNpMmiwri5zUgiducU+MIi736+lWYnmuH8tV4/pSb7FJFiCGGFdxbJqy0Rkw46VGmnsrF5W4HYVbaZFUIvaueUtdDVLuWUmSCMFvSs+4vwSdh61mXc7H5QarJFuBZzinGit5CdR7IkkujuOOahDSSnimvHspUm8tMKOT3rdRSWhk2+pchTaDvbBqByQuM1W3tndmnO+4AAUcuoXELAAgfnTQ3FNpwFXYm4UoBp4AFPGTwopXAixS4q9Fb7hnqR+VQyx7fSlzK9iuUr00inOyqPeoDJVJEkuBWlYR7X3sKzoMMck1e85Lcbic56ConfZFR7s3JGTGTVCSdQOKx5L52Jx0qq88j98VnHDvqW6q6H//X9xNQsKnNRNzXQjIgNJin001QiM00ipCKTtTAgIpMVIRSEUxEJFPHTNJilFAEg5FI1KoNKRzUjJ7S1+0TBG+7Wx/ZKRjzEJGO1YUckkLbozgjmtaHWmAInX8qial0KjbqU7vUJV/dJnA9fSsUsefeullmsLwENgH8qxbuCOIgxHINODW1hS7lTFKq0q8U9RWhJGRQCelOxQF5pAMIphFWSoxmq7GmgJPPYQGAAAE8moQnSng5H0oFIY0rgHNVGrWjlhDgyDg8H2rMufL80+WcimmJlc9aruOan60sUEk8mxOtXsSVCMU01blt5o871IxUGwkFgOB1pphYhxSGpmC7Rjr3qE0xERpuKkIoApgMxShM1ME9aVsDgUrgR8DgUAUuKdQAmKWlpKQwJqMgmpdtNagCFvaoiKlNRMcdaYiI+9QM1PZs1Axq0hMYeajNPNRmqRI00w080mKYiM0mKl20baAIsUbal204JRcZEE9alCgVIFFOwMVNx2ITijFOPNLwKAI8U4LS5oLAUALjAqJiBQWzTCRRYBhOaYacTTcZ61RIlGRSUUwFzRzSZxSFqAFNJTc00k0AOyBTc0UZAoASlx60FqaWoEBpDQTTadguLSZpMUtMQtOFNBo3Uhj84p4aoM0mTRYLlgyCml81DRmiwXJM5oqPdSbjRYLklJnFR7qM07BcfmlyKj5NLRYQ/Io3UylxRYB4al3VHzRzSsO480oNMyaOaLCJM0E5qOlyKLDuLikxS5FGaBDcGlwaXcKN1ABzSqrMcAU3NXrZkjf5vmpN2GkV3jMf3uppnHanXD73JxioRnPFNbagy9bwb2y/T0rpkEVvGGxyRWNbxNEgklPJ5Aptxdk8H04Fc805uyNYtRRauLrIODWIZ5NxINSKm5C7HPtUbLjrxWkIKOhMpNkTbmOTUqyMBz1pMAUEYGfWtCBh3N15pu0d6mBUD3qE0IBtNpTRgnpVEgDTgaesDEZPSo3ODgUhilqBvPIOKjB556VO08agBBk0MCYM6J1qozlj8x49KjeRpOtR01ETkOJXPFMzRUqIpGWOKrYW5GoYn5atrZTuNzDFatnBDwwGa1HB29MVzzr2dkaxpX3MCOwUAFqWS2iUcVoyJngGkFquNztmo9q92yuRbI//0PdpBzxVYirrgGqzCuhGbIelMOKlIzTMUySPFG2nkUqjtTAgK00jirGMHNI6Z5FFwsVCKAKeRg0qjmmIcgFLjmlAw1SEZqSiErmiSMfw9Km2mlMbFSQOBRcLGYwwaYcmrDr1qLFWSIOmKd3oA5p+zHNIBuKSpCKZjFIYjHAxVYmpXNRHGPeqQhy9KU8UqcDNITnmgCB+lVD1qzIcniq561SEwFWrMut0jocY6k9MVW6VOjypGyp0fj3okCOkvrUXEZKnPHauTuIfJYoDkVpW+oz24KkbgeMGqErpKxP3cnvUQTWhUmmUsd6hYc1YIx1qIitkZsixUiJk5pVXJqY8DApMaI29BUeKfSUAMxS4p2KDQA3FPC4pQKfjPFIZEahbmpGNQO2KaExjsBVV3pXaoCc1aRLY0mmE4pxplUSMNJtqTbTsYp3Ag20YqU03FADMU8LSgUpNIBMAUlNz6UfWiwC5xTS2aaTTadguKT6U3NJ9KKYBk0008A0YAoAjpuaeaaRQIYfemmnYpppgJmkpaSgQhpKXFJTAQ02lpMUxBRRijFACGm07ikoASiikoAKM0VJHHvOCcZoAizRT5FVXKqcgd6ZQAUuBSUlACmkopKYgpKWlxQA2inYoAoAQU7NLilxSGJmnqC3sKbilyQMdqAAjBwDmlxTKXJoAmWNmBYDgVGRUnnnyvLquSTSSfUHYU02ikxVCHZFKDTcU4CgApaOBRmkMUAd6sBlEXHBz+NVt1Ab0oaBM0Gij2b2PJp0fkgDPaqbu74UDpV61sWmALHHrWb0WrLWr0LRl3plBwKyZcsxNbN0iW0IiTrWISDy9KnbdDn2HKwRd2fwpN4Yc9ajC7mAq7bW8ZbdIeB2q3ZashXeg1LeRxvbgVBIAvArYu7yJU2J9MVgsxNKDb1Y5WWiFzTS1NpuSDWliLmjbWwcb5cgUSvBGTsqq91K4xnA9qqkknmpUG3dlcy6Fh7gngdKYzpt6cmmKBnLdKmZdxyvQVVkidSv0602lJJPNJV2JHqQFOetLtBXjrUdWYZQnUZpPyGiuAc4qwsDthz0q1HHLI29U+lWJQyRZzj2qHPoilHqTW9zFCm0jBFNa+81uuBWMA8jAetaHlQogHes5U4p3ZamyVr2NPc1C17uBApfse/7o5NRPbCL5GPWmowE3I//R94Y1EeakaozXQZkZptPpppiE4NOC0wVYTkUmCIXXFRg9qnf3qEgZ4oQETDPIpoHNTgUhUjpTAYetSJyOaQDJp4GKTAkA7UMSo470vFJ14NSUU5cEYC4NQBKuMBQzKwxtAPrV3JsVAuDUrgYFOIx0oIzQBXYVDk5qeTpVbOBVIRGxpg5NOILHikUY5qhDjxULOwG3tUrEVDIScZ7ChARk0zHNOxzS4PWmIZiponMTqx6A0hXAzTDRuBavdjESr/FWYRVpXYYzyAehpkmwn5BgUR00Blf2NR4qVuKaBVCEAxSNUmO5pgGTQA3HFAWpCAKYTQA00gFOApcY5oAOFFQs2TTmYHrUDHFCQNiO2KqO2ac7ZqE1aRLYwmmGnGm4qiRmKUCnhc0HAoGNxim9adQfSgRHS7fWn4xTCaAGmmGnGm4JpgJnFJ1qQJ3NNIJ+lADMUbfWn49KTae9ADPpRipQnrSHA6UXAjxTCKkOaTFAEZFMY1I1R4piIzmm4NSGmGmITim0tGKYCc0Ypc00mgAwKbRShSaYhtJUmyl20XAhxS4qTFFAEWKCKfTTQAyrERQId/B7VDUnmZ+8M0mNEJ60mKewxTaYhtFLSZwaYg2tjOOKbUpfcMdKjoASiiigB1LTKUUAOzTutNAp4DHigYAE8CgripWjCkBTn3oC1Nx2IcGg7j1q7s+Qcd6lSDH7wjIFLmCxmbSeaTaa0WK7NgGKrlKakDRW206pvKp4jXHNO4rFfFKUapgoDA9qkkwSMHtSuOw2KFVHmSc+gqLaGck8A0/zCFC+lTKoYrvGBS1Woym6YNWbWBmbd/OrTR24YLmoJZliGxOvqKXM2rILW1ZolYUy7jHp9algcBMtwa51riRj14qY3bkAA4FS6TKVRFu8mL5weRWTnJ5pXkLE470RRmQ4Bwa1jHlRnJ3ZfkeKNFWPr61WEpJyTUD53EE5xTeaFEHInkYFs5qLdTee9Kqs5woyaqxNwJoVQTycVP8AZZ9u7bgVWIIOKFrsG245gu7C9BSADvTQCelacdrGIdztye1JtLcaVyi7rnpnFJ5jkYpCAX2pz6VfhjWEb5hz2FDaSBJszxG7dBT1hZ+ADW1CqmMySEAHtUweKNPlGazdV9i1TKUOnArl6VbWGOX94c+1Ry3UjthOMdqos0hbLkmhKT3YNxWyOia5igXEYzisqRmuWyvFV1ld/k9a3Y4YoI8t1IqHFQ9Sr8xhNE0fK5zSpbuzAv0960JJokPAzT4naY5IwtXzu1yeVXHrMsSYB5ximx2vnZklp3kq0g29vyouW2rsDYNZeSNPU//S95YVERVlhzUTCt0ZlY0lPIptUSNFPDYFJjvTc0DHM2ajNKaaaBDhzS5pqmpdueaTGIo5qQpxSIMGpu1JjIACKcqF+B1paDxyKBkLqarE4NWHJP1pgjDc5wfemhDe1Pxlc03GODTgaAIDE7glRnFUn44rWjZslE7/AIVlygFuBiqiyWNjDpINpwetbT2cMsIMWNxzWEiSMcoORU3n3CHliDRJN7AmPxawyFSC316VUk+c+Zj5emB2prZJyavxNFGocjI6EU9g3MkrU8VvO7YRSa14ooZ5V8lQEbqT1966JI4kwI6iVWw1C5m/2SktsP4Wx1rmLyzmtX2uMjsw6V6EOUwDVZkjb5ZACPeso1WnqW4Jnn8MTTP5a9anlsZooPObGKsXccVvcF4TioZL+SWPy5VyvtXRdvVGdktzPeMbd6sCPTvUQpSMUg4rUgG9BTgNq5pAO9JIG2hj0PSkBGTmlA4yaaKkxxzTAaKa1SVA7CgCNjVdyalJzzUDHNUkSyI81G3FStxURqhDKULT1XNDHAwKYDCe1MpcUUANo6dKCfSmEk0xCE9hSYp4X1pwTNAEWCadjFSHjpQEJpARHmlCE1ZWKnFQtK47FcIBRtqXGaQnsKAIWGKj21MR61Gx9KYDCKjNOJqJiaaQhrEVGacaaaoQw0lOpppiENNNOpMUxDaApNSYA607NK4xoT1pcCndaKQxvFNNOJptAhDTMU/FJTEMxSYp5pUjL57AUwIqbWstgrIJA3FU7iJYZAhOcDmpUk9ENxaIGXjdVlrQRw+a7duBUBI2YXNMZ3YbSSR6U7MNCGkqTaR1oxVEjKSpMUmKAGUYp+2nbTTuBGBUqqKAoqQYFJjHCMU/Yopm70pQ1SMkAFOAA61Hn3pCx9aVhljeF44NDTMw29qq7wKQyelHKHMTbhTd1QeYaQk0+UVyffSFxVck03Jp8orljfzxTwjSNgnBPeqm7FHmNnOeaOULmnDbx78uc4P4UXciIeOtFq0s4C4wOmafd2bMwFZfa94vpoZqPuJdjyOgpwtJ5PmxjNa1nawxNubmlvLkRfKgpupraIcml2ZUln5MYeQ8mqJIzxVmeaV+JO9VK2gnbUzk10FzU0aZy2cYqNUZulP8mULuwcU2JDC3JNSiYBdoH41BjmrMds7thuPWh26gr9CFVZzheTWtYW8gfLDinwxW1u/3s561qh40UbcVz1KnRI1hDqzPvmkQbV5/pWCFdzgDJrqpYfOOD3qeGzgiwSBgVEKyhEqVNyZz1vpk8xB6A1qyWdvBDgncfer015HCDs4rn57kyNUqpKox8iiik7rHJmPt0pFd5ZAXNMZfmOacSqjC9fWuyxz3NhIWl+dj8q9hVOYNvwG4qJLlwuDThMu2s1FpluSaIWYRnCHmo+T1p/3jS8CtEQOiwpz3rRQs/MnA7Cs4F0+YCl812OTUyjcpOxrSCEr0zipY2jKfNwKzUDuMJSvBNnGDWXJ0bL5uti1LdRr8sYqlvEjFmPFK0DgYZTR9lcjNXFRRLbZ//9P6CkXniqrVoSuD8yjBqk471siGQMKixVgiojVEjKjNPNMNUIB1prUucUlACCp1PGKgpwNDAmVueanBBqmDUqvipaKTJiKQ0qtmkIqRkLDmmnFSuOKgNUIOMZqMk4pTTc4BpiISxqu3JqZuajIqkIajGNg69qknlSVQf4qTHaoiKLdRCNg4Iz07+tRnIqSmNTAuWd2Ivkccdj6VoWpmmkZ45C23oM9a54irNrcPbSB1OPWplDsNS7naCRYx83BPWoJp4YxuZuKwJNV85wrjKZ70kqWs65jfb3NY+z7mnN2JLqaxuQEHUntVSfSXji3xuCQeBWO3ytx2NbcJE0PyvyevNbOLjsyE77mLKS2FYYK8YquanmjaOQqxyRUJ5+taozY3cQcipnuDKAjDAHpUJA4x+NG0inYDZgj00woXI3Dr2qK6exYBI+v96s7GFquxqFDW9yuYmudiEbDwaoE5qdjGU75/SoME9K1iiGRse1MJAp7AqSCMH3pgG47e56VQiE80AZqWSJo2KN1FMJxwKBCMcDAqKnGmmmIaaYTmnGkxmmAzGakVKcFp/Sk2AzHrR7CnqpbpVlIgKTY0V0izyasBAtSHC1Gx9am4xjN6VEfU08803GaYDDk03FSMQtVmcmmhAxqFjQWqM5qrCEJ9KjNPOKYfaqENppNOptMQ00lPxSYoENxS0uKOKBiAU4Ad6TPpTc0AOJA6UwkmplaIKQRkn9KrmhAxaTNJRTEBJptLmkzQAAZ61KjFVwB1oRkAO4ZzUe40hkpml2lBwDVcgk807JpKaVhMbTkYo25etFJimIViWOWpNtJzRRYBcCkwKKM0AKOKXk8mmZNOosAhopcUdKAClpM0lADqaTRg0hBFABmkzmilAHemA2kJPapMLRlRQBF8xoCO3QZqUDfnHatGNo4IgSRk+lTKVhpXKCWczdeBVqKyQSDc2afPeKUCqOaoGeQOrnjHapXMx+6jYkuI7QbVHzHsKy3u5S+9jnNQzTmVi3TNQAE8VUaaWrFKfY0BfkHOKswI87iWUYBHf0rNeHyWAk69SKvrJMRiMZ4wKmUV9kab6kV6Yi2F6jvVOOEuwHarS2sjNmT16d62LazZ3D4wvvQ5qKGouTGw20USfKPqTTJ90q7UXAraeNI155qjtaRvl6Vyqpd3NnHSxlxWUa/MwyaimLhsRCujECBfmNRE268Zqvba6i9noc8thcP85OM1tW9oqYaZskU6SZcYXpUaTx555olUlJAoJMvsyjkDpWfcXTcqopJrsD2rKmu2Y4TiohSchymkNmkb+KoEcBiSM1GST1NJmu2NNJHPKbYMMnNJgUYNGK0IEozilwKTAoEGTSg4NJingCgCQzOyhOwpiqWNTRReacCtSOxCjJPvWcpqJootktsoSNTjJq6AR8zCqm9YeBUg3ycdBXJJX1N1oSMvmNgVBJA5bAPFaCIEGKY7RoKz57bF8tz/1Pohlqu4q21VGrVEMhK1A1WiKgYc1aEyA0w1IRTDVEjDTaeabQISl6UtBoGNpQabUgHFDAcrEVYBFVehqQc1LQ0SSH0qu1WMd6iZc0IZA3NRmpmUioiKaJIiKZipmFNxVCIzTKkIphFAEZFMIqXFIRTAgIppqZhUVMRHjmnElRgcUlI1MCBvWmgsvKnH0qUioyKYhrEtyeTTMVLihUJNMBoFPx3NOK0j9MUgK7mq7VZIqB+OKpCZCas2l4tq5Zk3/jVVuOKjIptXVmJOxYup453MhXDH+dUMkGpDTCKpKwmxrMSeeaZTjRtIwSODTER0081b+yyupkQZX9argZ6UXCxHinYqdIXf7gJphBBIIxRcLDKkSMsealjhOcsKtqqjr0qWykiJYwBSkgcCnvxwKhNSMaTUZHrTzTeB1piEx61E744FDvVZmqkhNgzVCTTmbcc9KjNWkSIT+NNJzTsU00wGGmmn4oxQIZijFO6U0mgBDTaWjbTAaTmkxUwT1pCKLhYhxSc1Lg0hXHWgRERSGnkUmKYEeKTFS7aAlAEWKMVLtox60BYixRUmBSgCgCMClxTz7UmCaAIyKSpdtGBQBFikxUuBTSKYiPFJinGm0AGKXOKTNNJp2AXdSbhTKSiwrjs0uajpKdguTbhnmlcnPI61ECAcnmp5ZzIo4AApW1C40I7HpjFRknoKDI+MZ60iEg5xmnYLiZNGasi3Z4zK5CgVVoVmDFzRmpEVGPzHAqJsA4XpTEGe9Kx3HNNooFcKepKkMO1CqWqWGB5TgUNrqNFsRNLiWQ1rRIyoFxj0qvAgUiMtuxWuZIvLyeMVx1J9DohHqVoY183c4q286j5VqmZQ+FSo2JQEnpWTjfc0TtsTSMZOhpwSRRxVGK6QybQQKv8A2hG+XNKVNoammQTb8dapFWzmtOVkCjHJNVAY+hPNTGLByRVk87GR0psMZY7icAdamuLpAuxcGs1pyRheK6qdN22MZz1LF2U6Cs+nu4IAFREmuiEbKxjJ3Y6k4puaKqwrjs02nACjFAhmKdilwanWCRiBjGaGwSIQuTgVdjs3bGeAauw2KIQ5Oa0VeNOornnW/lNo0+5BBYhG3E1cYqgwBTRKzcJTG8xvauSc23qdEYpbFdkZ2+VeakW3lJy7bajecpVVppnOFyaFNg4o2fMijXBOaqSzIfu81niKRj85qctFGuB1qGikf//V+iGqA9asmoWFaohkRxUD1M1QGqQiE001IaaRVEkeKaaeabTENpDTqTFACU8dMUyloGL3qdCAMVBS5IpMZZLCgiogTT88VNhjGHrUG3nNWiMjmgxnbk96LhYpMKZirBUZxTdmKq4isRUZFWyvOaYV707isQAU0+lSGmYpiIWFQkVYbpURFUhMixTSKkIpAM0xEZHFRkVZdcCoTQAwLUwXihRU2AFzkUmxogK1A3Jqdm4quTjOKaBkUh28VTZjuzU78nNRbQTg960RDI+XPvSSIUODj8OaleMoP61GFZyEHJPSmBDirMFhc3JCwoTnvXXaZpsH2P8A0hPn5JzWrFtj+VRj/CueeItojWNK+5yMekfZF8y9QsR0A5rOujHGEManYQeDxg12GpTKkTFziuPiuXmYQy42HI/OnTlKXvMU0lojPEso+VWIBoCYHPStSC0txNsmYjB/So722CuTD90Vtzq9iOV2GDEEqNbNu4ywpDFJcStKqde1Ng3ICfWtFLx402oAKl3Ww1qU9pj+VhyOxpjbh14qSV2kYu3WopJHc/Mc0ICMmozzUm0nrTGwKoQw1A7YpzvVVmzVJEtiyMCflqAmnGgL61ZIzBNGBTzTDQA002lNJ1piG0mDUoQmnbQPrQMg2k0bKshCacEApXCxVCU8JipjgVGWoAYV9ajOKecmrUFqkil3bFDdtwtcpxo0sixr1Y4onSSOQxuckcVZVFV8I2GHQ9qkktJMedKwJJ/OlzajtoZyIDnd+FKY8HFW9qq2401uTmncVgtDDHLunXK1NdPabSsI6nIqoaiNLlu7jvpYYT6VGc1IcU0kVoQMwaeBTd1LkYzmgB4ApTUXmU95RsAx+NKwXAioyQKHl3LtAxjvSKoZSSelP1AaTSE+9N2sTinFcKMqc+tMRGTTSasLG5GSMDrT4rOWfJHFF0twsynTa3mtYrUDJUt/ET/SsqdkaTaigY44ojO+w3GxWpWQqoY966PT9PjmjO5Qcd6zr2z8hiWb6CpVVOXKDg0rmVQMd6eUOMik+XtWpBZt7ZZFMjnCjrUEvl5/dk49DTvOcR+WOBUNJJ3uwbVrIOKkaQkAKNuKYAScCrIs7nGdhobXUFfoVyzkbSeKVVB4P506MIZAsvAHWugthbSApCgOB1qZz5ehUY3MKMrG/K7s0rwtIxcDC1pzW6wAykD2rLeaSRsHgUoy5tUNq2jK4Uk4HNWFtJm/hqzFPFCPu5PrUjXjTDaPl+nWm5S6ISiupSMQA68ilSVo84phVgfmo256VVu4iwly5ODV5B5w+9j1rK21YVXQbhwDUSiuhSk+ptoIreHk8+tY1xcs7FVPFMfcw+ZskdqgxUwp21Y5T6IFJU5HWnb3JzmnEJgc803APArUgd5smMZpxclQoqPbjrS5xSsguNK03GKkzmjGaYiMBf4qacHpUu2k20xEeKkSLecZApQKevtSY0PEaKDnk08BduAKQDPXin/KOnNSURogVgamZnPT86QK8jbUGTWlDYTYzL8v1qJyS1ZUU3sVVklA+U9aULk/O1XGgiU8mlRYycBay510NOV9R8AcnC/nUxRv4jTGLIOeB7VXWSRztRSxrJxb1LvbQleFGGRREmBg1cFvtTMvGe1VJJ0ThRWfN0Lt1GyRpiqRiUnJHFWtwb5j09KlUxsckcChaag9T//W+ht1MY05qjJxWpBG2aiqQnNMNUhEZFMNSGmmmIixSYqTFJTER4puKkPNJimIZijFPC59qAKLjALmjHNTDhaj71NxhinH1oAzTm4oGA5FOOQvXioc0/Py0rAQN14pw6Ue9LnimIibrUTA9KmPWo8HNNARbDQVwKt7cDNQSCi4WKZGajIqwRioSKtEkRFKopTSHimIjc5qPFSU2mhAOBmntG/HvUfJ4pxBB5OcUDIZAVJB7VBgtwOTUzAseKv6fADcBXO0n9RQ3ZXBK5nratuAmBUN0NdBbaRYS/PgnHbNbN15MUGNoIArDfUTbDdEQy8ZUcYrDnlPY05VHcvXFnbzReSqBcdDWBqOlx2iLLb5JUjPf8abJrF0zlowFHp1p7andSxbtowOGqoxnETlFmtZTu8KbiDuq1JvHyjisS0zIgmDgbM4A7VG+oTT9GCDOOeKhwu9ClLQv6g6S2rI6g545riWUxt9PSuyvXhFuEYbsjHPr9a41wSxregtDOpuXLYxMJHnbnHA9aiZ2chR90CqygZ5qZenFa26mdyUUE0AcUYz0pDGHmkx3NTbcVA7UAMZsVWdqczc1AxzVpEtiLy44zV8acnl73kAJ6Ac1Si2qwLE474qSGTy5fMJ49+aJX6ArdSN7YxE7zx2qqa0r+VJXV4zkEVmmnG7V2J7jKYTTzzTkQE/PnHtVCIQuamCY61IAB0pyoSaTYWIwueBUojA61MFC0xmHQUrlWGHioWanmm7aYiE5NG2pwmelP2qvWi4WKwjJqQJgYJ4NOaQDgVAzk0asCxhUUOO/FRyXDOACeBVYt6mmF6aiLmJi1MZ6gLmoy1Vyk3JGf0qItSUmKqwrhmmk0vFXbGJZnKsMjrQ3ZXBK7sUOaOla2oQJFKNnCkdcdazYow8gQnA9aUZJq42rOxHirBaJlVW/h4p8kcUSspyWPSqwBU809w2FkMZPyDGK0tPngT5Dw7fxGqaJGyksOTSAxo2ShIPSpkrqw07O5eu7mGFjHEoJPJNXtMdZopPN25Pr6VhXKqQJACGPWm27yKSADj2qHTTjoNTszq3nt3jMagfL7VmRQTCQsv3fSslbuRT685q4mrSqMMuRUeylHYv2ie465ijXcZclj0FZiWsrnpj61JPePK2QMUJeSp2B+tbRUkjNuLZqx3P2JPLXrnr1qG6JuASy9Mc1l+bvl8yQ+9WJ73eu1ehFT7Ozuh8+lii2VGwNmoqcTQFZuAK3MWMpyqDnNXbOCNn3TfdHatp7a2CGVRtrOdVRdi4029TOghaK38xVBkPT6VbFxePCFChTjGTVaNZZJQIzkCtyeOJIAWb5sdKwqSs9TaK00OXks5A2XIBNaMKC2h/2jWdPKd2FORQk8jtyelbOLa1Mk0mbbyo6BXGRVJ4YkyzAYpVillAKmrSQJjZOetY6RNNzHJM52xJnApq2s6vtAwRXThIIl2wKMjvWRdTyq/IxVwqtu0UTKFtWZjxsp+c0RxmRxGvU05pHbrTBkHI4Nb62M9C68KW/wB85aoXYzMFTtxSKrynHJPvV6ONLZxI5/Cs3pvuVuUzbzKMkdagKEHnrW5LcK+HAx7VnyAEbu5ojNvcJRXQpbfSnheOalx7UhBq7kkOKXbUmDShCTRcCLFHFXgQMZXgUwoJH4GBS5h2KuBS4zWrHDCDgrn605bJN2WPHpU+0Q+RmUIyegqdYHPRa1vLAXaiZA70BjgjpUOq+hSp9yrHZbhljUy2C4PB+tTxHHLHOOwrQBRo8jmsZ1JI0jBFSzt1gy7csakm3v04pTJs4VaqtJKx5FYOV3dmqVlZDxboOXOTU6Ko5AwKr+aqD1NVJbmR+FFHM2FkXZp489KgN+sfEajNUMSN96omUrR5AW3uZ5upxURRBy7ZNU97A8VJGCx55p2C5ZBUdOaUzkcAAVIseRwoFPFvzluaQH//1/oMmozzTzUZFbIzHKUHUcVHKUzlOlIRTadgGUhp2KQ0xDDTKkxRimIjxSYqbb60wigBlOUc0uKXp0oGK1JijOacKQADimO2aVjUZoAVealI4xUanFPJ4zSYyBuDSdqceaacUxDKcq5NKBk1MgxzQ2CFPC1VfmrLmoGGaSGysy8VAwq254qq3NaIlkWKY1S4ppWqJIDTalZaZimIZ7U/GBSquTQ/WgCu3HSri3UKxgyKWcd6rMKhYdqGkwvYtz6ncSDaD8oP+RWZtdsuOnensKdHKYz0yOhFUkktBN33I1IHBGec01zjOO9OJBORxTGFMRACynKnB9qQEhtx5+tOxSYqgL8moeZbeSUGfX2rK571IaQLSUUtgbuNC81MoHeggKKbmmBITmngY5pqjuaeMYyaljI5GwKpualdsnNV25qkhNkR5pm2p9vGaUL3NVcmxBimNUrEdqhNNAMJpqqXYL607FKAR0piLU9mbQr5pDbh27GoCwKBAMYpWZ5Duc5NAFT6j9BFWpeAKTgU080DEJJph9BT8elLtoERhadgDk0pIUVCzZoAc0mOlV2fNIzVEWq0hNjiR3qNn9KaaSqsTcaTmmmn4ppx2piGUmKd9aKAG4o9qWjFMQ5EQ5D8VZjljRRs+ViecVWJ3duabkg5FS1cd7DpnlY4ckjPGaiVGPKinks33jUiyoiYC8+tPZaALCyo7ecM8d6uwRwSyB2IxnoaoAPcyYQDNTywJbxiQON/pUSXTqUmdXJNaRQ8bRjiuVvriGRwYuPpVF5JJPvE49Kj4qadDl1bHOrfSxpJMk8flSkcDr60tuI4iJHO2M8ZPes1WCnJGfamsxb8K05OhHOb0tjHKwa1+cetZ0tjMr7EG76VHBeT26bY+Oavx6mUHzJknvUWnHbUu8WZrWrqoZ+M9qrEVs3rJ5ayq3zMM4FU7aSOL5pQDntVxk7XIaV7FVIJpBlFJHrir9tpc8zfP8o7mriaqi/KqYFTLfqo3Kc9zmolOfRFxjHuNi0iFAWc7z+VVblooB5ezafah9TmxgAVmuzyvuPJNKEJt3mwlKKXum1pcETEvIR16VavLZSCT0HQdqwYEnDgpkVNJeStlGJOOKUqbcrpjU1y2aL9oitkHKnPap7qOBU2scmsRLqVT14q9bQzXXyjn3NKUGnzNjjJPRIoJAsjkJwBUn2eRWzGPzrSl094gFdwvripYoYEXgl2HOTTdVdBKHcz4Wud2CMdqvfZWd1ct+FVJpLjzSFHXiljW+6jihpvXYafQ118mBiScms2+uYX+UL+NMkilZSztzWaVOeeamnTV7thOelrD1QSMMA4rVgs0VNrgEmqMDKgO7iraXe1Ng4PrVz5noiY23ZIYI4zheKhdIpG27sGnNKmAc7mPWrENtGRvbqai7WrL30RkMMMRnIoYhjwKvTRwpJ061AWXJwtaqVzNoh6dqMZNSbWIqVIWb2p3FYjEftkU9+ei4qyDsG1ORUsahyN1ZuXUuxnrCx7VKtu+cYIra2gDCgCgqoGSazdYtUzGaNozinIWzk5NaohhK7mFQSXiR/KiAUnWW1hqmxgnJyvQYqBbeSV/lBI70rXkhOdgNRPqNyo4wKj2ltkPkvuzVSBIkw+CaaDIx2oMCufa+lLZc1Yj1FsVF29WVobyx7TzyfWq8sbMfrWetxNL0OKkKuwxvyamwyX7Mg5ZuaYyxetMWA9GYk1ZEMaDJGTVWArFRjABNRNZyuMgYzWpGJCcxrgU9kbq70noCMMabIT8xxV2OyjUctUrxg/x0wIgP3iapXYtiQJEvfNPDJjgVCdoPtQJEXqarkJ5j//0PoIjHXimkD1pxyetNxWxmNIFMIqYAUu2ncCvtJo2GrGB6UUXCxB5ZpdlWBn0oK0rhYqlGphQjrVvOBUbGhMCtigLnrTzSVQhpA7U3mn7TQeKAIjSYp5pKAG4oLZ4oOaZQAGmGnZpppiAEinh/WoqKLBceTmjtTQM0e1AxrjIqArzVkjim7QaaYioRim5qZxg1EaoQxhnpR5ZxT161cVNwyaTdgSuUgm0Zquw5rSkA6VTZKaYNFVxiq5q24quVq0QyLFMOKlIxUTVQiOkNPxTMUwGYpSOKcRQKAIgtGMc1LjAqI0xDTyadjFCjJpScGgABpHfjApuajaiw7kTc05U4yaAMmpwOKbEQGonbPA6VM57VXNCE2RGm4p+KMd6sQzFLgU7FOC0gGhaXFSbaNuKVxkeKTGakIpOlADcYpjMBQzdhVdjmmkFxGbNRM1ONRmrsS2MJplSbaTHpTJGYpKlC5o2r/FxQBDimmrsFubjOCBik+xyF2QEfKcHNHMth2ZR60VNJF5bbMgnvimYpokZijIpaTimAnJowaCxppagBSDTMUZpOTTsIkSV4yShxkYqMnPWjBpdpNFguMoxU3lml8ui4WK+KcI8qTjpU2zFJyOBRcLCohdQg9alaymPC/MR6VCindx2rptIMLoxYDzM1lUm4q6NIR5nZnNtZ3C9V6VF5MhbbtOfSusuZiJNgXOTTWj8zDsuD0qFXdtUU6S6M5MoQcEc1KY24wOtbN28aKYyAxPcCs8yrj7ozWim3rYhxSIkgbBLKePyqxZzw27EsuT61FJMzqE6KKiwKbV1ZivZ6GvNexSDagwfpVGWxnOGVeD+dQBtvK9fWphdTdAxJqFBx+EpyT+Is22lM43zHaPSt2IC3h8uJeg4NJbyrNEFXqOpNRSPtB3sPwrlqSlJ2kbxioq6KcsbSSAyNwKmYRxAY4xSxlBl2GfrUVzIzIMrnvxVLsD7jJJowRt5PWgSNOuFOM9qfDbLJHumGD2+lMKDzCEG33qtNidSB4/LjKSPzSC2C2/mcHmie2b72c1WWWQLszxWqV1oyHpuR9+auRrCV3NwR2qpgnrTgpNU1chMuRKnm7gBj3rQluFQYHesgK/vTgOeazlC71LUrEssgY5UfjUOCxyasFVGMUqqCcU1otAepEq54xTsdqvqI1GcDimMAwLgip5x8pTqaJsNjGfSmsjDlu9LHuDgr1pvVCW5ZdnB6Um8OfmI4psrnOF5qOOIu3pUcqtdl310L/mCQbEFRtbIq7n604bYhnqaZ56sx31i4X2NObuU3jduEHFU5LcnrWoZWdtqc/SkMBxlzimodxc3YxxYF6sJp6xruIq7v2H5ec0ySR34NaKBLkRxhVIAFXMAj5ajjtZDhmHFXiYo0wRUzcVsON2QLEmeealKhevFQ+e5+4tNKyycycVky0OluAowpqiRNK2Sam8pAeBk08Bgc4xWkYdSZSI/JKrlqYdw68U6RmzjNREk9a2jEylIdJjsc1FinhSelTC3k6niquluTZs/9H6IMdJsrQa2kHIwaqsWQ4YVomTYrlKbtarIlXvTfNFO7EVzmgZqUsp7VHx2NACb2FIZCaCCe9REEUxClqYWpMUlOwCE03NO20bDTEJupvWjaaMUAGKNvpS49adjHSgCIg1GRVwwTEZ2mq5BzihMLEOKSp9lNK4p3FYhNAFSYJpSpouA1V701hzxT8U3BpDGYzS4wKeBSMRimBUbk0wrjipjzQVqiRiLk1a7cVGoFPzUspETDJphQVKRSgcUAUZEqq4wK1ZFGKz5RVxZDRSYVERU5WoTWiIZGaQDmnkUYxVAMb2pnSptpNMYYoAjwzHA5NIyMPvDFSKWQ714I70jO7HLEmgQ3oKjPNSHnmo6YEZptPxRimIaq81I3ApwWmnmkMrNzyaiIyassBURFUhEW3NLipQOMUu2i4EIWpQhNOAqcLxSbGkQbaYR6VM3NRsQKQERwKgZqc7ZqI1aRLYxjUeO5p9NqhDDTcVKEJp4QUxFbaacEqcqB1qJmzwKAGMwH3agPJqXGaXZT2ERKrA5HFaMU8UMH3d0hOcmqmP7tRtge9Jq+407EbnLE+tRmlJpnJq0iWxCabmnYpKYhtJTsUmKYDcUvFOxRigBBUgIHWmBT2pwQ0gHGT2pN5NLspwjJpaD1AuSu3tTMelTeSamNsyAM3eldIdmV4iVcN/KtRBEjCWME59O1QRRxMSCelb0FvEI/lGaxqzSNIRZFbnzAXfFEoR0ILYPbFIxVWKkYNOtrXBLS//AK6521uarsY09hc8Mo3A0iabPkGVSoreluNh2qc46ComMjDdI2PaqVeVheyiYstvDDIFOcVUm2bv3Z4rVuGhf7/bvWUwjMmAcLXRTberMZq2xCeetORtjBsZxVx4I1ClW6+tVSOa0TTJasXFvpFyVAGaaLlyfm5qoBTgKnkj2HzM0DcvtAAAFNMsqnfVSpEjkkO1RmlyJD5my6t8wXbgVC8zPyOMelLHb4fbLxQwKAoOhqVGN9B3dtREnCc4ycd6g+8ckVIsZPOM07Yw5xVaIWpFtHapkUZz6UAGpcEikwRcQox4wPeqUq4ckc04JzUjoq8DNQlZlt3RXANOAxU6KMgk4pxEe7kkincViCpY5NowRTnQDlQabHGZHCik2mh6onEbTEYFTtAq1OTHbR7c81R8zJyTXPzNvQ15UtxzwY5UAUqLt/8Ar1GZA3BJpcqeBVLmtqLToSTYccGqflMRwK0TCiKCTTTPEgwvNJTtogcb7hbx+WuTxUEkYdid3JphuCT7U3zcHIFNKV7g3G1izDDHF8z9aZI+W+UZqB5Gf1NCiQ9BRySbvIOZbInLyYwxxUbOG+6elOaEkZJqoRg4qowiyZTaLyONuFPNQkbmOTnFV8GnKF/iNP2SWoudkgkVMgUolPpmnrAG57UFFHBPFHuj1IQrSt2FPNsR941IAqnKjNDTMTihyf2Qsuo5fLiGepqNpie1OAO0mq3NJRu9QcrbH//S+peajdEkGGFVY5XH3mFKZtx44osFxj2X9001LcxuQ67gaux7yevFSkgU+ZhYqGziPIFI1nCR0q3uPpSA5pczCxktYSclWGKznVkYqeorpzxVeeKMruK5NUp9xOJztJWg9vHnKnj3qPycGtOZEWKVFWhG3pSNGQcEU7hYrUfLUpipvlMaLgMGKlBHAbpTkVU+YjJ9DV2Ly512suPpSbGkVhK6k+WTg1G8bs2TWulpCBnFIbWPJwSM1HOiuUxvJNL5J9K0ntZAflINRFJVHIzmnzCsUfJpGiAqwzbDg8U0nNO7FYpsAKiNWpEqoVNUhMjOajY1MRx06VCQKtEjcUopQBTwKBCYOeKMGpAKa3FIojNOzimcmmOcU7CuOdsiqMgNWSc1EVyKpaCZSIqIirLjFN2cVaZBVxRjNTstR4xVXFYTtioSKmxxmomoQMbjim7akoxTAiYYGKjxVggU0rQIrkU5VpxGDQKYDiMVCwqQmozzQgGleKixmpz0xUZpiEAoAJNKBTwMcUDGgc4qQnjAoApW4FSMgbgVWY1M3PJquxq0iWyI0mM08DNNY9hVkkRpQnrTwKdigBmKOnTrT6ZgngUgIWyabt9asbcfWkxjk07gRBMUhwOTSs/pVdmJppCuDvUByTUm0mg4HSrRLIdvrSYqQ03FMQykwafijbTAjxQAamCU4DFK4EQQmpBGvenZozSuMUYHQUnFFMJpWC4/cKTee1R5walEqhduwU7BckjliCkyZJ7AVFJOXPfHpUFGKOVbhzEhcHG0YNaFjeNASXYnPY1l4qxDncG6YPJNKcU1ZjjJp3NSW7AkLmtSCQXEf7sFvU1gPdJk5QEGtrS51MJZ8IgOMCuWrC0bpG8JXdrkcun5bdvwfrmnG2+UbpMnHNOkdcmRMtUnEnyL949qx552NOWNyk6gZj4xjrWU+BJsQbz61uy2+FPnMPpUFtCgn3JjAFa06iSuzOcNTJMTq26ZeKVJkR/lUFQK6CQ20fUb296qxRo0hbYvPOKpVk90L2dtmYjsGPyqAKERm+6CceldD9mhY5kUAe1JKjxxn7PHtB4zVe3WyRPsnuzGSIkgNxW7EkccICjr3rIMZifMhBqybiSYCJBgUVE5bDg0hf3Zkw3NSSPE42IAKeLSGMlpGLcUhEZIwvA4qLp7FWYsaptx2FV5NzthV4FaEMaRjJFK8jZwBU8+ug+XQoRWsj9eB71Y8iJflzk1diB2bnP4VC8jJyq4qXVd7DUFYiNtz6U8xhFzndSGQycMcfjTPMMa+tCcmGiIGVC+OeameGOLnBNRHn5y2DQ0zkbc8VpZvYi6HCUjK7ahUsGyvGakj5yWbFPPkBsHJ+tGwbivtAw3JpFizwF/E0PKANsSj61DvkbgmpV+hTt1Fddg2nBpiDnJOKe0QHU1EODWi2IZaB3f7WKhKvg4GKk3SBdwGB61AWY9TUqI2xgAHXmlABIxRikwRWhBOHYcIop5dgMkc1ArsnIppJPJqeQrmJSzsuRUPGPejFABPSqSsJu4hJPFNqXy29DQInPandCsxBIyjANNLE1OIcDLGmbOeOlSmh6gsrBdvamqpdsA81NmJRjG6mF1xhVxR6IfqwJdPlJxQojxuc5qM5PWkxTsK5//0/ptBCTnINK8UTj5Tg+1PjgjRMYzSGGE8bRRcLFEieNsLyPaoxeMOp5q3JaHYfKY5+tZz29xH85FWrMl3Rfju8kB+Ae5q4HU9DWAZ5B97B+oqISsnK8H60/ZhznS7uKYZVHDVgfbLgfxUv2+YrtbBzS9mw50bm6I9hULiE9RWV9rKj7pBpDeliM8UcjDmRcZVzhTxTGiYc1F5wwCwwDU3nAfKx4NOzC5EAO9Pwn8JIp7eV/Cai2selAAVAPPNOgi3NuDbajZJByQaaM9RQBrxkjgtuFPye1YqyMn3TirK3rgYIzUODHzF4s3Q0uBVM3KuP7ppgnbOEO6lysdyd4Ec/Mo+tVXtEB67RVkyyKMlKrvdBuNv501cTsU5YJGOEfcKreS+dqgk1dzzkcfSpY2KNuFaXaJsZUltODjaar+WwODxXUJKp4aqs6Qlsgc0Ko9mDgYflmnJBI5+QVeKj0pgBByDj6VXMKxUkjlj+8KrFs9a0ZFd/vEmqzRU0+4mioWIqJiTVkx4NMKirTJIMnvTGY1OQAKgI5poTIjz1pwHFLjFG7ApiGMM1CUq0hGafJCAu4EH6UXsFjPZcVARVthUDLVolkRFNNPIpuKoQCl4xmkpcUAQtSU8ikxTAYRTcVIRSY4oERkU3FTbaAvNFxkWMU4CpNtIBxRcBFGaY9S9Fqs7UIGV3NQkZqVuaaBWiIGdqZipmHakC5pgMAoxk0405VNIBoXPApzAKMCpsBF96qu9Jaj2GMQtV2YtTiC3JpCKtIhsiIJ4FGwL161L90e9RkZqhER5puKk+lG31piIsUm3NT7RSYouBHtFLT9tGKBkZ5pMVJikz6UAN2gdaQkdqXGaUIWOAKBERzUkJRZA0q7gO1SiCQrnacduOKsW1m0jYkyoP8AKk5Kw0ncozFXfKDA9BTfJYLuPStu6s7WEbY2IYd/WssREfMxzjt61MZprQco2eosdjLIpfhfrVMjBxVw3MuNn3R0qNI3c7YxnPrVJvdiduhWoqcwsAfbrTMVVySPFWYZvKUqRkHtTo0jPDAg+tSPb5bEXzGpbWzKSe6IVuJkBVGIHpU8V7NEQev1qBomThhjNKFHpScYvoNNouHUJHOXUVB9ok3Fk+XNMIJo20lCK6Dcn3FMsrfeNXtPEry7l5x61TULuBfkVpC8SIbbdcDvUVFpaKKg9btmjcSRxLxjdVBrpGGJCaiM0UjFpAfanefFxtQDHfFc8aTW6NXNdB6wRMwYLknmryoACGAXHp1qp9qYNyOPWpfLEiid2Iz0FEk+o4tdB5ZV4RC3uaTJP31ApWnRcKozSxRiXJfgCs2pLUu62GmWJeOpoM8jDCBRUhMEYwF3GqLhicqMD3qNW7D2JPMnz87cU6VkfGTmokKKMMM0xsE8dK6FTXUyc30AkfwinB1xgrmmUYrSy2IuNOCeKTFOxRiqJEU7TmlB5yaMUYoGPLsB0FMAZzS4zVlEKjcT+AqW0hpXK5jIPJxTNo7GrJjaVsqOPeho1Tktk0ufuPlK58xht5OKTYc4q3vaq5LFs96aYmiQJ5YJbGarscnOKmCyOe9ONuw6kZ9KV0t2Du9itjPSj61cECjljTvLizwKHUQcjK0cat97NWQ0ca5GM0uFUY29ag8s56VDakVblGmeRsgcVGSxPNaEUewZYYphUMemaFKK0QOLepRwWpQhPAq7s9ABSeSSc1XtELkZXEBAy3FNKBRnrU7Jzh2x+NR7Is8yChVF1Ycj6IiGByBS7gRgiphLbKMbs0z7dbJnYual1V0Q1Bn/1PqASc/MKXfGadlD3FQvGh5BqRkmM9DRhx3zUIKr1Jo3xno1IBxijf76g1BJYwyD5flPtSs5Xoc1H5pPempNCshp09NuBjPrUX9mDu35VN5zjoact06nDLVKbDlQkdqRwx3D3FV20wmTduGM9KvpcIxweDU25D3o52HKjJuEkjwqLvX3qtHNtbmIVusiuODWfcWTPHhcZ+nNXGS2ZLXYy5GeSQlcIOwp8byq3zH8RzULWrqcGpd5WPYFIPqK0duhBbjvWZSrLuHTIqWBkzuZSBWOxdRuVjk9RVm3v3Q4nyVpOGmg1Luacptvbn0qoY1xlTRLd2bYLDd9KgnubRlzDkEDtUqLKbRJtFSBCvPSssXUi4Jzg9CasJeGThiOPXvVOLJUkXxLIoxnNQNljzVc3G04cYNPFzGeM0uVjuPxS5x3oEiHpTjgdRikMTzMUvmg0mAaaVFADtymmkKaYRSdO9AAUpjRmpAcdaeCppiKTR1CyCtIhajIQ01ITRltHxULRGtRlAPFRsoarUiWjJZcVGRWi0R9KrPERVqRLRUwBSb26VMEG75uBR5RkfbEKq4rEJOahcZ6VYaNlOG61CaaEyuRSBSTxU23JqVFdPmTuMVTYrFQrSYqwy8VFii4WIsUmKlxTcUxEZFNAqQ0qrmgBoU04rtFTAZpjjtSuMiPAqMVKRUZpoQxj2qq1WSuRmoGqkJlfFKBTsUvQVZJDjmg8DFSY7008mgCMDJqdaRVyaccLSYIZIaqkZ61M2WOaYR6VSEyIgU3GOam201l45piK5GTTSOwqQ56UbaoRFinYx1pTx0pVjZyAOtACEKVHrTQozUuzHBo20gIwvr0phx2qc56UzbTAgIo21NtA60wn0piEVQWA/WtK1sAzh5m+T271mdORVqGSSJDKGHPG096iadtGVFq+p1EreVGEt4htrJdrtyW4XHbFVJ9Rlk2lGII6jtUC3syAjqT3NcsKElqbyqx2Lv2S5uCXJ2kcjPQ1Nb20UL75fmJ6+lZ7ahcsgTPAqu9xM42k8e1a8k3oyOeK1Nq7W1YA4GegrG+0uimMAemR1qDBNOCVcKairN3IlO+xDg05QVIYdqnCAUuAK0uQTQvECWZPm7VEGkD7lODSVLI27GBjA7VNirkbqcgyGhULnCAk05V3n5jitqDZDENgycdaic+VFRjdmedOlVcuQD6Zq5BbRImHCkkc96RpjJlZBTY1G7Kg8e9Yt1HuapQWxVuIo1P7v8ASq4Qk8VrMskhwflFSrGI8Dd+lWqllqS4XZl+W7rgL+QpBCR1roCQUyDiq21ZAfWpVV9humU4di5Mg3HtSys0hGTwO1KRt4NJzTsr3FfSxFtFSI2w4HSjrSYqt9wJDKByg596hZmc5NOxScUlFBdkeKMU4kUhNUK4mKKQsKTcKLCuOo4qMyDtTdxPSiwXLKxs3IHHrT0QbvmquJ2Iw3SpQwYjAwKl3KVi4FQfdA/GmyO6cA/gBUB8ztjApByMufyrFwv1NFK3Qf5zkHPAFMWdRwRmkRk546UBTJyDj6CrUUtyXJsnEiMOuPaoXbYcrTfLkTt+dOEIPJzTSSE22C3BzkjJpzyFumQfanfZ1C8HmmCFs5Zhj3qXyMa5gVM8GrKqsa5NQnyx95+npQbiJflQZ+tZya2RaXcY8zu2Fan+YiL+8k5qs48zocfSmpbL35+tSloVcrTXDE/IxNNjlnJ5atIRIvAxTWCpyapR7CbIhJMB3NOUyuORj8aUuvu1TCQFeOKfJbWxPNci+yoxzIePrUTJCnyxkD6mpXbIwOaiFtEeX6+1Ll6sdyu1s78mQfQVXNk+flatFgIh+7jz9ajV7iTqQo9qF5DP/9X6U8thzQC4PIyKlwwHHNN/eA9KgY4Jv7EUfZgetKJD3BH0o8wj1oAgltiOlVjG46GrDyvnioPObPIoAi/eCjzXHBqRnzz0qIn+9QAvnbqTzB3NRsqkZFRn0JpgWllI6Gphd7feswgdjTSTQBtLcwSffGDT1S1ZwykfSufMhBoExFPUDpmRH/hBFUZLKJ34GB7VRS7wOTV2O9RuC2PrQpNCaTGjTYi3B49KmbTbbbjBHvmpRKWHyuKgLzBvlO72p877hyoiewR12M2QOlZk9ksLjbk9wRzXQBmYYZcUjRKw9PpVRqNCcEznGlmkzGcNn25qIQ+Up89W9iK1p9OyS8b/ADe9ZbRy7/KZjnpg1tGSexk01uNW4mQ/uwMD2qR7+d1+cDH0rVtbYom1grA1LLBAVx5QOO2KlzjfYpRdtznxOT6/hThcn3q5cWDMu+BQnqKz/s1wybhtOO2eatOLJd0Tfam9aUXOetU4IHnYpnaw7GnzW08GScMo7inyxvYV3uXPNU+1IZPQ1l+caUSE8ijkDnNHzW9aFkB+9VDzGzUpmdkxtwB3xQ4j5i4mWOFNTtE4GRzj8Ky1mkjOVNSteyOpDdT6VLi+g1JE5fHB4qNxUaTKfvc1ISpHFFrBcg2rnLce9NSHcCVYLj1NXBbSMm8DioGt+Nxp8wrGewwSvBqDbk1oS2+xN4IIqoRWiZDREYyOacpK8VJyeKULkU7iIn5HSq1X3XiqbDmnEGRkUzFSEU3FUSMxTwMCgDmpRQwQiDimMvNTjimuKm5RCV4qFl4q5jiqzCmhMg7VWYVbI4qs1aIlkJ4ptPNNxVkBTcZNPxTlHNAxOg4qFjmrLgcCqzUIGMPoKUAUqinKOaYhGXHWoH5qw5zUWwk0IGV8d6ME1OUp4jp3JsV1jqUR+lWVj4yaGOOBUuRViAqPxqNjxipW45NQMc00gbI8U08U80wirIIzzTMVNijbTAh20bam20u2i4EG2l21NtpwSlcLEG2nBKsbQKMGlcdiHaBR9KnEZqRYqVx2Km0mnCMnoK04YosnzaUIFfK9Knn6FcpRWHBBP5VdktomTeMA+gqYqjDcTlvSm4IrNyb1KskV44lHVc1Pl8YzgelOGBRxQ9RoZtHenAlTkcUcUmRQA9pGYYbmoqC600yChIGx+WxjNICw6GozLTfMY0+UVyUjvSYqEs3rUbMafKLmLBZR1NMMqjpVYhjTNrVXKLmJzLTTIai2+9OAixy3NOyFdi7zTWkLHNSBIAMs3PoKgZlydgwKaEw3GgBmOBSZJGOKegduFzz6UxXGMGU7W4NMyaufZJiNxFBtJAecD8annj3Hyy7FQZqVCScFsCr0dpFkbm3fSpcNGf3UageprKVaPQ0jSfUrID90ZNTeS/bNMaWVer4+gqNrkKOpJNQnKWyLsluywsSqRuxUvmxJ0rLM0kny4x+NNaJgvLZJ7Cn7Jv4mT7RL4UaJuATkcfWnB9xxyfpVeBGEeSAPc0rydkzUOGtkWpdWWW/d/fYLVeS7tEGS+41VNq0x+Yk1GdLhU5kbHtUctt2Ve+wsl7BKcKv60KyDnGf1qUC0g+WFRnucZoRoj2z7Ypx5VuEuboPWXAwinJ9qk/fkf5NPPm4wgCVXJKf62cD6U3NdEJRfVk+Ng3yNioDcQscDJqnLdWoPUyH3pi3ePuAIPWpux2RphN3I4HvQIsnIrON/Gv3mz9KqSaoo4TJqlKXQTijcYxQ53n8zVf7cucRn9K5yS9eQ8movNb1xRyt7hzJbHTGZW5lk/AUhvrZOEG6uZ3t603zZM4BpqAcx/9b6S+0IKlW5jPU4qk0Uh5IqIoR1GKgZqedH2anq6t0INYZGPUU3JAyDRYDofLU9RTDBGR0rFWeUfxGrMd8w4Y/nQBae0Qjg4qo8BBwrVZF4p+8PyoMlu/8AsmgCkbaYcjBFQMjL95TWmVwP3Z3ewOKcoO350P6U7AY2EHrSYBPFbLQxHsaqyWpJ/digDOPuKiAUngYq29rMOqmoTbS9gaAImj6CkEbetNeKZfvDpUXmSIaYFtY5h900vmXKdzVZbyRe1Si73dRigC2l/OowTmrsV8jj95WQZo+9KJ4RzjNIDbLxv9xwDT0hU/NIFJ9QKyBeQkYCAGp1uuMHii7A1AoT7gAqGR5h9zBqusgbo351ZXPqD9KQCK7tw64pGWJjllGR3p5z2NIxYDsaYFdrO1bLMoJPcVEYIWQoHO3uOtSfaFB2sAD9aa0cL9ABn8DVpvqKyKy2Kqf4XX0Zefzqldaa7Pvi2oMdM1shlQYbPHHNOLBhhRnNUqkk7kuKaOSeGaLgjP0qWOOc/KykZ6ZHBrpgscfXH4CnEpICOtW6/kT7I51rC4QB2XI9AearTBVbCKy+ua6V5ImHltmqf2Vix2vlT0DDOKI1e4On2MDODg8GpA+OtbH2dUPzRK3qwP8AQ0XFvF5YYITnoBV+0TJ5GZ63UwXYGOKj81qsi3fy/kjIbOCDTTZ3AI+UjPt0p3iLUps7evFMLHrU8lvPGcMveoGRwMlSPwq1Yl3HDHWoy2D7UqtipAiv0o2AiLq3C9PeoCvNWfL2ntT9in7wx9Kd7BYoFaaVOK0/KXHBqIxCjmFylAU9Rk1aaJcZ71EFxTvcLCNUTZJqc80xhihAMA9ahdcc1IzVGWFNITZA3FVmqw3NQkVoiGQkUbafinBaq5JHtp6rj5j2qUJkUxv7opXHYgY5yTUBGTVhhimgc1SExgGKeEJqZYyatLEBUuQ0ih5WeKXZjpWiVAFV2wKSkOxUCc5NOCZNPZ1xwMVC0vYVWrFoSOwHAqsW5yaQvxTSQV56+tUoibGMSxpmKfilxVEkWKNtTYo20XCxFto21NtpdtK4WINtLsqwI/Wn7FFFx2KwSnbDU+09hS7DSuOxCEFOCiphH607ao61Nx2IgPangGnblHQU3fSGOA9aXioi4phkoswuWN2KaWqsZKYZKfILmLJemmSq53kbsHHrSxoZG2k7R6mnyoXMSeZQGz1OKrONpIByB3pQkhIGMZ6Zp8orkpPpSA5OCcU2VHRdrEcdhUG5sZA/HFCVwbsahgRV3A7h61RZ1B4HFNMmRtcsT6dBTACzYUcURi1uNy7Enne1N8xm6CrCRxx5eX5sdPSpTc/MCm0D2FJy7ILd2Uf3jcAHNTpayt8zELj1q/CFky2ce1QLE0k2Ezjual1OhSh1HNEiRbccnueKorb7s/MCewHNa3ky7tzEH0zzT2KQjIGW/KslV5epp7O5n/YvLTcfvfXFUzA7cIpJqzPcyu3AC/U1Yin2qCxyfRaUa8lqwdJFFLOZucY+tXoIGU4JwPam5uJmygKgetPPnrwCCaJVZPQI04rUfLMF+SmDkcGm/Zwx3yksfQCkdmT7qHisdjUm24Hy5qnKsrNtXcahZtQkOVUgVJB5qHM7AfU1UWk7slq+iEFtMxwanSzVfvYNDXsKHbnj2pr6hbAdSfatHWl0IVJdSZbUZzwop5MMY6FjVFdQjY4C1YWcnkYFRKcnuWopCmZuiREj3pA0wYHYq0j3KDqxqE3yAcA1F2VZEskxiGWYfhVFr6AHlSxqpcXJc5x+dZ0kjHkDFUodyXI1jqIByEAqu+qHPBI+lY7Fj61Hg+lWqaJ52ar6i7cZ/M1Ue4kc5PNVAGxTtp7U+VIOZkm9zTS7UnOeaQmmIYWJNJtPpTiT2pMP2piE2mnAUYk/OnfN0ouFh4ZV6gUecB0AqEjPU04LH3osM//X+mg+PvCgyRnhhSFscbaYWBHAxSsMkAgI6Co2itm9KZkd6cFDdDRYVxptISPlNV/sQz61Z4HejnHWjlHch+w/3TTfsMn97FWP3nY05ZHHDDIpWC5VFpcJyrc0vnXKkhsNV3zEI54qElFOQT+FKzAjS5lA5jFH2tgfmHFTBkI5IP1qN4BIMpijUZIlwj01w+cqQRmqAt3D8A8e9Sf6SnIzx+NCYWJjLGzeV0aq09mTkrg0hu7hDukjDD6VJ/aEZxlT+VHoIyHh2nG0g1HgA7SK2zeQvwBj60MsDLkspouMxPLGMgUvknsv61pNbJjK8e6mq5XyzxJn2NFxWKRide1OjVSeWAq+LlF4kTP0o86yc/Mm2ncLEKlo/uH9asC5nQfdB96heC1Ybo2P0qphwSo/WgDS/tBx1wKd/aKnh1z9KxWSRmwcVJ5EyjOD/OnZAajCCfJSTYT61XaynUgxvnryP8KzyJQeRj8Kes00ZyDmrUmiXFMty210o3CXJHY8U+3tJXAkkIXHocUsWpoTtlGB61dS6gfhGGPcUOo7WFyIa0TkbY5fz5qIQ3cQ++jfUVafZjPb2qviPdw+PY5qOZlWK7pcM4JRSO5DVbRCBnaQfrTwy42qVJqPDqcNz+lDd+gWHmMspHIzVSVZ4sNGTtHUAVM28/3l/GoWuUT5WlAPvTi30QOwNdRSjbCSWx071CxuSm5V5+ppY57Vn+UozeuOastcA8rz7g1b06E79TMN9covMeCO5py6mjrtlXB7+laTxrIPnUEe4qlLaW/Hy7PzqlKD0aE1JbMoTzQynAUAjuKiCjrU89rGmGQ4HvSxRqVzuA+tapq2hnZ31IlwTg1MAvSnKqMeBUmyk2NIjEeRxSiKpeR0prNk8cUrsdiB4RVZ0A7Zq6QT3qJreZx8uDTT7iaKLAduKYYyR1FWTZz5G4YBqu6FDheRWia6MhruVHQqahIrRbBTg89xVYqT2rRMhoqEVCRV4wOecUwQnPSqUkS0UwuTUo4GBVow4HAoWHuaHJBYhEZK1CY2JwKughBgDNG8dcYpXY7FVbUt1p4tgvJqQzgVH5hY8mjUNB33e1NBLGlMq4x1qsxOcjimkDZOx9aqO46mmPIemarkk1cYEOQrNk0w80YpwHpVkXI8UYqXbSYpgMAp22lozSGG2lx7UDNLgmgAAp4Q0Hcq5p6RmV9qsMdyalspCBPelwoq+bKMAOGJHeqohYljlVA/Gs1UT6luDRFnHak3GoC7E4pyRTygsikgVpa25F+w/cO5phkWo9khJAU8daZtc9BTshXY8yUwvSeXJStG7HoB9KqyJuxhekXLH2pxhI61Its7DK8ii6QamhFaRyRB2Uc+/Wqz2RDYQgj9atxb0ASWUYxwB1q3G0Sjapy1cjnKLbOlQi0U1EuArRDA4zUNzDIQNn3vRastmRs8kD8BUwKRcMwH0qVN3uinBbGbBDOiMrxZLd2xxUUltKxBAPHoR/StBhG5OIz9TmoQ5gOFQDPerU5XvYhwja1zM8l2OOTVj7NOEw33RVuN55G4PXpxUjWx+8xLH0rR1HsyFBdDHI9aAp7VdNrJ/dpVtyRnpitOdEcrK8EJlcKx4pQTCzKBntV4WzKAwPy561J5ETKdoz7ms3UVy1BlS2c7Sp7+lWoyqjAP4ZqMoE46j0FKRCB8q5NRJJlRbQjlXbjP4GhI89BSY/ujFOw/Q5qfZIr2jI2toesnJpRsiGIlA96ds5pdntT5F1FzsYrt/FzRuOelWBCx68U1vLj6gsfQUrwQ7SYeZgYUYoVJHyxOAKYJsAs0RUD1rOudRfOEY49OlZtp7ItJ9WaMrpt2Rkk+1ZMsMYG52/Wq76k+Npxiq0l75i4AA+gpKDG5ISVoR93JqmWGeBT9ryHlgB70/wAmMH72fpWiViR8MkanLDNXDf8A8MS/pUltbqRkqcVaMyQ/ciUe9Q2ikjM/0qXkKfypoguzwsZNWpNTKHgKP1qF9anIwuB9BTV+wn6jW0+7xl1A/GqptSp+Y1HJfSyH5mJqD7QemTVJMltFhlUDFVXYelNMpNRliatITY/cR6UvmEDoKizSbu1Owrji5J5phY00n2oOaLCuL5jd6PMbtTeaMe1FguO3mkJ7Zpu09qXY1Fhh8tJle1LsNNIAoA//0PpzYKaY6XfS+bS1GRGOm+WamaQGmeYKLsRHsNJsNS7weKkAWi4WKu0im5YVbKrTSq07hYr727gUbh3WrHlim+WO1FwsQfuz2xRkfwnFTeXTTGKLgRhiOhp4mOMHk0hjWozEvajQCXMT8MacEgB6VTMPvTSkgGBS5UFy80EDDlBVZ7WDaeMY9KhzOgIYkVGJZc4o5A5iEw25z8xB+lVtkPmbWYkVrk5GJkz7imNFZsOBg+vSpsx3KX2W2+8HYVP5EEvrxUpgjH3XNMCXKn92wYe4qbjGi3gU/I2PapAD0Cow/I1Xm3jDSjHuKEuYSMEZFMBkkeDu8ph9OaVbheBhh9asRyW8hwuVPpmnPatncjYz60ADGRlyB+lVJHhIxMpHuBUrQMT8khB+tONvKfklOR68f1p2EVUjsCMk/makWO3TgPgH8afNa5XaAn16VmGykUk7guPfNMDdCw7cfKcVGLdvvKR9K50ySQnkgirMOoBRhsD86dgNdUdWwDinHzWOGXPv0qtFfQt0ah5fMJVZB+ZFICy6nbtxn8awL6Dcdytkjt3xWoIp0/1cg59acFnz+9CsPwrSnPldyZR5lY5lraUDdikSS5gGULKP0rZlsombMT7CP4TxUMQCDy53JHp1B/rXX7RNHNyWZXTUrtmAZhjr0rVtr5JgfMwCO/aoRLYj7q9e4FI0yyqUUBQOh6GspJP7NjSLa6lqSG3um2oRkelM+yxRKVd1P1pttZsmJd/0FXJYhIm3GaylK2iZaV9WinFGFOUdWx2BqZ1YnJFU5bFS4KYX1waRzNGmEZsClzj5SzsLHA4oaBh97pVWLUVztmBUn+KtBZbd1yrDH1quYOUrtDhsqMj0zSu7rwoK1ZCxEZUg/jTNmeev40cye4WKfmMWyetK8SMM5yT14q55QPammMLgDk+lPmXQVn1M/wCyp1FJ9nQVeMbAZqJmIwMfpVKTZPKiDyVppjjA5q8qt3xVeSM5OeBQpA0UXMQHFUnkSrssI9azpolH8VbwsZSuMaYLyB1qrJLuoYfjURUetbqKMXJjS1N8wilKA9KYYzV2RF2IZT2ppkc96d5ZppXFPQLsjY5puDUuKOnSqERhDT8FRwaCTTTmkFxCTTacRSpGXYKCBn14piuMOaSrIt3Zyi4JHvxTGjwfpSuh2YkeSwX1NaUtkxXEADD+8TzWaE54FXYGuohiIcGs6ie8WXBrZj4dPIUvcfL6CmGNYWyrANx2q0kN1KcOcA+tPezCsGaTNZc+vvM15dNEUzMwO4tu9u1VuSd1bUdrbHknNPe1iHzKuBSVWKdgdOTMWMbDkDNaMEhUgk7VP8IFWHihGMZAppgQAEt1pSmpbjUWiNp1UkKpI+lZ8vmOc7QPpWkFhOeCSKcsaEE7fzpRajqOV5GGY5PXFJ5LHkmtl1VAG28GnIARuYECtfa9TP2ZjeS5GCTUghbZs7da09rH7o/OmkP6Ue0DkMwW57A077O6gMVxWgA4INLJ83JJ+lJzY+RFD98xwzcVIMq3mAbm9xxUhAppwKejFcizKxLNnJ96uYQ4dwMgdKrN8pxip44yy7jx6DuaiUVYuMncVSzA4HPYCq0dtKHLynr0xV4Aj7/AqOZTKuxSRjuKwe+hqvMQjBwxCj3PNJIjOmIiR79KoLaS7sFifepXEifIrEgetWoN6EuSQ5bVxzJKTjtVjA24LZqmFl6kE0ojc9RVqml1IdS/Qsfu+5oJQjjtTUgfGegHXNLmEHaCT+FDkl1BJvoKi7j7UHAYjbR5kS8biKeHQc5JP0qHK/UtRt0I/mxxGT+NVZrp0OzZtI9DVySVx8sQ5PfGah+y7/mlYk/lUN33KSM8QPcsXdyo+tP84QDZEST9Ktyyi2QLCuTVVBc3P3yFz2A5o3DYYzM4zcOVHpmomtrMpkFmNXjBbWo3SfMT61nXF4ZDshXA9qa8g9SmYYlOSo/GglGwEiH4VKkc5G4xnjuRTy77eoHtjH86oRWZ4kGGjANQNdxIMIuae6GRvnZQKryCKPhCD+dNITZE91Kfu5AquTIeWP51IWY8UbFIyWJP0rTYkrkH1pmPU1a2AdVNIQn938zRcRV+X0pPoKnPzcBQKsx2Mkg5ZVHuaG0gsZx3U3mt1LS3j/1oaT6cCiSayQYWDH1NLn7D5TDA9qdsFaSzQE4MYFS77Rf4Qfxocn2DlMrYO9KEBPSr7yxt90AfQVGWT+InH1FHMwsVCijtQF9Aat/aIFGFjyfUnNPW/boqqv4UXfYLIrCGUjO0gU0xdmNaK3idZnDD0AqQ6lag/u4s49gKV32HZFCO1D/dVmq6ukuw5VU/3jTX1OeT5Y12j2qvtupeSjGl7waH/9H6ZKMKZtarG5u2PxoDSdwCPY1Nx2KpVh1FNAweau59QaAFPWjmCxUIGeOKacg5WrWxetR4XPBp3CxF5uB8wqQSxnqDUnlrjnmkVo1GMj3zxRdCsxyOh+7zTsY5xTA0Y+4RQ2xhyfyqWMRmbrtz+NKpDDJGKhEaden40bgn8RNK4yfatMZUHWkE0f8AeFMfcxyjU7hYeUQ9KbtYcA/nTD5q9TQJCWw1FwsRusg5x+VQyMSNpH6VoZx61CySdmH5U1IVirFIY/vDilfEpDYBH5VYMeRhsUw7FXkdKG1uFis0S4JAYE9+36UiJcDo4/GpjKmAWTAFMa6B+6u4UuZhYmVHIxMAazZ9P3EvDgH3/wDrVdMqfeb+tNaSbJMIUj3zU3GZgtb1VyrBT7GqrXN7A2Gc8etbWTKMTJg9sGopLCKRQc800+4FaDVcnE2M+1WZfJu/lDEH61RbSCxyjj8qj+x3kJ/dOD9KegEraZNnb5px261CVvLc/d3qKtR/blYFjj361M97sUq/zfQGi4rFMypOmySAg+1Zklv18sD8etbEd7CWz5ZA9cmpTdWbHqB9RVJ22A5pftEf3V/Sl86cHcw/Suhe9siNqDP4VXmWBjkA0+byFYpRXchwFHStaOdJE+defasmaK2xkSbSO2Kp5xxHJkeoo0YHQvcwxgLt3Y9ah8y0lYGUKD+RrGWaT7u/OamFvI6bkUk+tPVdRbmu1lb7SwJUHvk1XeyHk7V+c+ueP1qKE3CgLJnHuBir4ldW2bN3ryf8KpTkhOER0KMsKoFUEfjTmedBjYD7g0/eAAMbT7VFINx2kso9gKh6u5S0Kk10qctG4NVxqEKnJRqtSWy4+QF/bNQrsBIVQB04aqUboTkMF9HJjcFT6jJpWMLDK4bNKbCGT5iT+FC6fCo+UY/WloMhWC3B+cspPpwKlKIx2pJnj3p/kIDtOQPUkYpytChwjDPuaAGpG4GBu/OrKOQMEEn65qBZyAcuufqKaGmzuZo8e1AFkyyNx5fHrmoZQAQdzA+gGaas0Y5LDNSJukGY3xn1FNOwmG91j3AFifbFVTNMqkFc59qutwNpcBvpUAjnxxIG+o4pqS6oTRReGd13AcnqMYqm9ncNzg81qTGQttEuG9hUL21yBvExJrWNZozdJMzW06fA9feojp84PIrSS5khO24bcPrUokhmfCuV/GrWIl1JdFdDHa3U4ABU9zUXkV0jwAjG7I9DUH2BG5Bq1XXUh0X0MBoR60zyR2roDpyY61H5Yj42A1arJ7Euk1uYRiPrTDEa3/JLEsYgc/hTBaHHMY5pqsL2RgGP3puyt77FzjAqeK0iUHzgCabrpCVFs5rZRs9jXSm2tz1GPpTHtYWUAHB9aFXXYHRZgpGTkAY/GnLEzH5R+da/2NP71H2VPWj2qD2bMkJIOwqVWnUbVYAVo/Zko+zoKTqJjUGivCkzHLScVOUhRi7nJPbtT1QA09wGA31nJ3ZotERwui8gjn2xTi4Y9fpSARj+GnqYlHTmocVuUpMi8lmbqcD15zTwmeOuOOalBSQ9Dj3puPLb5FP4mpbexVupC0ZHX9KlyxUJ0z3pjyOPRT7iohJMTu3jHptod2tUJWWzLBG7gc1GQQM9/SlMu4bMnPr0qv8AZUHzgkDvRzNDsmPbeO1M+c9qGdVG3eTTeG/iIA9a1TdtUZu3QcA54pfKPemhQMsu449xRgEd/wATS5uwW7jvKHek8tO9NAAPPIpOWONuB6iq1FoShY1HAyaUozYJYqPY4qIAbhgE08YB2lgM9s1Ekiotke5Ax+Q/U1KdhGOacFB7ijAHTkipVu5TbIvLB7UojQAs3OKUvzk03cCOlW07EJohE0zNtSPj1zTml8sZcgfTrVhWyMAcVAYY2Y/Lz71m0aJrchHky8fM31zTnMUS5Oce1Toq9FwKa5CJk8/Xii3cL32KEM1qz/IjEn2q7l88DAqBLhT02jH41ZBJGfvD60NoLMFBpN3O3B+tRGWXd8qkD2GaTzpTxjaf9qhu4JWFcBOQmT+ZqAyT9EAGfQU1zsy1xMPoDVCTVPLOyDGKEmwbsWPs88jbpcY/2uKsGW2tVxgf8BrMGqvkbo/yFQzXiTDG0/oKrlYrokmu7dySWcD2NZ0lxCpPlZI98VXcZPAxUe01qoJEOTBpi3T9aFRnOCcU8xDHzZzTdhBpiL0NjAeSSx9uBUhjtY+GGPxzWYxf+JvwqRZYgMFST9alxZV0XTPpyjDIW/Gmfa9PX7sBb61QZk9KEYqcqpo5Q5i897vTbDbBfcCs5jMDuxirKx3c3CK34U/+zb4jlfzNCSQmyg0s7dWNQ7WbrmtqPSbj+Ihf1q1HpSZ/euSf9mqvYk55YsjgipPs5PRh+ddRHp9vGfu5+pqwkMKjhVH4VDlYtI4xom+tOS0nk+4hOfauy8tFGIxzTXOBjLZ9iBU+0HyHKHTrgckAfjQloFH7wf0rblt5X+6uB6ls/wAqjGnyYy7qPbrT5nbULIqpb2OAX4PuavRppcYzgE/nUPk2sXDsC3+1xUqz2PQkfgKm7HZFgXdmPlVR+VSGe3Azu59KqIbGU4QdPrUuy3AyEB/D/GpaQ0z/0vp/Yh6imGOPtxURkHVTSrKpGCKizHcXaR/F+ZoOR3z9DTC0XvTS0Z6EiizC48BiOCRS7WH8fPvUSuh6k0nyZzuz9aVmO45ln6qwNQNvxh2ANWi+BwMj2qsyRMfmU5pAVzCD8xcH8aUQSEZUkCnm2jBycilCKo5Z6dwIP9IjOQ2ad58n/LQCpvNReAzfiKY7BvWgBhCy9Rg+1J9jkHO7H0NPHmgfI38qja4uE4cfmKAHCGRfm3E/jUiZHqP+A1F9omAB+XHtU6yyE8cj6igAeROjN+lQtLHjqCfap8ljj+eDTCp9FJ+lICsWbGFc59OaaEuGOCyke4FTMrk/6vJ9RxUqBuVdSv45oAgkhZU+dQfcGooTbr8u4qRV77qkE5+tVtyHnhSO2KpJsTY/fETgSig3MMYxI4we+DVOSTLY8scVCZAw2sOPQnNP2bFzo1BNbnlZF/SmeYrHakik/hWYjQKD+73fXmlRoxkqi464wKapyFzo1iG/h5PtUA8wNmRRj261DFLCT+8CirO+Be6j8alpopNMUAd8k0jEoOmfqaryS3IOYhkH0wf61Xd7sk4Xd9cD+tTcdi3JHG6cFVPr1rEncq5RnyO3H/16nZL1+PJGM9iP6VYSAn/Xw5H1FNaAZccbE5R0wOcVomGRl3KGDev/ANeiRRGR5cBGPYGk+2uvysjAfQ8U73ASTTmf5mJP1NUjpUo+4cfj/wDWrU+3oR8p/PP+FL9tgPU002KxnLYvFxv3fgD/ADoaGUkbpAo/2RitRHjl5Vgfwp/kjPJFVzImzKUaFDlpsgdutS+au7CYP0JqfyYySOtM+zR9TjHtTXKDuOxg7ifyNQzSqFyQR7HNL5UQ5RsfjR9nLcs5NCUerB3IVvFIxwvvyab50RGGPA9uDVgxBSMY/Kmm3GchufpVLkJ94gE8bAqAevHH9KVywyZDkemCKtZKjDDJ9qblCc7Tn86LrsGvcpGaNsZjAX6E08pHGMqhIJzipJFLjBOAPQEf1pg/druzn60eiD1IJI4wcrHgfhn+RoRo3bmNgBz/AJxUM8iOMbifw6VAqyhtyvuGfXFWqbtuS6iuahERAyB9Caryvz8jhQO2M1RLtkhuDinIIwCu8A+tNU2tRe0T0LY81mLK4I9//r1MJo0GGcEntnvVdZVT5XIPoeP8aJFixkMB+AqJXehasT+ZHuy5XHbHJ/Sh3tnPzZOPY1T8xI+C2fwFSJNH94sPx60cr3sHMu5LJJbONh4x0wpqt5cAGRJ/MUySdQ2V59xUbzRMfnGcdxVKnLsS6ke5aSMAbo5cfjU2wscSvke1ZJlXORnAqVWjPO8A+wxT5Jdg549zVykYJJwPzqMSwOQSwzVTeV5EpI9wKXzweSQf1pKEhuaLDIpOVP60bDjvVZnRz1/DFHmhRjJrRRkZuSLYTsRml8selVBd47moXuc9cGjkkHPE0CijrxUZaMVRS4QkbiV+nSiSaMfdOc98/wD1qfK1uLmT2LZdOwqMyL6VUMyM2MlffP8A9anZiUko7VVhcxKZlphnSmbYXJAYg+poNtHkBXOSKfu9Sdeg8Sxkc8fhTjt6hs/So2V0yoHHf5TVd7aTGQc/nQrPqN3XQnPfDjihGDDkiqgtJiCTx9aa1vIpwcVfKtrkcz3saDP8uB82OwNU2uHOSmMU1bdz3FWVgUDazD8qnljErmkymXkbk0qvJuyO1XvLXtn8qlWJccim5q2wlBlICYncMk98ipg8rdRV3aq8AUYHpxWTlfoaKNupSZA55wKQRjG04xVw4z04ppAHanzaBylfgLgUwCrDEehpv0FCYmR8dqTJFSfN0C0wlx2qhCb2HSoyM5JGPen73Y7RjP4U0sSPu5P1pARg7ThBuzUnA++Dn0zSKznORxQqr2AHrRJjiiJpIV4JCfU5qVCuMlgfTFVGSIPwmcfrRtkPRCB7nFPlvuJyS2HSvNyEYAU2N2QfOQaiKSA4b+dAjkbk9OnWrVOHch1Jdiz5vfIo4lb5gD+FQqka5LnOKsJzzH+FTK3RDjfqyUqqj5cA+uKg80IQoPPcgcVC4Byd2T+Jpq/ZywBAz3ODWfKaqQy4uAflEmPqOKoMbc53MfqK0ZgpbChdo7kVSkiuJAViAx9KFEbkZTrb5yGzVZmA+7Wg+nTcGQqueetRGwKnLHI9iK1TXchpkMIeRslvzOKuNFbofnlAI7DmpIbSzH+u/U//AFqk8ix6qQfapb1GkVPKjlb92c+5IFI1meu4AfXNay21uRiMAA05IEXnr+FLm7BYxTZODlGJNQyWs/cEmukPlrzg1GwLfMMkUKUgaRzYsLhjyu0ercfzqcWhiGSyZ+ua2fLVuCufbOTTWii/jGPwq1zMhyijIRAWwzIB64yaspDAWCu4OKviO27Lx9BTswr/AAjI9sUnFjU0LGQg2xrkD0P/ANepRcZ6jb9ahyjA4wKgxzjgj1zRGl3FKr2LouI+pNO89MccCs8x7eCaljjyar2UUiPayb2Hth2yGxUqv6HOPWgYUf5NSLz0/wAKjliac0upEZQflbj6VTe2gkYtkg1q7B0NGyMdcUe6HvGUIYlXGWb9KUQwZyy5+uTWkQg6Yppx0wKenYV33M54YX/gFCxxqMKoH0Aq8RGfvVCfKFUorsQ5PuVGhUnOT+dQmKPptq6WHaoySTxVqK7EOb7n/9P6U8lqPKenkSDuaXEh53UrhYiML0wxP6VY3sOpFKJc/eFF2KyKuxh/DmnKAAQymrJdaaZFPSi7HYqMqZ4yKTGP4uKt5Q9cUhCGlcLEBkccgKab5564pWXHam4xxinZC1AzI3Xj8KXz4gOB+lR7B6UeWD2p2QXZIZUxzTfMjPHNHkE0fZ2HTNK0R3kNEqrwWz+FPMkeMFQajNsepNQeS3OKXKu4cz7F0eWw5UD608BAPlAFUCJQMN0pnzcDPSnyeYc5p+YB0GTSkk+1ZoxnrUu9iMBuKTgCkW2JA55qHCnO5QB+VM+c4O6ldpR0walIbZETbBs96CkDjoaTD9QopNzgHA/WtCRpiQDA6HuRUZt4CP4S3+9irAklA5SoGd2O3Zj86eotCAxRbsY28f3hUbwqp+Qg8evNTGJscpk9qaYwD/qj/wDrq0yWiu8LKm4HB9M1W3vwCTitDy+P9VnHrU8caOvMQFHPbcXLfYoJlcHzMD0FSGZk+VTnPfIq6be3A5j/ACFRNFCc4jzj04qOdPdF8rKclzMp7H8c1EbyTOQAPpWh5EEnVWyeue1RGyhBJLED6impQ6olxn0ZU+0THnbnPtUn2uQDDRDH0qwqWowvmH8zUZEStw7YJ/vU7rsFn3AXXykeWfwFCXRXgBvfK/4YphY4Kh2AHY1X3uOQx46e9PkT6Cc2upfW6PUo3PtTfNhDbiWBPXiqouJyfmP6c1KbliQFB57kdqXJYfPcVpYckF/0NO86JcHcT+NM2xyjLbc/T/69J9ljI+U4J+uKr3eove6ErXVuw2tz9elCzQH7rAH2yKqPbsBnIP0pggfcD096ahHcXPIleX5tyk0155R3oEMuCMk+1Na2dRnIx1q1ykPmGiWRu5JqdftGQGU89O1QrFJwUFT5u15zx70S8gjfqK8DvyykfiOarfZWz8pIx61Z8yfkgj9KjZphhnUUk5Ib5Su1jJnOc1ELTsxYD6VcFzgk7SPoaebtfQ8U+aYuWDMswOM7QTg+lTR20pONg/GrhuxjlcmmAliHU4z6mm5y6oFGPQg+xcEudoqD7OhBKSAn0NXtqyMd5B9qJIIwMpGM+wBqPaSvuV7ONjONrKDhRu+lPSB1G4qCPer8RHC42+wFPbbgHtVe2lsxKlHdFMBz91UI+lQPK+7DRr+VaRETDAH5VCIiX5Vhj6UlNdRuD6Gd5wXJCLTvNLZKIoq+YRgjbu9dwx+tM8kfwopx71ftIkckil9olXnC/lUZmd+cAVaeNSSAm3396Y9vwNhB/StFKJDUiry3ORRs9+KnERX7yk/SlKoOCCP1qubsRy9yHYMdaYV9qsDaDz0qUFQPl6+4ocrAo3KiLn5QuasrAMcqaljcqfmU/wCfwoeRH4YEj3qHNvZGiiluxoiTHTB+tL5YxxyfYim+VA/IUA/jUi7UyowPYZrNykWoxDbLnHOPrQFb2496kLvj/wCtTQzeo/KlzPsPlXceuD3FKyLjFNMch58wgemKcsbLyTmp5irIhMQpfJU08l+gGRSHP8RwPqKfOxciFEajpTwAOgpjlwMoR+PNRH7URkOPyo5rj5bExBHQU0g554qILdHgyAfQUBZv43DY/wBk0XDlHnHXJNRjnO0YPvUpIIAKnn2oEeOen4VJRFnA54/M01SZOc8VMV28klvwpMDGcGqTJaKRaMHGTn8ajMoBwsbNV/bkcZphgB5qr92TbyM6R7gjaqFfbj/Gq4julOSoJPqelbRh/GkMYB6UKwNsyz9r6BlH4UqJcggNLn6YrRKDj2phj5yKtW7ENvuV/mHJb86icA89TVojHfFHOeCPyqloS22VViUAPj9KcUR/vbutTmMsetRNEf71CYmmQskCnGGNMDRKcgH8alMJc4BzR9mbNaXXVmdn0RDvUHKjFHmnOQB+VS/Zz3PWkEHPP4Yp80QtMi3Fmyfy7VJ5pAwCB9KPK9M5p5gAwTmk+XqC5uhE2043EH86awibsPyqwIFPQGk8oDqlQ3E0SkZ52jjYPypnOc4Ga0/3QGBtz+FIy54GOaamuiJcJdWZuZs7gc49KkTzWOT2qztZeATTT5gGc9PWqvfYVrb3AhAPvc980E5X5W/D/IqP94560picA5NZuC6stVOyFVhjJ/n1qIN8xPH9KlCHbj+vFRnaTyR+dNKNwblYUyOOcCozM56044/vAD65p4TIz96muTqS+foQEhvvdKAoJ4HFWNiBcMPypNq9R/WnzxWiD2cnqyMoAc4x9acXQDAWjbmgqB70XTFZoaZCegxTlaTtTwo61IgbsBihyQJPqyEs/c0mCepPFWiMdgabyeowPap5i+Uq7R3NB2ipmRe+fwqIxg9Kaku4nF9ERkp3zQNn9386XZ2Bp5iwMk03KPclQl2Gjb1IFMYxkYx+VPwo4zxTHaIcZH50k43KcZWP/9T6bDNim/MTnNO+tJj2rK5QmG74pCGxxTulGT2pgRlT6Cm8+gqXJoouBFux1UUnmrn7tPPPQ03aaAG+YxxtXin7+MEU0qwpuG6ZoC4pAPIWoyxBxgfrT8Pjg0mwHrQACTsR+tSbgR1AqLy1PANAiA5yaVwJCWxhSKZ+8HvSj2NOzxRcCJnIGMUmVxyvFPOCOajO3GM/rTQhhCk/WlIToFH41IMdqXPNFwsR4IPygY9s05dw4NOPPTigF+hxSuMA2OvNNZgT8vFDM3oKjLHPTigCYMP4uaUuucYqt5mOQOKXzSOppDJg601lVvX86gMxx04qq8hY53Hj3p2EXigAwo/WofLXjdnp6mmJOR0Oc+pqXzCeGx+dAxo6+1DOVGQpqQkAE8CoBJGxxuB/ShWEQvIAcgEfQ1GHVhhs1bAjIzgEVGRGwwBVqSJaZFuhXnLZ9KZlTkgA59RVgJjvTgVPFFwsVzjH3F/KkCRE7nUH6CrTODwcVEFRicdfwpKQNDAsHUJj8KXKKMcgfnUmSvBGaXzFPbpTuFiHzIwOAfyFN+0qBjaTVkHPQfpSHaPQ0XXYLPuQiVD0XtR5gJwAfpUuQOmKaXzxRdBZjMt2yP8AP0qLzQp+bJz69P5VNtUnJyPxIp4UdcH8TmhNBYptM/8AAP0/+tSeeyrjaT61ZbrycfWkPuau67E2ZUM4znZz2NDSbk+YA88VZMeT1/SoyoB5/lVqSIaZQIznjFNKnrWgf9mmFWPGK0UzNwKJViaTA7jNXDGf7tJ5Z/u1XMTysqEKf4QM+lIoYHkkVc8pv7vWlEO8e/oaXOh8rKJLD+I5HvUJ3Z6mtL7Ng9eajNsc9fypqaBwkQJM6KRyak+1H+7/AEpfszE4FO+zgLg4z61LcBrnK5mYEOv4jnFTCZ25K496TyW4OBnuKQxkcfoKPdGucDjk5/MVE0YPzDv6075lYcHmpTv9sUk7bMbV90RAYxlc/QdDQ7Mq/IuTVg5C5PIIphPoMCpcrlKNjM88lsyRkfSpluIWONrCnyg5GzcfoOKeu/HzEjH4VXMxcqHb4yo2rmmBwTjyyaUKVyQeKRm2/ewPQ8Uk2NpDflJx5bD8acF+bCqaduGOctTc7j8qtiq5vMnl8iQ7gOefxppYDkgigKOrNxQyg9AOaNA94TzFLdzQZweDmniIZyQAPr0oEa845ovEVpjTKjDBqLKg5FOZW6qMU4AgD5Dn1qtCde4nmk8daUyZ6jFOIb+7+lQ+W5/hoVgd0Sbj2pRJ61H5cg6DP1p+x+60aBdiHy2O5gCakDoOOlR+Xz92jyh1wfwo0HdkvmJ600uh461F5XXANN2Sr0FFkLmZJ5nop/SlLYGTVcq/U8U0xnPX9aOTzD2nkTGUA9OPWmvcRx+rfQVXKe9IF4xxT5F3F7XyEkvmI/dISfoahM1wf4Rn0watgEDIxn60vJ5/+vRZIfNcqiWTH3BkUu6Y43KD9Kn56gkfhQwB7c0AJuXHPBpNy/3s0p2Drj8TTCVz/DS0Hr0FDR9KkAU9KgMoDbQoOOvtS+cc4QCquTyslMW773NLsYcLxUBuZF6ikNwzHAHP1pXY+UnO4HtUZi3Nndj6GqxY87lJpvlI/Kxnn3NAycwITzIR+NQvbRE/K/Huab9l3H7uB9aQ2XpwafzERNHbofvlvoak3Ii/KCfxqP7FJ7fhQbWZcBTVadxXJ98ZAwT+Jpvmw7sMag+zTkcmoWtpuvpTXqS7b2L4IbmPBHuaQL3z+orNMEw5INN8uReoNO3mBolUYEZz+IqMwxD74XNVdmAPepEt9x5Ix7GkxpEp8nGAVFJtjPIKmpPsIIyvH60gtJI8ZcD8Km6Ks2IUT+IqKcuzs/FOCbONwz9DS7wo6/pS5hcg4RxkZzmn7IwOKiaU/wAOB7kVE0h/iI/CjmYciLBQA8Uh4PeqJZC4LMeKlWe3B4OfxJp3YcqLBB6ijqMHj6VD9pj7Zpn2g9dhI96WvULJbE20A46/U0wxA8kD1qMzEnJBH41JuJHPGfU0WGmNYt90HH51XcK3bJ+lWsxn7xB/GhtgGAcUJA5FBrbcMKD+JpjWTHkED86vEIO4z75NNBHfn/gNVdiP/9X6b3UufaoMmngisCx5PtSZFNBo3GmAuR0p1N30b6LgBGDxTc+lOLCmFh6UAONMJ9BSblpNy0AKd3am5f2pdy0bh60ANIc8DFR/vl9DUoI6ZowPWlcCMvIO1L5j91pSB3OaMDrii4Cbm/u9aaST/DSkL1NJtTvmncLCfNnoKd9aYY17Zpuxe9ICTK+tACk5zUBRMHBo2oeKAJTjoDTO33v5Um0dMU0ouPSmA4/7wpuGGBwab5a9jSgEd6LgS4J61EYw3Umn89zRgH7w4pXAr+RESCMipAqqMAfjT9imlKe9O4DOAMHmoiuTnj8qlK89RTdvFAEJXkdaUqAOMinNHnufrSBDnrTuTYgMb9s0vlZ5wamIbPJ4oy3GKfMLlGbG6c8U0qx6inMpbg0mwgUrjsAXGePpRtI5x19aTkZAFM+frxRcdg/fDqAAfQ08jI9/pRv9cUhZepIFK47CFSSeSPwqPYEyR+lSeZGOM0nnxUxEBQHGXIPsaUqMcO34mpDLEfak3p25p3YELDdgbj/31SCM5+XP1qXzIxyacJUI+XNPmZNiERSZ6n8zUgyGGSePU4pwkXdwTn0phZM4LYx61VwsP8w+v65pPNNNEkYP3hRvG75Wo+QtSTzCPel83I6U0HJzuFIB2GKd0KzJNx7CkLsemKUA+tO465ouh2ZFk/jUZVmHb8qnIbtim5YZ6fnRcVmV9gUcj+lG4dCoOOnFSnzfb86aRJ160XQWZF8uOE/U1GXx1WrBLg+tMfnkindCafcj3k46U7co79aaWOMgUzzOOnNMLMVsEfLx9KhZS3BY59OanDKRzRvXHHNFwKLrNn5c1XaKdu1abSL3JyfSmswB6Z96pSE0ZDWswxkHBqM2zggnI+tbB2sCME/pULRsOmPoeapTYuVGb5L85J/Cp1U56vk1Y8sEfMB+GKQQr2JH5UOQco1dg4ZWJz17VZVo26f4VD5C4xkml8qMcfNn60rodi1nr0pQQMiquI04JapQV980XFYmGQMCkDY6mocLzSfKQOOfwoAf5ozjNIZHB6H86T7vOM07k9FFFwsNEvOGIzUgZccnn61EUfsAPxpAjE/NincViXKn6U3zAOlN2IOopjovcZ+lNMTQ8yr0wadyeOlRKoB4H504+ymi4WHMnHWojGPrTyM/w0zBB+7TUmJwQm3HUUBB6GghgQQAM0hVjxT5ieQQqO3WkwelO8k9Qf0p+0jqRRzByEBHY4ppxjJH6VZ8setBjXHNHMPl8yriNjnj8qAIunH5VYKR9KYUTsAaOYEhn7vtijA7YzSleD8opuD0xSuOwnyjnvTgfXtSFSecc/WmFCDk4ouFh+7PSgk4pgUHqcml4Axnj6U7iaDOOaacHjIp21MZHeggfWnzC5Ru00nPpTx+dG7npT5hchGaTaTU+Qe1MIYcKtLmDlfcaqEdTSGIGjc4/gprPJ/dphYb5EY6AUYAGKUO+cEEUm9s/dNAxCAeec/WgDLZbFOJ9jUTMRyKA1JNg9eajaPjHr71GZDnj9aZvmz607C1HmJemP1NN8lM9BT979COaacsfu/zoFZ9xCvsKQKQeBTwHx93+dIFYDpQOz7jcHuaXdzS7ZPTNM/eegFK4W8x+8d6du7jFRqGPBxTyMc0XFyhznn+VJnBOTS5wcGl4zyKLhyjdwzjNLS4B6Ube9PmFyn/1vpbiim5FBI9a5zQeDS1HnnrShh60XAdRSZFJkCmA7AowKbmjIouICtJgUuRTSRQMCBSY70bh60bhQAECk4oLCmkikA7j0pvtSZFHFADc+tOBppIpueetFwJDzTCBSZAp2RRcLEfHpS5oODTcgUgHbh3o3AUzK0mV9aLjHlhSbqaSKNwNMQu403d3NBxTCQD1oAdvAo3elNytGR60XCw8H2pCabuX1o3Ci4BvFJkGg4pmcelADiVHFN3L0FIx75pm7HcUAS7hjtTdwI6ZqLdn0/GjcO+AaAJDjsKaTjpRux6UmR60rgMIz2prU8laYQp5zTuFhNmeaABnpTS3qaNwPencVhxPHA5phGCcAflQcDvTd47n9adwsLgKMnA/CkDYJo3DOCeKTcD3ouFhwcn0FPBOc1CxHY/rTd59frTuBN8pzwKcNp7DiqwZSetKHHTNAiUBT2FKVBGKiLD1FIH96YiUgdR1+tODY9fzqLd7ilDjrmncLFgMKCR71DvAOc07cD3ouFh7Ee9MKg9qUOMdRSE+9O4iMovXHNR7U6FTU/HrTcr607hYgKp2Wl2joRTyR60w4HOaLisMKDtTxx700sO5pMg96LhYdnPWkKgmmdBnNIT707hYQop6Dp70YA6U4NxzRkHgGi4rERjHUEimgMvXmpTg8A1HuFO4WGmoyMHOPyqQ7OoppI9adwG5OMUbsYpCR60wkdSaBE4cZ5qQEdwKpFlznNKJB6imBeA4pckdqpCXjqKlEnHJoAm96MetR7x60m4etFxWJNnIpNoFIGHY0blI5ouKyA4I4oxTTt9f1puecZ/WncOUfiimb1xS7gKLi5R2TSUm9e9G5fWi47DvmpMmmkj1pMqe9O4rC89qORSZHrSbgKLhYDg0n1NLuXvSZHY07hYTA6U07c80/cMYJoyvrRcLEfygdKQ7RT+KTIouKxH8lGRS8e1BIouFhm4Y4oD4A54pxINN49adwsHmKadvU9xUeR68UnA6Gi4rEhbjORSBx0pNwIoJHTIouHKO3L60hKmkOOx/Om8eoouFhxIHuKTNNyPUUuQR2p3CwhyeoppA7in5HY03I70XCw3CdwKQqp54p2V7nFNO31p3AQqMYpKXjGAaQ49aAHBscdqXK1EQOxFJwKBWJflptR8ZpdwHWgLDjTcU4MuOtJ8vakA3kDFJn1pcjtSZHWgLBQfemcdRSFsCgD/1/pHanXApdq9cCkpQa5TUTavoKNq9cCgkUmfWmA4BfQUuF9BTM4pwNAhdq+gpNq/3RS0UwDavoKQqvoKM0uaAGbF9BTcJ6CpDUZ60AG1fQUm1fQUtJQMCq+g/Km7VHYUuaQmkAbV9BTCi+gpc0pPFICPan90flS4Qdh+VBppNAxxVPQUhRMfdH5UmaXNMRHsT+6Pyo2If4RT6jNIYbV/uj8qQqnoPyoJpCeaAFCp6D8qCif3R+VJkUA4piG7E/uj8qTbGf4R+VONNJ70hiBE7AflS7U/uj8qZmjd+lAEmEP8I/KmmNP7o/KmhjS7qBDdiD+EUm2Mj7o/KnmmE+lMBpjTrtA/CjYhHQflS7s9aQ9eKAG7EznA/KlAQ9VH5U1iSME0E55xSAdsQ/wj8qbsT+6PypN1G6gYhRD/AAj8qjMcY52j8qeTxxTSfWgBjKndQfwoKp/dH5UGo9xBxTuKw4xp12j8qQrGeNo/KjdkZNJ3zTELsTgYH5UhSMnO0flTc9jRu9KdwEKKP4Rz7UhWMcbR+VP3DpURGOQfwoEPwnYD8qUeX/dHHtUQPpS7qYEu1M8KPyo2p/dH5VHvzS78mmA8CPptH5UuEP8ACPyqPdng0u6gRLtj64H5U5RH2A/KoA2KAR2pgWQsfQqPypNkf90flUIYCnB89KAHFE/uj8qZ5cZ/hH5U/dxik6igLERjT+6PyphjQ87R+VTGmHpTuIZsQdVH5U3ZH/dH5U80wnPWmIaUQdFH5UhCDoopxOOlNOCKAF+Q8FR9cUhjj7KPyppJxTMn8aYDti9lH5U0qndR+VO3+vegn0oAjMcfXaPyphRAPuj8qeRxSEjvVCIiidlH5UzYg/hH5VIeRTG4FMQzYndR+VOXYOoH5U0kHtSE4PNMCUbP7op48s9VH5VVLUBqLCLmI+yinfIMYUflVTzOKkDnqKLAWFEfcD8qNi5PA/KoVcmnB6QEhWM8bR+VNKJ2UflRu96QEYpgG2MclR+VG1PQflQcEU09M0APwnTaPypCsf8AdH5UzOOKMigB+xP7o/KmlUz90flRuozQINidlFBRO6j8qTNGTTANqf3R+VG2P+6PyoyKTkdaAF2p/dH5UbI/7o/Kmg4ozzQApRP7o/KmlE/uj8qXPpRkdKBDNkZ7D8qb5aeg/KpODSEUwI/LTOdoNIVjP8IH4VJTKAGFFxwBSFE4+UflTiCKM0xDcKDjApcRgZ2j8qOO4phB60APCxkZ2j8qCqf3R+VR89KUNjrQA7an90flS4j/ALo/KmhqXIoAUqh/hH5UbE9B+VMyetLuFMA2Rnqo/KkMaf3R+VOzRnuKBEflp/dH5UmxMfdH5VJmm0AM2Iew/Km+Wn90flUlNximBGY06FR+VG1emB+VSH3ppx2pgJhP7o/Kjan90flSYpp4oEPMcf8AdH5U0xoP4R+VICaXd+dFgP/Q+jzRmmE80ZrkNR5PrScU3PpRmmA7tQDTCScUnNAE2aM1GGp2c0wHZopuaTNAD80HpTM0ue1AhpBpKcaZ7UxhSZpOnWg4pAB6U3NGaQmkAuc9aaetJSFgaAAnmkyaQ4/Co84oGTbqQmo880Zx1piA8UmaUnNMPHSkAZwaM0wk96bmgZLn1o3ZqPdQGxQIceOKZmlzmmsKBhnjikz6UzJzSbqAJd3rSkioN9AkwMHigCVh6U3dSbh2NIaYhSeOabu9OKZuIo3CgBxI6GkJ7Uwt6dqaWweaQyXNN3elR7u4pN2DzSAfkU0mkznimE0AIT6dO9IH5NIWpjc+1NMRIWz7UjZHIJqHfg4p2/PPrTAer5oyfXNREfxDv6U3OOM9KYicjPJqIsVJIORSZFJu7U7gO3cZWgMKYQD3qLo2eaYi3vB46UA8c1V3804PnvQBZ3kUhYEVBvzS5HrTAn3EUu73qDdzRuoEWQ/qc04NmqgfjBp4amBZ3Aimj2qFXp27mgCQn1phxR1HNNPWgBDkfSmnFOJ7GmEelMQhJ6GkOO1Jk96b9KYAxPQ00kk5GKXoeelNPJyKBDg/QGkPPTmoyM9abkr0NMB5HPBpM+opN4PBpD7c07isDDODUZyKcWweeKbvA4aqTENJplPI4pp4zTuAzPNAYjvR1ppzmmIkEvY9qkV89arZ7DtRkjANAFzfxTtxqoG7k0qyUWAubu1GR61X3gjFLuwKQFjNN+lRh6XdzQApNG6kz6UmPSgCQNSE1Fk80FscUwJeKQnmo856GlzQBJuz1pM44qPPpRk0APz60ZpmaODQIfn0ozimc96TNAEmRTabnsaM0AKabS5pOKYDec03OKfTaBCZpDQelIfrTADxTSx65pT70lAg3c804MCOe9R/zpPrQBKOKMnpUOTwKdupgS7uaXINRZB6UnIoAkNHNM3YNG4UALSYpetIaAEPHNJmlpM07iGkDFJg049aQ/Wi4H//0foo0mcUZzTD71yGw/cKQnFMJHYdKMg9KAJAaTNM3cUZJ5xQIfmlBqMUe9MCYGg9ajDU7NAC5oz3pDSZ5xQA/NIetMzS5zQAlIaDwc00mmAhNJntSmmHApAKabkUE0hoACaafWk3fpRmgYz60UHrxTKBEmaUmocnOKXdzigB7Y61GD2p2ajbpQAhPHpSAjNNPSkyM8UDJc+lJu/Kot2KXcKAHGmZ9KXdTSfSgBPl680jHnJNBPGajJOf60wJA4BwO1KWqHOMnoTSBvSkBL2pucU3d7UE5piF354obBqM9BSE0AKeKQYH3jSZzyKjPpSAkL9OKTORio2NJuxwKBj6b+NM3fLyabuB5pAKxPamdCcYyaXPfrTD14pgODYOCaCwK5qL39KZu2ggUxE/TjH5UBx1qMP0z1puVORTAlz78UpaqxbBIHQ0u/n6UxDgCvPWkyRweKTcQSRS9RmmIUSDpnpTwwqvu2jNIH+QPQBa3c4oLEdKrBxSh6YFgN2pQ3frUG71o3UCJw5zin7sVVD0oamBbDk0oYDk1U3elOD9qALJYZoPNQbxTi2TmgB2fXvTDR15FJuboaYgz60wUuc8005p3AD15pnfFBOeDTSQMYoAU4phYgcUZpD3xwaYh+7PXvSZqHjvQGx3zTAk79KQt600sPSkAOKdxWFPPQ0wg4ozjOOKXI70xDPakPFKaQ8U7iGnPWk3HvSkikNO4Egbv0pwYfjVcjtRnBwaYi0Gpwb0qoJBUitmkMsbsUocGoN3elDUAT9sCmH34x3poalB70gClDUlJmmA/OaM1HSbuaAJc0nvTN1LuoAfk0maZmk75oAkzmjNR5NLmgB+aTNMNG71oAfu9aKZn0o3UxDjSGm5oyKAA00+9O4pp60BYaeKT2paQ4piD6dqbgmnUnNADCTnjj60/cRSEA03kc0xD85xQTk5qJlzz6Uo4FAEmTQGH41Hu7GjgHGaAJs5o4NRZOcUueaAHc5oz603OaXNAH//0voUGgnNRA96duPXFcZsDUdKaT3oz2pgOyKAc0zdzjpSbsUASFumKCajBycU7PtQA4HvTs5qLIpMkHmmBODRmmbh1pc5oEOz60m6m5FJmgCXOaaTxTQeaN1ACGmmlPNM49KYBkd6TP5UhPNNJxSAU80zd60ucUwnNAxxphAoOce9JnigBh4/Cjp0pSaj6UAPDGnZA61AGBpQ3agB7DnNRZp27mkbnpQAwkduKbuHTNBJ6VGcjnNAE24dDRntmoA3NLuzwaAJD60zOaM0hORQAjE4ppIxt7HtSE4600EY57+lMQpYrkdCfWl3jb/Ko2fjkZpvRv8AHpQBOfzoZgOvBNQh+uePxpSeBigBQcd6Ccjimk9CKaeuR2oAU4xTM0uaaaAGjnk9KTjPBppGOe9MLYPzUDJN3bpTSQabkHntTc+1IAJA6dKbnPXpQSMVGSPX86YDhgU3eRgdff2ppOOKaW54piJtwIzTScHp2qAMQc9acG9fSgRJvOeKXcWqLtUfOeDTAtbwfl9aYcY4qEOCevIpd+OetMBfQE44p+4jFQttYc96QkkLimIsBuKXdxVQOMY5zineZwMcUAWd1LuPWoN3fNAc0xFjcOlG7nk4qDd60bsUAWA1OD1V3c+9O3468UwLYc4pQeuTzVQMQMinhxQInJppJxTQ9N3DBoAeeab9KaTz1pA3HPWmAZA600mlyOpqI5//AFUwHZGaQ8dOKTI79aQmgQjY6mkyVHFIT2NN+nemBKGBOTSVCSOnT6UgbmmIlzRmm7xjBpM4piHHnpSEnrTCfTilzTAUk0nfNB+v4005FAhT1zTcn86Ce9JnNMCQNgZNP3ZGagx2pMnOc/hTAtbs9KN2arb8U8NSAnD9sU/NVgewpwagCbPFIT61Fu54p+4GgBfcUm7FHXrSUAOzRkUzHNJmgCXNNJpm6lzQA7NLmmZpOlAEmaTNMzRmmBJmjPOajzRmgB+aM96ZmjvQA/NNpM0ZoEGfXmk6UZpOKAE9ulGeKKQ9aYgB60h560dOBR9KAEPtTRjPU5p2aT6UCDJ69acGBHFMpKYD+3FAPao8mlzkUAf/0/egxODT91QbgvTpS7sjFcZuTbsjBPWkJ4poPH0o3HFAhTz1oB9eKYeRg0mR34FAD2OKXcegqInOMdaTd1pgTZ65ozTAQelJkUASBhmnhqgyMU/OaYEuc0mfSmBqXNAh2aM4qMmk4FAExPfrmmH36UgPHNBoAQnsKaxz1pSRnimEmgAJyM00nFB+tRk5oAXIpmacSO9NNAAT600nimk4HNJnNIYh9RSZ7ClJzUbUxDt1O3Z5qHOKNx9aAJTtNQk9u2aUNnvSk560DIvwpmcce1ObjpUZP40APVvXmnZOc4quSMdaUSYzzQBLnnFNzxTd2f6UhY4z26UwBj/d64pjZzzz70p55qI4z16UCAkZyPxpRIOh560wtxRk5OMUwJg3rRu/+vVfdjBxg0okpWAlOetJn8qaxwQOnvTc5wKAHZ71E3fP1peQeKTNMBm5gAOgpp5GRTn6GoSTt64oAeWxz+lNOe/GaRuRnNRnnikAp5700nvSHgfWmsSBx+NAClsDHX600kgdeaYzDrSZPWmIk3kUu4H61Xzgbh1ppYg8+tUBMfY/Wml8ACm7+xOMUhwetAiXdu7c0u7H41XPHI7Uu/PemBL05x0prDALE0zOCPTFGc59PWgB4ft+Zp4f0qHgg+vtTAx6E80xFrf3p24HnpVQOcZ7CnBvWmBaz0xTc561DuFKX4oET5x059qUMeOtV855zS7s0wLO7mn7uPrVPd6dKUNigC2G555p2dxJPSqu/PWl3UATZBpCwFM3cUmR1xg0APbnmmdDSZOcim5x1piFJHWkJwRig4pvT8aYBnvmmnNGRnPSm55HpQAFsnJpd2KaSDx2pueMimIkz+FLkj6VB97+lLuPSmBJnPel3cc1FuBFOyR1piHjnmkOajB44pd3XtQA7dRntTMj1pMnr2piH5zRnuaYWyaM0AP3808Pk1D9OtHTkcUwJy3ejJqDd608PSAlDEcU7dUII4BpfegCfPFNI7io91LuNADjRSZzRgdaAF3etLkUykJoAkpM0zPejdTAdzmjNNJooAfnNGcVHmjJoESZ9aTrTc0ZoAdRmm59aM0AOzSUmaTNADu1N6UZNFMQH2pvelpDkdKADmg+hpKM9jQAYxzSHr1pe3FJQI//1PcQw2kgdKXdgbqr7jj3p4OevWuM3LAY/nS7qr7ug9Kfu54oAkyD0pMgcUm6mtzQIdnnrg0hYEZHXpTSeaQHnPrQA/cKXfkfzqANzx0pQ1MCYdKXd0qPI7Umf1oAm3U4NVcFs04N60wJ80hNR5NLnigB1Ab1pme9JnNAEvbim96aD+dJ3zQIGwDk00+uaUnik6igBhOOQO9MzyacTTeKBiHOOaZk0pJ4bPSmnHNABuGKaTTT0ApM9qQAaZmn9ajOOfWmAu7HtS7uOaiJ96aTTAmJBqNgfWjJBpCQaBER5ODTDUjDuKiJx9KAAPg/LmpC2RkioCSDjFRhvrk80DLRJBxTGwwx9KZvyec0hIHFAgJJx2pvQ8ZPFKTxx1Iph68/pTACQDk9KQkg/KenaggDBHboKjJyRx+dMRIHH8WacHB7cc1WPbH4+lLvPB/lSsMs55yOaaSOneog/HXmnbt45PegBd3GKY4zwelB6Zz0phYCgQ0jAwetR5x14qU4NROBjvkHtQAmeOaY3HNBOPqaTODzTAQkUwn1pSaQ9uPegCMtnpSE9qDwKYT+dMBcnGaVXB69aiL+9ITn5qYifdkcUxgAM1DuIPXinq3agBQ7LTw+4Y9OKjPpURHdfypgWd7ZwR70p+Yg1WEgHB5pdx7EdMGmImKkAFuBTA5ztHOOM0gcHGRwOtMKnPy8ZoAmWQHp3p+7n3qoT82D1/pTg+R6mmIth88UufSqgkzT92KALOeeaaGHSog+eDS57GgCXOOhpyvxUG7ig89KYFkSZpwYgA1V3HNO34HNAi2XDdRTTk1CHzzShxnmgCRjg4pM9qYDnpQcYpgL14ppPakY4PvQSCPloACR0ppOOnpQfUUm7jmmIDnPFNORz2o4Jz6U3JH3qAFznpRuxTTjqOaYeBgHmmIn3Z4I5o3flUG6gPjrTAnzkelLu4qHeByKUsSPagCTrSc00cdKTdjpTEPpd1MyKQnnpQA/rRznNMyKMj8KAH7+9PDCoh8w4pD60AT7s8Uuc/SoA2OtKG96AJdxPFPDcc1CGzTvagCXOaCKiBpd1ADjRxSbqOtABu9aXdTTSd6YiTNJ9KjzS5oAdRmkzSUAPzRkUzpSZoAkzRmmZoyKYD80mabRmgQ7NGabmg0AOpKbmlzQAUCikoA//9X2YcGlDnOAeKh3ccdaA5zjGK5DYsZ/WlLHpUQOR1pAQOvWkMs5p2c1XDdutP3YoAfnA4poPIPrSE55pvFAh5wBkduabuye9Nz27UmR247UASbqdnuOtQZxjFLnnApgS56/rQD+lMzxSZOKAJ93enBqrhuppwbNMCfOevSm5NNBpCaQDsg0bvWme1ITTAlJz0pDTAwzS545oAQmmZzQSaaSce1AhCcnNNJx9aXvg0xhnmgYdcH/ADmmH1FGCD8vNDH05oAbkGmnmkPXmmknoaAAnvUe7NPPWoyBnigBTkcA+9LnnnrTCxFNyMimIl3ZNRke1Jk9KTcOuaAI2zUR45qVsEVA3U5OKYC7/XmgSgdKYeDioh1x0oAtbjnOOvekJyM9ag3jjJOe9PLAnA4xTEOYY/8ArVH1yrHHX8KFPr6YpjHHI70AKOhApA3OB9BTWYYyf0pjnPfnt9KYEgOKA+7r60zcQT3qPJU49aVgLG7AyOadnGCarb8A04OGBJ6UgJW6DFISBzTM8Y703qOtMBGwelROTu+tS5GD2prdeaAISSOOtKT2akIOajLd+f8A69MBW6ZFR5/ip3U5ppNADGGVzTCx+6BzTs4BNRt1z0piAsAc0m5l/lTBz24H60E8UwJN7Z7Zp2eM+n9arnjpUeWJPbNMRZbpUecHOKC+AAeM0E9jQBJvBwDQGPrnH4VAw5yKQydj360wJgckA9PelJPVf5+tRDn8OKeSMHBpiBW7n8fwpfMwcGmBgw6YIqIlgcdecUAXA4pwc/lVPIz/AEp4ftiiwFndnk0oJ7VADz1pQ/P0pgThvejPcVFkkUnPc0CJtxqTd61W9yaUNjrQBbDZ79aUNVUN2pQ/40AWtwJINNPoDUQY0oPc8UAODEdaCQabwRnqaQA0AO7c03JNKSMCm9qYgx3B5703OM/rS9D1pmeOaYCe4pD0pzcjI4ppOc0xCA+nb9aUPk4pMA03GDQBIG45p+ag3d6UNx1pgTZpd3HNQhs8U4mgRJQT60zPpQDjrQA7NG6m98UmKYEuRTSO9MzS5xQA4Ng5/lTg+aiB6+9L7UAT5FFVwxp4cUATZNLuqMMDR9KAJd1LwahzS57UgJPpSfSjdRTEGaM0lN+tAD80UyjPFADqKTNFAC5pc0yimA/NFMozQIfmjNNpKAH5ozTM0tAH/9b10H1pRxyai3Y5IoJ3DiuU2J854Ipwzj0z61X3KeAfbPan7s4OelICQOpNOyeCRxUAPOD1p4cUgJh19aU+vSod3c07cMYFADsjoe1NPPU0E80wn0oAcSM4GKTJFNyQM+tNLE96YFgNxzSZ7dKhD84/Kn7u9MB4IHtS7h1qPI45pu4Yx+tAFncD0NOyOxqvnA5pwP5UAS5pM56U3I6ikJ6UAO9qN20U3OTjvSbvegCQ9OBTfpTS+BSE54zxQAhJzSE8YNKevtTW747UCG5zwKYMZ46UpOPemEgkZ4zQAZzmmED6kUpcdBgkmmE/L70DELcmkJA6UMTmmZFACse/ANRn1WncHkZph9BTEGTwBzQGG7APWmHOcUjEdB260wJN3NMYGozux/WnA9vSmIiJI5NRt14yMVMQCfrVdsg+1ACHrnrS5Ay2QaY3vzUZOeD9aYFlmGCRSByBketQK+D8vTvR5hzgH29qAJCxHzU3IP3Rjimlu2Me1JnK8dM80CEYsW2DmhW3cd6Zx93+tIXPbv70wFbBIweP8Kdxgjpiow3J3fw4NNzn5v0oAnDgjpwe9OHucdqqhiehp+4d/wAM0rDJjt7dKa+QBxUe7OeelLu4xjvmgQhPHvUZ6/Snbj160EjvQBA3HPXmmbqmOc1C429Oc+lMAJzwKbj15puc9uDSZPegBrHHAprcE4p54O70phIznFAEWfSjcM880HIG5jUXXiqEPJ/GnBgc4wB/nrUQI701jk9OlMROHU55+lNOD1NQhtvPpxmpPbt60wDDA9eO1ODr3NN+Yg+1MIAw3TvTAmJwMA8dTSq+T6k1WDbRz9KeHG3AoAl3LuJFMLN0zyKYpA5zT85wCOfWmIVZDnGKlDnNVyCMgnHFNBbJIOfr7UAWwxHSnBs+1Vd5x+NO3flQBYye/wCNOzxjFQbvxpQwPJNAE2786Ax9aj3ce1G7I+tAiffnrTg/ODVYGnc/WgCwGOafuGOO9VN3YVIGP50AS59aQcHimA+tP3Bu/FAClu/am5A6elB6033PIoAXJHXmjg896aSpwDSN14piEAxmgnFHSjg9aYCMQfyppx26Up4JI603ORTANxB9vapA2M1EeelNyfpQIsbhRux71XDZ+WnhqYE+aM1CGx1NOzQBKOaTkUzOelLn86AFHpS5596bwaTpQIeDRmmZpQe1ADgcfSnb88YqPPvR7UAT7u9O4PIqtkgcUoegCfmgNUYalyKAJQ+adkGoOe9LuoAlpM03dS5zQAewozRSGgBc0tM+lGaAHUU3NLmmAuaM02igQ/NJTc0ZoA//1/Vs7up+opA5OCeBQScEnmm5wMcAVyGw/BJ9qceQSaiznvzQrAUwJt3y0nO4YqInOCO1POdoHQ9aQEuSeM5pwIUVApPPpShsc+lAFjPc0nQ/WogeeuaU46ZzQAZ7nt2pM56/5xSE49vWml+9AC5pVbNR7iBk+tNzzTAtE5HBppYgdaiDU7J60APDcc0/dwKg3HnNLu7UAWQ2BxTj69ar7gDmnA5H0oAlHWkJptN60APzk5HekBPTFMzSZz1oAlJHam0zJzilJHfn2oEIeOtMYjjP60pPc0m4kfSmAw7c570wZ7dTSk80w9PTigAyAcCmN064pWOAT6d6ZQAFsDAPvTS3GD+dNI44pp46mgBzEDnPFMJ28Dik5wPakJzkEUwG5IPTH86PM28E5x1pu4ZpCwH3ecHvTESbh16H0pjcc1GXKE570pOOKYEbnmoye+eKmI6+lRMM4oERnq2aQEkYJwOtKVHU1GxI+Ve5GPpTAmHzDOec4NJuG3J9arhgrdaUMT8xOPY0ASkh8kYzTT79vam5xgDjrTt/TnjvQBFnpn17elKo4zjJP4UuCQeMjvUeQFP4c4pgKDnr0FKSTz+IpmTtwOvc0meOOc+vagQ8N1P+eaduIqAntSFz37cf40rDJ85PPQfrQSBnPFQ5A+7kU8HP3jmgBzkHGO1MJ5waUnnHUVEeDk9+KAEb347UxsjAJp3IJ5+lNYDPzdaYDN3TNMYgnHelYkH2x+lMIGfegQ0jjmg4HApWzioyP4qAGnPXGBUZP6VIai4PJBFUA75cc5H41Hj5CewpDxgUgOOaYh27sOBjNS5DAY696gJI5ODTdxXrx/KmBZYc4FRjcvK00OMY7ClyR07ZpiHK/XPPvShzw2OPWoyAeaZu2jmgRY3qQM/Sm5z8yk4FNWTI96QMynb60wHtgnnIpN/egsoG3r7004HQ5oAn3cDB4p27jiqgLKQf0p4c85osBa3H8aeGB5qoHyOacCBQBYyRzS9etRBzigEg4zQBMDninBjknPSqwPqeKXOfagCyHz0p2fzqqGIHPNPB5oAtbuuf1p2ciqu49KcpOMCgCQjIz3oHB9aaGzwPxp3egBcnrTSB0pDjOVpvI4piHHNNIHSnDnpTfcUANJI4IPNLk4o6GkIBGe/amAmPSkHBxxSHK5HWkHIFAhysMnmnK2eOtRkd179aM8fNTAm3U4NVcHin7sCgRMGxmjOaiBJ9qXcOhoAl4NNNJkilzj60AHWl344ptFMB+7J4o96ZR/nFADuRkZpQ1NDelHXrQBMGHWlyKg6UBqAJ/ejdiow3enEikBJupwNQ59KXNAEtIaYGp27NABRRSdKAHZozmmZozTAfSd6bmjNAj//Q9TJKke9RnAOQc+1DHHyrkgYpjnnJ4HNcpsOJ7kd6XJyfaoxkgZ603k8jnj8qAJtw7dPelDYAxyahJBbI44pwOMc80AS+/FG7v/KoieOaCePpQBOGzzTw2Tz1qvn14xTg3vSAlwTz1po6cj60gIPDGjnkZoAZnjg4xQabjklTzjim5BwScGmA/dzUm4EdagOegPFICehpgWeMZ9KaG9TTA2RQDz16GgCUNTgc81BuP+elKrfjQBZ3cgGnE8cVXJ9KduPQc0hDycUmcUdOKbmgYueaVW9qjzxxSbiD7UxE3B56VH0PFIr56UEj8qAEI55pjccH8KUnNNLEUAMyxb2ppYfTmlBAORTASSM0ANyXGfyoyR19e9K3PJ7U1j0zTAZkYIA5pvpimszZyOtALHB6UAJ1NMcgHINKRjqf8OaTtnFAhDtPJ59KaG4ODyf6U1jz35pCSByeaoCQuc//AFqQkH7tR/xYJx3o3bs569PagQjj5vaoSPmwOKnP6GomUEZ644pgQFcZPemknoDT2PH41G2B+FMRIW+UH+tKWBG4dffmq+W2lsUeZgZx1oAsBwwJPf0pmcfkOfrSF1wT2pHP8qAFBOOB+IpocHAbI9fX60Keg/P2pgzkkimArdjzz7U0MMnfk0gbHJ+lJlccYoAXJHAwKMnGCenSmdPqfxo+o5osBJuyMN1FOL4Ax27VXz1FLntSAkY9x+NIDng8Um/GCOecUEHI96AGEAHaKjOMY604ng54xSbv73T0pgRMem7ntTc08/MRjrUeTjI6Dg0wAnB4qM5PU0UdcGgRHye/4VGcDvUuOMmk4xTAi3Z4ozkY/OkIX1z6UzJzzTAkZuMClV+cZ+n0qItx060mAOnWmInJZiNvegj6VBux930yKcG4OOOaYhSSAQKUScnPejdnn71NYdRwe1ADyDwVGKkBBJ3d6q5CkZHFPGMZH1pgTZHHb3qMccj+VMYk4x0pwY9OoFAh24DrTt/NM2luGP4U3POWxTAshuKduIx3qqGPSnq3YUrDLO4U7pwOarjr15pwbBxQBKDkZ9aA3OKjDBu3SjcRyaBEysATnilDc4qFWHT8qVewHFAFnIpwY+tVVY96cH9aLAWlYjpQRz1qEMO9LnIoAecj2pMnOKTfmnHGNwoAMlhzSHtTSCBjvSE44NADsjvSHngfpS8EZ7UzJyTTATnPFBI+lO3HGD2pBjtQIbz1ozgdMUhOGx+NJuycGmA/cM0/NQcGlzjr0piJ88Uu6oMmnZoAnzmlz2FQgj1p27NAEnWkpufSlzng0AKaAe9FNNAh+eOaU5xio/YGjd0oAdyOlO3HNMBB6UvFAyUN+lLmoKFY0ATdKXNRBueKfu9aAHhqfmoqTPakBNSUwNSg0AOzRSZopgf/0fTiSc4GSKQ7R8p7gUZP3jj6f0+tMPKFzx7DrXKbASByuRTMhTnpmhlwcHoaYduDzimA8nHt3pFLHrwKjUggk9u1LkgZJPQYoETcDnvSZPsaj3DBpc8cduvpQMeJMcHr2p24kc1ET/F3oXoSDnNICwrHrin59aq7to/pUgPBOD680APPHXgZ7UwkYAXPH+eaDzjPNMbIyw4JoAU57kdf1pgPT2pCSFA6fSk3AjI7e1MB+/Bwak3fhVfdnkc0obHU8elAiQnJwRTySMYqMPkU3PQGgCwrnqKcG5qvuGOv1pQSvTn1oAs5zmgkA4HWog3enHB+tACg4NDGkY9hSbh2oGAJHAp27PYdO9Rlqb7ZxmgROcdc1H7Ug6c9KbkdSfwoAD6g81G3Bz3p/GKYeRxz7UxDRwS3So+2c/QU5vamY5KjFAB8u3NNPBBzTiPl9cj+VMPKDP60AMO4cD1/Cmk/w+tKRzkdBURJ5wRg9cmmBITjn1NRds8UhfPGOnNKRnmgBuScZ4oYnHof0ppctyPwFMwACT1PamIkJBAycEdKVu361D5ncikLYGT16UwAgY4qE8jd29KsdB14PSoyFxgfWmIh6YPWoySxbjpUjH5sk0xieMdMnFMBFbAOcnNOLNxuweM/rUOcZ/lQGxz1zQIsAkU0g4wDgVHvxgY7YHvSg59+M80DEbI5Xr0pc5IJGfehsjORTCSMg5NAhSQOcZGc8daZnr6ZoDEN14Gc/jTQ5xuHII/WmAvfd29qQcMRj8aMYB4HpTSc4XPUUAOLMWGOKcCO3PvURO1sE47Um9h0P50rDJ87sf5FRncBnNM3djzTx047UCEwRx69aacbcdxTvmP3fT8qjYqTnHPrTAYQSeBz1qMnHB/OpcnOD2/lUbDceABTAjY4NIQOueaMep4pAT1/nQAxsbty96Rgxz6HpS5BpuOoPFADTz7imZIPpTm5ODTGBxz+lUhChiB7f0pA20c9B1pnf+lKT60xEodScAnNOB/i4+b1qAtnGOKazZHA/GmBYO3pnP8ASoyNoz2pFfPUZ9qdnHA9sfWgBNzdKkDKMZ9elRkDpn61EWw1MRaBIwc446980dPvVADlcGnISBnrnigB5xnOc/4UKaaTjqOCc04jPfr0NAChs8DinhwTnrUIO3j+dJuPamItBulKG9arg44NOz3zSGWSR09KC2MDrUAcjr3p+78qAJMnoKAxHFN3d6TPO39aAJQ3U/nUgbBxVbocClyQOBQBa308SEj2qpvJ5BqQNz83SiwFgtjBAo68/rUAPPWn7vXrSAWgnv27U49ODxTMZOR1/QUALnOfejNMBIzmgkHHemA7OM03HOe1BxjPekBPemIBk8elJxnilGDzSkEcCgBtCntSMccmkyCM96Yh+efYVIG4qDcSMCl3EdaALGfSgNUAJ4zTgwzzQImB7mlz3FRemKdnjrQBJ1pORxTAeKdn1oAO30oyc0dTSUAOzS9qYeaM4NADjS7/AFpobPFKaAHhh1p24VAeOlLk0AT9elGcVEGGeadnjmgCTdSg1HkGjNAz/9L0g4yDjpjpSEjt29qUEKAD9eKjduQ4zt7+lcpsAxyDke9MfnHcetSAjG9hjB7c8UxsbTxgUwI2JD4Jz9KduDc+nGaaW5yOOOpFMDDocmgQ8EZA/M0ucj3/AJUwnuuaMtwf0pgP35wPT9aXHHH6VHknrwcfWkzwTQBJnkg81Mr84qruA5PFSA55H6UgJzjBzTR7nj61GGOefyoV93I/CgYofnpgk9O1Jvy3vzSjjBP8zTGOTkjpzQAdTTSR06035tx3H5R+P4ZoyWbI5z1piJlYYC/nS7gOveq27OR2qbfyMdqBDiccHrSKdpGelN5brSZL9TigCwGxin7uarBxnrxTw1AFnIPWmEluewpm4Y/pS57UhikgUnTBpM4OKbnBNAD92PwpQ2Tg9DUR9qTdjPNMCbk8mm55puOcDimscZ/SgQH0qNj6U4knOKacfWmA0+opv3hlc4HOaUnFMz26UAKCcZ6ZqNiB/nvS5+XjqKYcHk96BDMjtSNkjGDkj8KDhh9ajII5HbpQMchB7c01upI7UmSGwR1pN/NMQFufSmLkfMeM+poZmZT/AFpoBX5+OnHsKYDmIwQe/NOySMiosj+E44z0o39y1MQY49yKiJOcmpiemeMD/PWmNgDJNMCHtx6VGxGM96lYcZz0qLAAwaYgLDjB/L1oVsv8zZB/OojkYHSjcobJOff0oAnBwSeuDTcgghuBTQ5BOcYJ5pc8cdB/SgBuR3oOCOKXGfyphHc8UAOOOPSk3ZOKQ/dyuKiDA/X9aYD8/JjGabk4wR/+ugkEg+tJ364zxQAuTyv40A8YzzSKcZA9PyqPcOnftSsBMCCMjmgkkZHAqHp1p244FADiGweKjJwOn51IPm/pUbdvagBjjnJHXjNMbO7A5HOalJXOM1EVyckn6UwGEc7R+dN4709gowM8io+MEjNMAOCKZ82MZ4FL7j9aaehPWgQzAABHFNPfNPPH3aY2eD0JpgNGCPUUen5UhO1ef/rU3kjmmIdkqNvXPXtxTiyDAHHvTc84PJxSE856jFUImVgfXimgc5PSoBJkgk8Hj8akL984oAVsAAg0ocDnvT8ggqo6VHtBHuKAHg9GBx/SjcN3y5+tQ7dpGKUHcefypiLQ6Ff/AK1MySCQMDFMLfLjkk0uW4HpnHvQAFsYPfinbj/EaQHdTQMZFAEobgZp341WB5HpmnbvxxRYCwHK9alB5yP1qrnpTs+lAExyPwpwOOtRbqd16mgB+c8j86dk4qLJx6UZGeaAJ1OSSKdu61WDfnUgYUAT7j0HSng561WD807JB60gJyR1P5UYBHHWow/rT9wOB0oGISc4bHtS5BpcZ4xTCufzoAU8fSlDY4pp96D70xC7hTcHORS0gbFAhu6gc9KXINN+tMBxoz3puT3pfrxQA9WH4daXJPSoQaUMB+dMRPu7U4NUO4Hk0u7rQBPmjNR57ijNICX3pMU2lzQAueaMmko6e9MBwNLUeaM96AHYzQDikz3p3FAAGzUgNQ4oyRQB/9P0BuuRUoIwMHioVdSMCmk44FcpsTDOeehFRqGPANGQASOce3U0EkfMoxj365pgRkuOeuePpSbmBOB+felG7PFMwU4UfWmIeWU5I9evpTWLDljnmoMkKOcDpTi/I78dqBDyxIxk04Z+7nGOtM3HGc85pCSRn1INAyTjJwTRu7Hp6VGG3cHoaXPpQBLvI4z+NOBDH73/ANaq44+gpwIDYXOMUAT58wEn16Uxn45Hrik3ndweaCNwGT7UgEVjknr04PWkzyc9BTWOB0OOlNVucEEAY60wFZwRkjAoU/rTSQCNvSgnnPr0piJwcDJ70hJOMVArHJA4NP3cZoAeDj608Oc55qE4OBijdtyKALW/Bwe9KGx0qsM4Geo5qQMM+5oAmJHWm59DTQc/KKCcjkYpAKeOM9abnByvNITkY70Zx9aAHZ7mndutQ5OaN5z9aYEhyeAc03jHPajOTgU3Jx2oATAIyKYacW7dqZkEZoERYA60hyvvinYIpC2en50wEyMYJGajZQcdMClLD1PrSEnOAOlACE59u1Nx35z6Zobdn1qLC7R9aAH+56VH6KDn696XPGB1qPOV545pgKVweP8AJpvOfTPNKCMHqB15oIUjP4CmABxkc5yKO/NRgn7o9qTdgcjpQIe2QRjntUR9e9SEjHPamk5Gc0xEGCc+tMPHA5+lTMvv2qKmBH0JB5p24DgcY/KkxkmmE7Rlhn1pgTBhzg5xRnB496hUk8YAp4ZiQrDnp+FAC55wRimFgOuCDS9Bhjz3oO0jpxigA2gkgDpTfm/u9KCT90/pTSdp3ds9aAFJOOaaeASOQaVuVy34VH1ODx70xC5GP5UoYHJPQ9KCe9MyQeeQaVgJN+3vxS8Mv+eah3k8HjFA5OB05P8A+ugZIcNgjgiowT0HFLvG3rgml7ZzQBH8wbKKD60x9rDcDgGntgE46+1N443dKYiMrjBFNPXipiuRjOR6VA2SxamAhHPXtTc+tJkAY6fWj6/hQBGcDgYPc5prE85p5x/EOKawzwO1MQhB4xTN3/1s0rZB+vWmcbuaYCnlfrzSHA7fShs9elAIBzTEP808t06UoJByMfjUZAYcc47UbsL1xnsKYiXODgUjAj5l6dqAVxyeeaduDnYPz/pQAxXxyTwKfvGMY96jOD079qbghfrTAnAJIx0xT8g9uAM1WV8c1Ln5flPBoAdgdqaeeAaRW6+lOyPbBoAMnpTw2OtR5wc4/KjJ/PNAiYMOpo3HA71CCB1GKeDQBOG9aXPfmoAc9KUHj3oGWMkf40gbPTtUe8Cne9AEmSDtFOB9eahzk80bh9aBFkPjr0FLuz0qBc/hTgQx6Uhljfgc/nShs9OPWoNw6elODHpQBMOQCKaemetND44NPBBH0pANyABml9qRvSmnOMDtTAdwOaKaDwSaXPpQIU88U0jj+VO6nmkyKYDFIHFOHvSsM0zBHTigA5HTtTg3PWmljnml4wD60xEmelLmoTS5Oc0AT59KXOaizzmnZFAE2aPrUWSeadupAPpOlNzmlzTAOadmkpO9AD8ij3pmOPSgE0Af/9Tud3B28H1pyk4yOKj+YFT7UuQWxwPrXKbEuVYc9e9N2g8KeSMGmbvSkzkEgc+3FMQ8gdcD3x9aaeDuPT+uKOSOOMVFgY+bO49O/wCtMBBnA3duv50hODgY6flTeSTk8jpTevKj2xTESqcdvypGzuBJFNztyCM9jS/KetAC98n65+tKxBHIx2pi4I2/nijdzz696AHEjBUHmlDYXBqLnJzwTQM45+tAEgY+m7/61SD5hz9cmoAc9+nYVIHDLnHH+FADuAcDH4e9Rk/MB1HtT9wxu7f57U0qf4DzSGJkDBDYoPzcimnkfT3poKgAuMZ96Yh+STzSqckgmoQRnjBH1pcYPHemIsZ4yfxpMdhxUYJxkc0nOCc4NAEwY555o3HrUWOm3NAPcnigCyCc807dycVVVualD8dqQyUnim7qNxNNJHQ0AKScdjQCfzpuewpvTjvQBIGx6elKNpPHWocknmlB59aAH5GcUh9KQHjHFIQfxpiGn/OKZyM5xTmz2HJpp5PtQBGeeT0pvfI79qceBk/lTMnNAC84xioznA/lTmIBx/k03OMUANBHpmmgkDPXNKBgGoQMEimA/A5z3OetIfmXPPTFNZh0/Cm8hyVxjvQAHOFPvzQDj5hS4IqEnnn8PrTESdSRRyTycYGKaMs3pg800uBx6nvTEPH4n61GVIJA60uccnvSt1HvTAgYHueBTG9zwP5VO3qahYc4FMBhIP3aQsByPpSk4FNIAGBTESBsfe9KNy4xjA/U1Ap2nv71IWzg460hi5OeO1H3voaZnqfelPbvQAdyDTSdo/HjvQc59M01sjt+VMQq+h6npmgkHGRSHB/CkOM80AIV4OeeOtAJJGOp5o4z6etNBIIxzmgA3Dr3pR1we360xuPekHIznH/1qAJMZ4HA9aBnqcAmmggdcfSlIGcDj60AJjJ5NM6YA4IpSMHAoyKAInQkY9u9MIPAPT+VSEA5BGAKb3wOaYiLOfxoz2NJjDANgZ7UmVHXqaYDSeDzSc5pc9s01hkAd6AE9C34n3pnIFKQRkD9aRjk+lMAyc9sUHGCBk03p0pMjr70xD8k/MeBxSBgxG4cMe3WjnOSKQnbg9h2piJU4yw6jpTueQR+BqEuoGO9PB43Y9OaAFxuJ4/CmgkE805tw465puRjHGc00A8EEnnj/Gl3Dd7Y+tQhe7c/SgOWycYAoETAhizU9cE56Dmoiy5yM/UUdTQA8ds96TPc9KToDkY5oIA4NMBwbFPzURPpSA/zoAsAkcU5W496r7venAgdKALII6jmkwQcioQTTww60ASA9qcGwp70wE4BFA5pAO3YH+FSByPpUOSeB+NKcg4PSgCwrZGaUNtOBUCsemc805WxzSsBZ35pfu5xUAOTmlBzigY84I54pOfz7CgMG4NOwOh5NACD26DrS8Ec0hP4U3B70CHE+tLnHHamhvSg89KYB1HHamcr3p5yOvNLntQBHn1p4PoelBXnimcgc0xDuhIzQCRz0NNz6UueeKAJQ2elLk1B05pwJPegCfJozUefenZ9KAJQc0oqEGnbj3oAkpKaDTqAP//V7Qkk7c/59aZn5sZPJ69M0jE4A/iP64pCd+epx+VcxqS/dOD0603sccj+tNB5BP0zSEjO0cHNAEvfHI5phLHj3yKUHoM00lGIz74pgDc4zwBzzUZbaCe3SnkbhgdeD+FM2E5HfqfamIQYK56+gpNxwOelNPADHpnFHzBs4oAdyDgdaVmI5PU0wZZsk54/lQMbc9/pTAkyFIJ6n0pARn+VMyvBIGO2aX73Q8dh24pALnnNODEnA59umaiDDvxS5DY3dv5UATLzlc/eoP3QuAKjTD5U9B70mSg44oAXg9/fNKxHRxjjHHFM6nBJ/AUDH+97UwE4Az07cUb+p6YFDkDHoaQsc5X8aAFVsdak35PAquMjv+VO3MBmmImyT0/SkGQOtNDHGD+lGdoyaQDxgD1qQHnFV8n+H8qcrEYNAFkNyR0o4I61WLDOO3apQ3bmgBx6dOlHuaQH/Cmkg8E0hin+VLyOc1GWJPFHQUCJC1KT1x19ahJ9BxSkjaeaYDuKQnByeaPfOKQ4AyKAEZcjOOtRk8FhxS5IPNJ9OlAEftSN79M8UrDnNNYj7vSmAbsnI+lREfxe/wCdPyAOKQ5yccD1oAYPujA6VEfv5/Cpckj3qNjjAxnFABuwSMGkJBXcvTHGPSgtggCo8rz14piF3fMFwOaaMlicdsUobnAAz1HNJyDxTEKWweeBx1pcnAweelR54x360cL16mmA9uePTvUbYzwakzzn9KacEZIoAhK98803k96kYdaYRj+tMREflIwOaQM2c+lOzkkUw4pgOz+nrTsd8f8A1qi459aAcjHfNAEvsfY8UhIGQP8AOajDbsDOKf8AeGDQA0sc8dD3o74FJnJC9D1pPrwKAE3nOcdaXgnk80g4yR1pnueaYDycnr9aj78cU7tg80MAwIH4AUAMz60obDADoaaeCB3pA3I/zmgCTdkY/wA/lSHk803jr1PqKASc9hSAOemaZgj7o5qTIZskdabggnFMBjYznHNRszZ5HHT/ABpzdzmlX3piICDngc4po6dalc85/DmmbAOMUwGkAdKZjnI/zmnMCPwppyADQA0gFeaZ8o5/SpCCaaTjg9KYhnfHelzjkUmeOe/Wm46MRwKYDyck4J9aduznjB71CW4x60BhnGOKYiUMVII9uKcMfxde/rUWcjjGe2KVScc9/wDPWgCThWO3JH+etNOD09aA23kEelLk45wcfhQIXJFKrDI5wen/AOumZHG0U0gZwKYE/Gc5JpN3BA46/jTBg9Rjilz3HIoAlzzzSEFckdRTVBJ5Jz2pS3PNABnHTn1pQe3ejH600gigRJnPWjNRZOeKUE9qBk6n1qTf29Kr5796dntQIn3HHFAJGefzqMMOfUU8P2oAcPlpQ3PFNHpScYyaBkwYev4U7dgZqAEkcUueMtSAsAjHvShiDjOcVBkCn5GM0WAnUgnmncYqAEHoacH54pDH4HXH50mQO2aXPY0nOSB2oAQHPSlA5xTSDk5NJlh/hTEO5ByafkHrTM5NJnHFACkd6Zwp6VJzSZzTENyDzSk+tJjBHpTOlAD89hTgxJ9qZu9KUAnmgCXcOop2fWoAaUNxxQBP/WnZqHdzS575oA//1uwzhscc00sfvKDRuHUdR/Wk8vB64Pauc1AtnGO/HPSlyCRu71HvHH9elG4Zz0P+e1IB+7JDHj2xR7jr2/Gm59KMgjaaYD84GSaYZBtA6+uKGDE5BwO1IQQCD0IxTER9eD0H4c03Jx+vFKy4wM4K9u1R/PHjoKYD87TjkZ6E08uSueCKYhwAxGSR6daTPyjANAhwDduM/nS5wcYx79c4qNWPTABPOfajJO0HOB60AO3EHGe5pAMDC0Y657jOPrSEnBYHAzQMduAAGcdak6KM9OtQq2TtHr1o5J5+XtQItZ7jn/GoAygYB7/Wmgktk9Kdgk5U8ZzmgYhBxx+A9DTdzdT3p0h2+nTrTB0G3PPegBoPH+eaVgWGAPyphYDjnIp5JGD35piHD68U/IK8CoQ3pSq3BJ5oAlySelBI/GkBB6GmHnpigB4JHXmpge9V92Til3YHHOTQBZO7rigk+3vUOce1LknmkA8nHAFJx2pBgd6Tjp0FAC59f0pM8dKbu5HpRk/hQBJnincHioA2DilDYOBTAdnnjrSHHagkGm/WgBM81G3SpCRjFMOAOaAIzn14xSNzwcGlbBFJnHHamIAR2FMPPJ470egpB044oAjOee9NDKDg8jr9aec4yajOOnrQAEjggc01hk8/T605icHj6+tREkc9+1ADizZwBTdxJx+FKScfMce4oHJPHFMQ7dgAmkypHP60zPoePzpCQDgdqYDs5AFNI6mgMAcdKd1PHpTAhIPWoyOBU/fH61Ew7imIi78DNJ69hTzTGz2oATOM9jTtx464xTDgnk0cZ3GmBMCSPcU09lOCM5xTFYfQ5pSADn1pAH3RxSEngngilL9OPypmRgEfjTAVsY470A5wDzj1pDwOelNJycigQnyk4A49KQrzkU7I79aTORigBC2M4X8aZk/ePNPOQep696awxjtigBc5GT1/WlLNuBPINRljnNKMr8woAc2Tgtz9KbtX/wDVSk5J/XNJ0OO+aAGE4JHr09qb8x79ak3HoKjyefamA0oQxB5FRE5PPABqUsc4IpDyeeOO9MCHJPJozilKkd+tN6jOaYhuOSetJ1OM4x7089qjIyc9KAG4GMHFNzwCTTuBxTW4zTEOGR39qAcADNJ1OT6U3PfrTAPukDkj0qQMoyKbuGORnNJ0Ptg0xEu8dieegqTEbH0zUAkyuSAKNxA7+v40gJcYPBwPWm+5oL5HJ5oI744/xpgKpJ61J0OeOKh5/GlDlRwfagCUlh+XpRntTAfU5p2ecA9aAHdOe1J3z60gJAz1FKDkZ9aYg3U4EimmkDdu5oAkBPPvTg3NQ5OM04HHWgCcEnjrmn9R6DFQZxQGx35pATEkc5pVJ6evFM3A04HOCOtADyeoB6Uobuah+6cU/IA5oAk3U8H5c96h3ZPPNKD60DJs/hTwdtQAnGaeGB6c5pWAlzyCKDyAe5qME9utO3dCeaQC+4oyM0D0oJHQ0AOHAxim+1IxI6/hSAsaYD8kGggH60dqbnFACleeabkjinZxyaXAPWmIYDnrS8E0hA6UnIGMUAOBI5p4Y49ajBP6UvbFAH//1+qHcLyTSg8Ypqtzlu1IQB83ryK5zUM96TBPX1pCyg5x1pG6ZNAC5JO3Heg8cnnH6U1mxjvikzyf9qgCUnPPamt0wgJGKTLd6TOeTwM9aYgJwARkHqc00twcEc5+lKdxPPJHP+c1ECThgOnrTAUNnOPXGaQbyQGH+frSMfmOPmx26U1c7sHtzTESKwU7ifpijIB9qjBxkjn6e9KxOMEYJ/pQA9cHIAwDwaGJPfnqfpTG2Hj1PNKWHU0gELcdyD0+tSAFjzzimcYyvJ9Kazc8HFMCX5sZxgD3704dTn+IVFl2XJJNORgMgnNADid3tjimswUZPXsP/r0DOeOD0FN6cMOfr6UgGsxPT2pc7eeopitjn+9nHpRzwB2wKYDiScYJHXpRuIPANN3YUheuaZ1IHTPpTEWN5HUUZqMHsORS5GOPxoAeOBkflRnnB+tNzgenFJnFAEoOakDZ6jFVgdp56VKrZ4pDJh6jvTSVOGpgPBzxS7gOB1oAdnjP403PNNOexoPbn8u9IBeppR157UwnIx60mVzx60wJAc/nRuweajDDPHrS5BNADicimnnrQCCaXI/OgCMjuKacGnHpTCPzpiE6DntTQQPalpv+cUAISMdfwpCMDmkPAz60i84z6cUARjuTSZ4y1P5zTPu/MP1pgM4ODnBFP7cUwjHXt+tNBYcnkZ6UCFznIOaTPHPNKxz7YpPujr70wG7jkqB19aUM2MgdOKaSScAUb/XvQA8HDeuRTTn/AOtR+OKCVz60wGkd/wCVRZqbjFMYcccUxELD9aacZzUnrTM8YpgN3YPr71IHGM9qh2+tKD6DpQIkDAY6+/pQwB6Gmrjq3HFLgZzQMTaSenWkyRwe5pvU59acVLHvQIb2ANG7+7/9aj5uAvSm8detACknFLjjFNIGRjHSlJB74oAaMKSx4pvUcdMU8gng1HgDoKADA5IPIoDL6/nTeSTmnFgDxnmmAvB6mkOCeOPamZyPfNOxt+YHpQAhXdwc8UxhyD6U8kNgD0NNxtAoAj+bblR09O9IVJ59adhc+uKRg23KdfSmIjIGenA703rTwuQCwGe9IVOM0wIzSD0p3tSdBQBEx6Z6etN+9xTygPTg+tMPB4HH9aYg4zzj2pRlcE0h+7knmk49M4/lTAfyDuzx60gYqMN0NIOeRQD2IyKYiTLYzjp6075sZHbmmElhz260wOVwQM5oAmzxn1oKk9OKbk9RxTs8UAJngY7elLkH8KQ53ZHbv9aDuJ2n9KYEgLYpRjJxyaiVj0FPBJ+b160CJeeV/LmkwcEd6iJGBzTwSRwe9ACkkDmkBNKOSBxzTccnmgB45HFKDUfvTgfTmgCTPFPVuATxUIOadk44oAnDZ/GjkGoFJGc9ak3Z/CgB/f8AWnBueBxTcg/jQQRjjpSAcDSg/NyeajHQE0obIwOtAE4Y08HjAqvuIpwIzzQBMCefSng54NVwwang9+ppWGTc455FJjj+lMBxyeRThjr60gEAIJ9KXIAo+XpTcKen4UwHkY5oH1pgYd+1KD69KAHZpOopKXpTEBFJninUhANAH//Q6TPPtSrj7zc0zd/d5pTuYVgaDu/I+961HuA78U48jHQU05OQcdKAAkdcZ6c00nuB1pMgAg9cU0njIoAl4GcnI96VfTrg1EWweOQKcCx46ZoAfnOCeAf61GAjqAenU4pxLdemKBwCFHJHPHamAw4zg89vamchiMYPbPpSA7yVJwAMHvmmkJ9f8+9MQ8g8Mo5P86N3Vien6U3eGGAeR1/CgFiQWUZFAD8g4G7nsMU07j8vXPXimEDouamLEDByO9AEZbIxnp1pOcHaTg0gGBhhx7f560iDrt4xx60AO4GCM5z0p+RngZyev1qNWIXPJPPsaFzjJ4ye1AEm/PbkCkRix9T/AIU3cmeetO3D+IZz07UAD8kdse1Mbg5I4GOtKTkAenvTXw/5d/SgA8w/dHGfWl3ZXvjHOaac5Hr9Kaxycfp6UwHBsKSDke/FSZLHBH0qEgfTPNOAwSR1piJcjHWgk9qjHPDACl56dqQDsnuacp9aj5PI5oBzz0oAmDdMmnBsYzUAPp1p2eaAJemc96XkDNIpzmkJGRjmkMM9sZxTQwJJxRwRmkPHSgBQT93rS7sZNRhgp4pTyw5oAlByOlN9iKj3/N7VJn05piEI5yKb70uR39Kb2oAG60w8dafz0/CmH9KAGHGPamDgc9qcc4zx702mAZGT1NRnvjkU8n8aTOSe1ADDgf5zUZyDnFSN3qMnI4/OgQDAH86bnbx29aQk4+XvQOvJ5oAUAgbW/Ok7/SkDc9KM45PbtTAOPvClDZFMyDlR+NKAevemAuSefX0o9jTAcHnpTsnOBQIaeeDUZx0qXBPJpDnHPSmBCc9DTeT16044HNNIwaYhhJHPX3pchjRyR0puecigB64wQeKXAJx0qME5Pp0FPBIGRigBDnHrSdBk9DSlulIy4HGaAEA4z070DaCcUE4G096QHP0oABj+Lr+lHG35hgCgZwSaZuI+g/SmAE4+bH4Uw8Ef1p+cjB6GggAj3oAjBxgfrSr0OcZpDyfpkUvIzu70AKpycDjvSNxjB4NMBKnHSnMQTjORQApAHvTTxTge55NNPNADSe3T1FNKrkjPGKceSQKb1OegpiIscEY5AH5UzO4/L0qZs5wATk8Y9KYUVQTimAw4PWozk57elTHjqajOPTimIjx3H0peMgEYpx9BQc4+lAEYBU80EMO9OPJxTQNpA6imAoJOQaQYA4/KjlicdaQ5U5HHc0xD1BOff86cDjgnv1qMdeTjNG3jIP0piJlI6L+YpxPGM5qAHt0zinjk85waQyTaecUzvj9aXeSBgUdec0CF3AY4608EDpz+OKiIHbjmlzt+lMCUZPXpSggdc/403OBweaFzg8UAL1ApSx60zPy4604EnrxQADPUUuaDzzSY5560AOzkc04McYFR98UuaAJQQBUmQw5quKd9aAJzkDjpQMCog2ORz2qQHPfk0AKrc/Wl4OeOaTv0NJknk0ASZxShvU+9RZbvTie3WkBOGB9qUMB16dqh+valyR1oAmDevenDHU9qhBx0pwOOvWkMkxx0oPHTpSAk5yacDwPp1oAZnHJpc8UZycGg/wB6gBe+aUGoweeeKdwaYj//0d1SFyT+VPyMEnODUeUye4A5xSqwJ2gisDQeOmBkilxgE/lTeg+lC5xwcUAIW+UjGePSmABsLS7tuce1BIPzdD09qAEbAFNJUd+R0pCRnGfx7UFjz2FAEueOeOKd8xwVx1qHAJz+VOB24H86YDjk9OvOf8iowC/JHAH+RRuKg9Tj+tNJbbhjx2oERsmCM9eOtOkAbI/hbr60hJV+Onp7+2abkhg/XtTAcCA3HT+tSSYbA/nUBlxlj06f59sUu9ec8/TvimBITkYHrj8Oaj7kjgZpSwzxx79aTBx04z1xQAp2thv85oL9cDvz9KTOevH1pN3y9c/hxQA45ZiRyOnvT1PQjPWoefvk9eop288lePrQBNn5cj86TBxhhyKYpyMqQf5UuSR157fSkAnAyT/k1Fng4+n4U4Eqp44B9KaTnkcEfrTELkDJIz6YpDkA4z16U07VOSPzpS3Oc9qYDwcAex7U8Nk8VX3EjgGnZGAaBE3bIoYnFR7uKdk0DHZ7ZxinBsnnpUQ64FIWI4oEWAwzzTicjJqBWGOlPJ9e9IZKDkY6U3BGfSm5544FOLADFIY1h2FN9BS5yeabyB6UxDiQOR3pcnkYpgPel3Y5oAcTxQfbmkyD3pc+lACc4/GkJ4yfSg0nHSmAxsdRTTjpinimnk9aBEfOKCR070p+mKaD9aAEOf4qaeRx3p3GcU0HIwaAI8kYphJIyemalPPHfFMIwOuc0AIMEbgeabnH1pSeM9OaYcHgDn/PWmAoBUk+tIdxPtj8qQnaNy5J/wA5pc4PpQAhyRz0pQcYJ4pCcnk//Xpu449aYEm/sOaTAxg9aQYFG7kE0xARgdOtM608g+tNOfzoAhPcGmsO4qU5HSmY59KYiPPaj5qCPXmmg4z3NAEqtj73+RRnPFQk461Ipxx60AG0Accmm8jqKd04HHFIPfufzoAUE4AGBmk/ix6cCkbGPUUc8ZPPWmAHAAwfwpF6Y/Kg4/PpTRuB5oAUgDk1GT2IzmpN3JOeD2puSfpQAzHoKGzuz17elP8Aujj60w/L/wDqoATdg460obcfSmHnj1pwIyDj2pgOPXk03GM55pvJPyinZHIJoAYQe5+lISSR704+v4UmdoxTEMOBuH+RmmNgDHU/41KRnFNIDHjr60AQng009u9P5HXkjvSEegpiGHHWm4BI9qcaTA+lMBBkAkelNwcnP1p5AIzUY47UAL2xnpR6Uznoc5pc5wc4NMQ/r26UocngCogSAOOhxT8jPPHNMRMCR1ORSKw6E+3FM3cd/wAKQNzhqAJyQOnemgAUhycYPvS545oAQ5B4pwI7H60o5Bx/Om4I4/GgCT3zmgZ9TUYIFPB5zQA8Njhf/r0vfpUe45wB1p2QfyoAdgjnFNDGl6jA/GkznmgBwajPrSHrxSGmIlz29aUH0+lRZpw9qAJlZhg59qcD+HrUGegoyRxmkMsHpk80biDgVGGyBzTwFByaAFXOKfnPNRnjg9aKAJAd3I4pwOeveo88Y/zxRkZ4FICcYx704HBwx4xUPsaM84NAE4IH+FKBzzUOAaeGI49eaQxzAUg6EjGaVSOpNLgYxQB//9LYLc8c0c4pCQBkc80hIP3fbj61iWSdACfXNOJyBxUQYjB65FOy3I9aQx24dOpFMGc4A5HrTscZY4x0qPknjpTAQjCDg8cfSjvkc0ZxngH2NNLLjBwKAHlgoz3OKU87smomORu96VdxwQMmgROBg5B/CmkZ6cGmc4BoxzknH0NADQgfhuSuetN+RgeOnanMyseM++aYvHOMr7UwHq/ybW4NMDOCAgyD1yeBSBmLFj744zTMsPu5z9fWmIeD8xOME8fj60vz8Nu71GN4UHgkDBNL8y5X0554oAX77YPOfTilDFRgDAA/Gk6nI7/rTBySo6HuO9AEi8nHv1pjnB68kdulAIUHJ7cU1W3OeCB2NAEmTkZB65qTcG4GcVCXBHrjrTgwz160APyScLjPr65poOD+dKpb+LvSHg7emeaAGFvQDP6UEJk+gFGM84JJpMHkOOlMBNwOD6mlPTaT1qMHOB607PVQcD2oESY469elPyRwagBz0p+4/wD66AHnn2NNPoOmP1o/nR0zmgBw6cnpTwRyajHqfSm7s8HrQBZGKDy2c8VCrHpTx796Qx556jNNJyKXgcCmk9MmgA9sYxTerZGcgEUDrz0pu7k/lQA/oMjJpQcH04pmSORgY5pC4z9M8daYEuT0NGcU0PnjpQH5xjmgBMnPrQaXNNJ4oENOetNAz+FOJpvQc0AMNNyB+dO4pn8XNMBTkcAcGmMRyf5U44+7Tc5ODg4oAZ8pHPOaYMA+wqUjgk0zkcmgCPkjj16ilOM598c+lGMc/wD16aOOo5NAEmMHJ/WkIGMA0wYzhh270AkE570ADcdOQKCTwKQ8gDNNzgZzyOuaYiTPPAoznimKSRnoaUHB5pgBHPFMIPen57UmDTAhOaaeOlSlO3XFRkAcUCGYJPpRuxwKU0jE4pgAbB/xqTPHH5VBxn2pQx4GaAJiABn8qYQRQDngcj2ozlskdKAGHgAc5607cOmc0nLHik24PfmgBWJLZxQvpTQQfvdaU8H3oADgHj0pP4aDjHrRn06ZoAj6HjrTWGOOtScdKaw6ZFMBuVK8UDbnDc/0pcAdKjwQQR1P+cUCJiBk56DpTBjpSdTzTuAKAGkdCcU3HBxxTm64yKTPGDTAOTj361CwbYO4qVhnJ9KAxIIPegCDbx60zGO1TMpLY56daj5wKYhpwRgU3GBg08Yxmm4pgMPJz0pAqnJ6+tSYx1HGaZjHSgQ0E44pMsDyOtOxx0pNxB9B/WmAowWzTs8+oNRjA4HUUpY5xgUxEgbPU0pY+vT+dNJ+XPp2pARg5/WgCUNkcU/BI3cevFVy2M7QePyp6sSvf09KAHnpgcUuSM980nHakzwKAHBse1O3K3PamAZ+g5oHHX0oAk4AwKFbtTFanYHpxQBIMDg96D370zPP5UoI60ALx/hQTjkUAljz3oORTEOBozxg0zNOoAdzxn6VIGP8XWoQRS+9AE4YE896kyMcVUDGpg2Tx0pDH5wPagHtik4Ix3pWX+7+tADhmlHQVHj+9Ti3PvQA4N9acrHrUYP8NKPSgCbPH1pdx4z0qLd6U8daQH//09XqDn8jTck898+tG7JwRyB2pM7Rnv71iWPLNj1H9ad+uM1CWwucD86dkEDFAEjtjp3/AJU3gDn5TjrRnsOaXjPPNAxCepXiomByeR0oPPIP3sYA6UHC9D170CFAHUUmWDYH4Y9aQ4LZ659OKTKg4PfrTAkG4gc547/0oyCB2/rTA2Pu8EZ4o3fL8vX3oAeeWGOSf88UwcZJ60oJ5Z+D2+tG7bknP+FADWJB7jcB3FROWKjOQD+dOIxyOeAcD1qIksB2BP8AnNMROCCNwxk9Me1NBJyBnknimnaW3RnoP1FRjDHHIIPbpTAsLnJAOOOPf2/KmhVwCOCefamhgRnuv+eaMqCQBk9evFAD/vEN1PQ/SkcnblR1/wD11Bj+A/j+NOLMFK5yM/jQA/OTuJoyoH97tmo1+XjOf50vzMMPyDxQBIpPUcdqeCBxkio8ryBwaXIIOeaAFA5xnk03dj6UAHPXkUw5JO3pQAZBGfSlLAEetIW46d+vrUZOOo/GmIlBIxjv+lIWHQnn0pvOfQUrYzn0oAkBx78U4kj5jUQxnPel57UAOPHTvQD2xRnPt2pM96AHjqeacOtQ5weaeD1oAl3U4FSMVDu4p2RyT+FICQqenWmNgfKBS7upHBpmPWgY7jvTdy5Jxg0HjgUh55J4FADs5+YU4N1wah6HjpS54yenWgRKCQDTSaTdkZFKTx0oATOaTGOlKTxx3pD1oAYeTSHpml5PvTSe9MBhweKDuPTHHrSnHSmjoKAAkYJ9ab9c0pxgZ4xSEA96AGdRTM9z9ak5z7UxjjP50AMxk8cfzoBGTx1xRg5yuaTp060ASHgYpnXvQTgYpAVwaYCcgkcUpO04B4NNzk4puR6GmIkHIyaUZxjHFMB7ml3deelACkdD60wrTgcjmjtimBDtPcU09KlPPNMoEMIPT61Hz2qTHrSHGeaYDR1qTp155qHP4ZpwPagB/wB4UhzjPbvSbskZODTgOuTgelADBnoTxSYzmnnLc/nQMdsigBOCOlRlT9fanFtpyfwpcjdn86AEyeooHQZ4NGc8DpS545/OmBEeep6U0kHrUvAHXNR9j7UCG/MAB296QEDg/nRhun60hb8KAJVGRk/Tmm9sE/8A66ZkjnOR3pfp0HNADsMeQeKawJz/ACpT1yOM0H+dMBgOMUMCQAOacT27U0nB60CIyD97qKaQPXk1LnHQ5pmMjJHP6mmBF7GkPSnkevFNI5NMQ05B4ppx0pxx0pAOxoAaVbrxQQcgUFew6CmccelMB5OM5GR0Apcg49+9MGByKUAAUxDgTnPanjb/AFqME5z2pTxyBQBJnB29CKXJPWmbu5OKefXGaAHA8+tHUcdabwTil6g9hQAe1PBzwabj05o6jj8aAHDr+lOxjPNR57CnA/wn8aAJMKDkHvSE89abg4xSqePWgBSB+FL0HAx9aOpyO9KcYxTATNOpuMcmk4PegQ/IxShjnimZpwOOlAEgbGacGHHftUWf1pQQKAJyM5waTI/Go8/lT9wOM0hjgB9aUHApD7dDTeM8UASHBFL9aYMnpS7u/wCdAH//1NHIySByepoZiw68daaZBgjsv6/U00sO3NYljgQMgj+tG7HOfy/zxTAQrfMOvHrQGG3GQaYEwbH40vfjj1qPIAz1OafnJ4HFIBDgkcEYpoJAx04p2STjt6eppm4qduOOn1oATjOM/n9KZg8CnvgfNg89qYcDrgnpTAMPkDPHenE87Rxg1Grc5/yacwGeOf50ASkA++aMjHA5/Ko1Prmnnk5B9CaAGswySTg9Khzzg/5zU2OrEZByKY6jaOfrTERlWIBGeQenpTlHz5J68gf/AF6GBVcp06ZNN3tF6YzzntTAXIycevP4dad1G0A8f403c20HcBjjHb2pdybSSOeSPWgBpY9TkH9acFyuG5zSFtx54o4IyOnv1zQAAZ+XoTj8Kbghske3SlYdMd+c0zcRkDk9KAHEDPOOeadk5IH6VGDnpz65pwGBjNAiRD39cUvyjgimZwMDrQCeP170DGnOQp78ZphHvkVJuBznBzUZ4IweKYgznpQxI5o5x9aQ9PagB5wPmPBPFO/iqMHcTwTSjHegCbNHJ71GW7Uu845oAX2oyTg03OKXn/8AVQAu849KlBqDApwPPNAE2d3XtS5qPOB70c5FIBzYIPbFNz3HvS5B4P8A+umnr0oAdnijJx0/Km/xFfQ8UmaAFB7+pFLuB6VGMgZzyaVQQSR+OaYDzjqKU9c+lN3Z96Mk4JpAHXjpimnBNKevpQcY96YDDyKae2Rin+2KYeaAE5ORimchsdfpTjnp603txQAmDnik5PBpc5G2mjkUAMIBppG7r6VIexFRn16GgBoHI4ppOOgJp2OOtABzgGmA0bup9fSnHbgkcUnO3GelN+Y/LQAoyOOtJnJ9DilJzyOlNYAjHamIfu7U4HHv2qM4xxS0AOOO1MIPJH1/Gnde1JnvTAYT3ppp/HI9KbTER5HamnrtIp5IJzTc560AN6HqDTsgjrx703qfSk9+aYEoyKQ8/MO4pAd2Pag88nn+lIBSNw47UgyPc0bccUhbBxTATOBx6U3OTinH0NIKAEzyPWlJOBSFT1x0pBnHFAh2cHFMzzjFOX0pGX1oAZ9eKb82aXjGCKQldxPORTAXJxgH3NKOOMc03Oeg4FIP09qAJCR1NRkc8GnDHtSYwaADjPJpM4I7g0uOeelJnjFAgbByMdajKhVODnHFOxg8Cggjpx+FMCD/AApG61KQOo78UxgRyaYhnbmm9sU+kHP0pgRE8YPalGOhp/amcd6AGgY68U/689qTOMUjdaYhwYfjSnk885FMBOTinDA69aAHjtTuvOaZ2pwIxg80APVh3FKpxznoaiJJyTxingg8rQA4gjrSdOKTdkkd6XnoaAHbiMZ5pRzg5po6+1GcnA6UAPBPUflUgOck8e1RAgcilDc+tAEgIODSnH51HjAz0x3pQcYFADgB35pM88UE5HFGOcelMQ4GjOeKZxSigCTFAPJ6imgmlz79aAJVbFSbueKr+uacGx0osBKeMH16UmMHH480m/Ipduf0pAf/1b5+UcDI5HtimbQOQOnPSlJJyV59KaQSuGGO1ZFjyVK565496aSqgY7elNb5ARngd+hzTQc+vpQA8NuOB2pwY8g9Mc1HnaTjgkZzQckdc8dPagCUccU3kHpn+maASfpSMRjdwSPzoACflBJ460xscZ4zzTiWJ5Jz6e1NLfMDx+NADsFgR2FM5Jz/AJxTXbaMtzn0pQSW4JoAcC2S3X+lHQZAyOM/Wmhsjg8CkLEnCD/61MCXvkYpuQeCMdMUoxjBOCOaQEYwCB3P/wCugQxjt4xyOMccUjyhsZGB3z+lPOQDxzxUe0Dpgev+FMBpGDjp6f59adwUHqDg/hTHTGdp59PwxS42LtBy2PrQA/aBjHHrj1ppGSR04HHX9aACvJBGcYA70ZP3Vzx+XNMQqFcbeeOx7Gm7sjFBIyRxzx7igHvnp2x6UgDOODnpwe1BPGRjp3pOFbdjGaTAB54oAkG7HFLuJbmox156UA8nIpgPAxkjv/KkPI9D60AY96Td26GgBvPek4HIFDE8sOlJyDyKAFzjr+tOB/vVHwOnejPOe4oAcDT88+1MPv7UgOBxTAnzTSccZ6U3IB4pwIPTrSATI6U5fUU3I6mkJoAlyDx/OnKcc1HwKXPagCX0pOvTtTc5HNBIxikAcUhOOlLkmm9uOtAAwzz7dKVi3GKZn160H5sYpgODEY9DTgcjJqIZCg4+bp6U7dngDk0APyD0NFMPP4UvABoAG/OkFOJphOBzQAh6CmnPWnknGKYRQAwZzjGKTqcU5uDTMc5pgBORimjGcU6m9OeuKAGYBFMJGcD0p+AeTTMGgABJxn8aQ4+72o3A5PSkGTQAhJH0Pp1pwyRzwKTIA5ppIH40xDxx05xTetHOPTNDNj65oAXpSgdhUY4OM0o4zTAceuRQTng0mT2pSQBmgQwjmm/yp+M00jH4UwGN0xTBTzyabwRkUAIWC96NwBwR15pDx70337CmBIvoD1pNo5+tIDjBwRTgc8UgEXnj0owRyO9KCBke1Jz0pgKc45/H6U3p/Ok7++aO2f0oEGDnIPFHP1NKcEc00kA5oACKZtOOe/Wn53YFHB6ng0AMHTjHuKYPlyRzipNvSmHjgUwAnPPNH0owTwBTSTxk+3FADgexOTR9eM0wYBzyKf29hQAhHUU0nJAPJApw5yc4pG684pgGOTTcZoP3ufWnEscmgRAV5wKaQPyqYjPPQ9s03DMSBx9aYiHr1pCD2qTjrSc0wGU05p1BoAYP5d6XceBmjGO1J0+tMQq8nI6jtTsjb7dqYSRz1NJvO7FAE2c4BJFKWPToPpUfBbrwaUdqYEgYZ78UoyepxnNRhgOoFO68NQBIWJG7OBSU3IzjGPenbiTwOBSAcMmlB796aMflQMk5pgO3ZOexqQjOD6d6hBx/OlyfwoAlGeppeeh70wHvjFL1OTSAcMY5owAfrSbhmjdTEH1pwPpTQM0buKAH5pc81GDmnA0APBPSnhsdD1qLpR15FAH/1rQXGADnFAbj2pwOc88j8qj8zGQpIOB+tZFitgZYZPemkgncenQ0oJzkc5NM5A3Hg0APGQ2Tzkdz0FMLHPuR29KXKsCORjpSDDHB6AUASbyeKdkAc9euKhU88ZOOtOJGcZ7dqAJMgY284qP2OeaXJHYcd6TPUk46+1ADGJIJGKbhj0AAx17UvJPA56c0ZPPHFMBBkDGc57Uqsc5fpj60Db2HWjjHf14HWgRIOmcHihWDA7gDUaHjB6U7PO3nHc0ADMp6DB/pTGBLEdB3A+tK53glePf9ablnP07+1MB3QZfBB746UwN5Yx1BPX1pqsByRwM/400sq9+vJH9PxoAehCjfn73QGm5YNx6dfT/PalU4AYgFccHvSKXU8nH+OKYiXYfL65x+dN3gEjsMimqHJIJ+Y/yowDH7dKAEHzYbOelLnGAD7n2pOM/Ln160hx26HFAD+c5P+frTc54weOlMPPPJHenbsHg9v1oAePmI9acO4HWo88HIwD607qNooAVjgcetMzkkZ+lLgYGeuOaRhg/TrigBpUde55o6EkcUMVxnuaYSe1MB24k4zTsn1PvTM46k4oPK5oAeOPwp+elQg8YHNOGAf0oAlyOopp5470mcD3o9xQA70p3XrUeaM9sUASqeKX2qMcU7IHFIB+cUmSevTtijcM4PNAPfFAAD29qb1HFPyMY9ai4zgUAAOSD1p4+vHam9B1/+vTd2CTjkUASjtx3pc7jzUJIDHdSgDbz+VAEh5NJnueKQdTmkPrnigAz2FBo9abkdqAE44zTTzzTicj3pOcUwI+3tQcDrS98Uh5wKAE4644pp6/WloGR+dAERx3pDjAAqQjP+FR8A0AMzjvj3pcnGQeKMAUHnrTATJxgUmQRkdDQBznPWgZwc0CFzg+3vRkbsntRj1pG+lADie9G7NMJGeKQHn60xEoNNOCaAaOelACEZ5pjeuKkOetMPp0pgRkfhTCMcVLx1ptAEZ9OaVTg56H1oxQeBn8KYg4K5p455PbvUfQcc04Hnj8qAFPP3fzpB654pV4Oc0EYPHNADB9TSnBpWz/jSFAKAGnB59elOOMcUuNoOeOKjAK9ef6UAPJ4zTcdzzSg4yB+IpCMdOtADeF46U0gDr/nFOYEjJzSH1pgIB/CeppAMEKeKDyMUn3c4oAeOTz2/Wk49aaSQpIGKNw4/zzQAf1oAOcGlGD0/Glx3piGYGOuc03rnOadwaQZzxQAhX+VRkDr1FTYzk80zGeP0pgQ9Ov4Ud6fjgn8KaRjr39KYhg46U0gdqkxnpTfwoAaPQUmMdetL1GDRgimITkZxQTjr9PekBPQ9KCSOnfpQBIG9qcCMYHeocj0p2TjGO3GKYiU8jnAoByM5zTd2AQTxilBPBI64oAkHT0oHocUwNnoORTiR74P86BkgGcqe9N45pOQwIpx6daQBnjkU5Sc8nim/KeDRTESZ5zSr1qMnrjmnA+uc0APPFKCDTCemKOR+FADiKKXHOKTr3oAA3GadTT7UuMDigD//17XT8T0poXHT+fWg+jZP4c0ZUj5ck/qRWRZGc9OPypT9wAAEjsfakyScjp60DhsY68/jQAZUAkgD1xTAw5Ge3T60Eq55ANDHA6cA0xDhkHnnr2OMUoVQMcUwHgLkc+tKuT1OT60DJBk5BH4Un3c+g6UijjrnvSBtynjkHpQAhY5JxjA6mhj2A46nHT/Ipx2BeaY2W65AI6UAITjNKSeR29vpUZYgZIwc9aQHqMUCJN2OvfqaXIJ/lTBuB6dOgoBHTHFAE3UfMM4A4pp/vdO3IpA/fn60HcTuz2zTAZhScMPf86PkyDxkHjNKucnI/wD1VGRgnIzmgQjMqvsHQ1IdpYdaiP3lyASPek5LAE/QjtTAk6rnGQOPTp0pSQGA7D+vrTGOchugHp3/AM9KEUY3YZTQAuc5YcADv0qNfm5AJNSMFHTr2/CkHYjGSMigBTnAxxjqCfSgH8+9DvhQwP40g2kAE884BoACcjIp27AwOtRgbXwMmgEpx+PtQA4cHHPPQ045XBJ478U0Nj2Bweacp5PbnvQA047dKQ0pbI/Sm+w+tMBpJ4z1oJHI60FuoB603p34oAkXjp0o78daZn/JpcnqfwFAEu4jGO9LnoBTAcGgE0AP5pM4/Ckx2pQT16DNADutAprH60AjFAD8mnDgVGOlO5AxSAdknvSHrRnnij3PegBPrzRx3pBgcn86TqBjigAbdkEc/SlzheO3p1ppJzjtS5z60AKjbsbsZp4PB9KiGRjBp3XJ6YoAd93r60A4pAScj0oPTrTAQ9aTPal+9k00jmgBD6U3tT+tMPtQAw8Un1p5znAqP2oELg4+lNI5yvWlyR9aaD+dAxDxUedoPtUhPPYimEHrjNMQ0fpRkD6UEnGRScj6+lAClvzPrSDn5ifekxnn8qcTQA3ryeKXg+lJweBSdD0pgLkjFPz3qIkk9KcDn2oEOo9qQfSjmgBMZPNM+lSYpuPUUwGE4HNNHPOKcaTGfamA09MUmeQKUimkdcUCHZzx0p2ce+Kix0Ipe+Me1AEqkk8daYfQ/lSrj6E0pGe9ADD1yBikyQRk8U8r7g4FNPP9KAFzlsk9aaOOM0Fjj5qMg9eKAEySMHmlPPXmk7DoeaBg9+AaYDSoprD9alOe+OaYRnnP0oAZ169RTVJqQjvnmmgE5zQAAjJxjml59ufWmcdBxQQVP0pgSZz0pnt0zQCWP1oOCf5UCEweufakOccdaXlaM5wc80ANOSp96TGevWn85xTV+Y9OKYiMr/8Aqpp4qU89DgCmHnj1pgMoPIxQcdKTOaAG8k803huR1p/Q0mBnNMQdRg0gbaMfpRgUZ5xQABsng1J1PNRAYPt3p3T8aYEnfOcDrShsnP8A+qoy1A+U5H5dqBE27nI5FL1ORUfBHPNOVuBg+34UASfX60E+uabnPFLkL1pDFPB45oyQcjmkHXilx3piHe1OBzxUeePalzzQBJuB9zR3pv6Zo6DHWgCQcmlxTAR0pQaAP//QttuztwMjvTCyjCpjnk88fSntnngnmoAycnbkDnp/jWRYMcEMeAfxzQ+OWBwKaxBAbqMdD6UiFWBBAxjPSgAAXtzjv3pucAZyCf6U1G5AORk0pB+9t/HqPr+dMQvHUcCnbzkDoDzTcsE+XAwcc+gpqknls8HjH8qAJVIIwO/f1pVLDktUKsc5XrjPT0p4XaOT34waAHEJzxz6f400/Njb9eKUnB56Z4P+NI+3PJHH8qAEY9h69fWmNg4bAGetHB/H/PFNPDcnnPegAOAQQPrThwcjoO1NP93qRTWyev44pgTjJ54welDdOvFR8A8elO3HODx9aAHFiQGH+RSHgZPXnJ9KDnI29O9NdATnPagBjHjp+Xr70gRdu9TjI4peAdxzx6U1AFOCBk0xASAxC8+h+vpTsn+Hk1GWJKgHAGOowcdKUOfvAE59fSgCViCN3qMUhIAU9D3zUYkLDoeeO3BocZPPT/69ADmU4wOR60YJ4Pp1pFU49jTOTyO3J/z70wHtkAnv+tAbn19qQAdW/GmtgDI6elADxkgk08Hmo85HynFNGVH0pASYwp3evakIOTj9aaAc4Y9eKUE5wOT/APWpgByRkUmV70vINJyRzQAnf60nU8igHceaQtzk0ASc5GKFPemE7elODDgdcUCH+1LwajBJJPr0pVJxzQA/J/wpOMgUgBwSTSemKAHlgacT0xUQ69aeCcUDH5PUU8Hj3qHPOTTw2O1ADuMYpMdR7UnrQc9KQBn8aTGAaRs0n0PPvQAck/SkU5wMk96XPGBTeAB2/rTAl4I+XOM0me/pTNwAz6c0/PGSMUAGP1oOABjvRyBg/nQTzgUANHvQPTpQMmg8jIoAYeOKbyaeenrTTyfSgBhzj60mcCnc/hTTkgUxCdOtIBgc96Untmkx196AGEDp6UxmA59al9jUZwTxQA3GORmgEg5pcDnNNHHSgBSV79O9B6fLzTRzwTS0wFGOvejJxSHHHOPSmnjk+lAh475pQQSKjP1peepGKAJOKTpTBjrTuvWmAhH400jPFPPTBpoBoAjOfxpDz1qQ46UwcCmIbxnmm9Djmn4HGKSgA3Gj+lDZpp/OgCTcCMHrRyetNz6DpTuooATtg8dqaPm5px45NNPApgJ365oKknI5/wDrU4gZAx9aTODk+tADAT3pwHGaU4ZsU3tycYoAMHv6Uw9OPapfbGO1MIz0/WgBmCOnakO7v2p2MCm44PGPWgBOO/ajtnIoA9KQcfjTESck+wxTeKTJ/Wnnr0zx0oAbjA+tG0Yo4FGPWgBrYOKGH4Yozzz3NJn5sUwGketMxU3Q/NRjI47UCK+OKTFSMCO1M470wEPWmkcinnmmnqBTEIMZP4UnGcGlA4zSHGMnNADue/rQGIGKbzj1o9xTAkzTgRzxxUOcdO1OByPpQIlBwMe9L7npUYJ69TTskYyaAJVPPIpS3IIqLPr3pQTjj86Bknek7cCjjGe9B5FACqaUHnBpvelzQIeMEEU4Hj+dR55peuDmgD//0bLg4479TnJxVeT72C2RjmrDqc/JwBTMnOOCT+dZFkeQ3yrwASKaNxxzgVIcAE4x1P581AvCkoMn0pgBLK/bmnbkLfMOn4CmBtvyk57f16mjB5AOcdvrQIdySR6flUYPOSOSe/tQCAMDGeue3NL90YDD15pgOD54xnGefandhj/9VRZJ+7nbycjvQh6OBjjpnjnvSAlA4z35waONw9vam7ieD6dqBjBXqKAEY/ifT0/Om4xwMj60pAPy9j6U0g4APHrz0pgNCkgkjvSgsDjFKecHP400kZ7+nWgBcnhc05fc81HnIJ7jjNL/AA8UCJe2Ka3BHfigHp0NKM4+bgZoAbyo4Oe4qPLZAwKkx/Ce/IqNvu5YEDGBTAfxjjqf8mmKFYA7s5FAYZ3MDyP6U1mbHQYPoKAHsh6E89P6Uu/LE7fu+tNQjJYgnt0zTdxXKgflTAlbaVAGRTAAc4wfelIQqMn2OO1JwFOR1x04oAOeRnjNNJ+cZNBALBQOBweKB8xx2oAQLwV7U7nn8qTHpgDB6UA5I9RQAuc8jpnHNOJJxUecde/86cGOMjv1oAdknoaYc4p2RwKRsNmgBM8DFNOe3/16Q0D0piAdetPzjhjn0phOBk8Zo3DtgUAOyDjGeuafnkVFuC9OTTsnGTQBJnsKBwaYCe9KCSMUAO6HNGe5pOfypoGcH/JoAfkgU9TnrUWSOKcDjk0hkm7vS1GvSl3DOKAFxSH1NLjAppPFACgnqOKb0GTg0pz1FJj5eR+FABkgepzzT9xzkVGOOf5U4E9aAHBsnGeKM4bA/Go+W4NOJOcUAOxnJ9qRuOlOGMYPWmj9O9ACD09KTAx6U4jNNOKBDCB0ppznAFO7Y6UhFMBvWjIo6U3nGaAAgZ5phXv3p/ftSZoAZn1OT600inH0x7UH09aAI+/1oPHXvQwBGO9N57dKYC5yeeKMZYjoKQHnIo4zmgB3AHPem59OlIpP40v1NAgJApcjtTMYpBjk/jQBKOmKO2c03IBFLTAXimnnilHNLxQBHjnim+1Px2FNP1piGnpTe+cU/wCvam4oAOlLuBApvqaRSB8p596YEwYkYz05ph+b7pFR57n171LuHGD+dADee/XNN7Z61IcdD060zn25oAXjFIem7GelByTz2oBZhigBOKdnJ603kggj/wCtSKeDn9aAH44yelR44z60Z4yadnIHrQBF0PFOOPvE+1PI9evpUeMjmmA0ZyQaQDI/HNL9M5pCAeSf8igQ8cDAHekGenpTCVJ9aU4OBnFADyCQPemnrS+2aB6dcd6AEB9aTHOaUikA/lTAMAHnAphXvTxyTuoIHUCgRBt70hz0qYjPbFMIwOOlMCL2peoxS9Rmm570xCDPNGBjFKaQ4I7UAB9P1oU5700+lKeDxTAdn2p27PbOaYPWkHyj1oETEnNLkDtg0zOKXcwwT0oAfyOfSnZxntxTQcAjvSfMKAJCc8igdMCmj2p4PQdqAE6jilHr2pM4PHSjnH1oA//StOG3Hc3HpTCB37Yp7EsQVPeonBBBB574zWJY1gNxOcD+dRquGHYHt708k5C59+nrTCWPfj9KYCMfmO/j3puSDgjqeDSMcD0ORTQMOe3seQf0piHkAcqOfc1GwGcrwR/k0rDIwoHHPvTdw/u4xwf/AK1MB4YfeIwaTO4n/IpiAHLr0JznHanBjg5H4UAP52YXgdMU/bnGfXvUJJyAB1/KgDA44/nQA/Azjt6UwnaMdT2p38WDwR1ANMbb98c9M/X/AOtQAuS2Aenp601lHOOMHpR8qjk5/wAaQENzg89vegBgwMZOPWnDAOe2TSHOQGx0pAOOPSmIeGyPp/I08nj19Kj3YGAOKVcg/NzQAvBb2FL1JCn6gmjB6en9aQAH3yc0ANQFThW556+9NAZRk9WHbipJF3HBOP8AGmfMBt6gDqaAFyQuG700vnnb7cc5/KoyPkXGACenPWpVIQ46D296YCsecZ6DrQpXbjIwOPrSHGBwMZoIJbAUHA/nQABSByQAD26Ugk5HvQjYUqpzz06UHAz1BPTHNADHK7Rg9KXcAN3PtignjDd+lIc9DwaAHHkdM96XDnn9BUQyoyTin7znryKAHDJAYHB/lSjIPJ5NMHJpWJ3EY/CgBTnNNB3dadg9OnvTSKAGZ9KAQCN2BmgnP0owSO1MQuSAcAUq4zntUecAinigB27PUU9ST171F0O78qXOBigCTJP4Uf7NNBz+FKT0FAC0cd6TqMUnPegBwPrT+Pzpg6UmexpAS+gpe2B1po+vWjoKBhk9u9B+bmjtkdaM46H6UAJywyKQH1o9KaRg96AFIz65p/BPPOai6nI+lJgDoOc0CJjgkk/SlwOKYORx/wDWoU84bjHvQA71yKTNADE/WkZuee9MBc+tN4OT2obk56Y6UHsfagBpz9aaBj3p/vnimnrQAymk88CnH86ackcUAL2ppAHalzg80mQTQAyk6dO9OIphA6jmgBpzxSAjrS5703n1pgOHtS9uO9Mz680pI6UCF5PWkPrRnnIpCwx05+lAC7gRilBz3pnJOSad3pgO3Zo5FJS/jQAe9If60o9qQnPFMBpppHpTjyOKb25oENz1/Sm89qeSOtIfXrTAYC3T1NOUrn1xQeOe9JnpkcUAOJGO3FOBJNRkgHPSlGSfqeKAAkA5z9aXj8aTJGSKBu4oAF+Xj0pwIBOBmm4yDTd204/OgBx4OR09qb178+9O43c8ZpGGDhs4oAdg46UjAEAg0zPO3NO4PXpQAw5ByKOB+NKRn5hzTdpPQ0xCYGcChvUelJnb0OQO9JyOG70AKDgZOaXJH59aaScYA47Ue9ADsnIxQc/Tim55BPWl9wO/NAARSY4yOKXI7c0gzj2pgL1FNYf3qduxzyaQ+tAiNlxzTCAal2nikK8UwIcUvfilIAOaTBpiEIOcntTTyacaT60AJkj6UmBxilwKTj7tMBTkHPWnZpmcAZ60cA4PegRLnPHcU4frUa9f8aUH0oAlyRRknOfwqPJ9etOBI5oAkBB9Mil5Jx61GoBJ65+tPJIwfwoA/9OfquVyBnn2pWBKkv0H60Bs7iRjnH1xUZU4y5+bjFYlkbA7W46/4+tM5Iz1PoefepgWHybhwOcnk1A+1iA5OehA/OmAjNuyTjrx/wDXppZkO3BK9jSgj7vU9eT/ACpjZIyOBnvz/k0xCk5wRz6k9hTXbd9wE8/hTi68L0yabuKjg454pgDbQOT9PqKGfH8vWk5YlWOT2+lBGGDZyAf1oAVWLYz2/wAKUkDknp+nvzTMjkHJxSkZPB9B09KAHdPmI5b+n1pxOT8wz6UwuSSevHSk5YKV+g70AOODgMOnGKbkY2tnOKM/KTn5gKacbd7dDQAwsck5p44UA5z+lMKIBkg0nB6Z56+tMQE5PX0p+/IIPNN35x6jilBJ9x3oAlUZx1z/AIUMO/4UwHp+NLuJGw8+vr9aAFJw2cYABqNm3tgdB19afhkHXP8APFRN93+gxQA4x5xtOOQTTVADgEdeevYVHxtyOR6Ht3pWPyCTk8gflTAkxuYcgYOMZpytlSB1HrUbHbyoJB6+1O3Edfxx6UAGXOMdDSsMPvz0oLkL/n8aP4cDGc5H1oATPHy+x+tI38LDp1//AF0pyw2r260jj5eM0AGMkZI/xpo+XJxj3pT3I7ZP/wBamgFhjtTEKcHpTsMTwaZkA4zxQffp2pASDkcE0HpnuKZnjOcil3ev196Bh1PFN3EU7jIxUZHPvTELnvR2OaTHrQD6HigB+D0P50pwByevNRnHSlUjsCaAJDux7UoOePWo93zBQe1OoAfnH3aQ5zgUAgcUhyTg0ALz1oyQeabg96O2KAJOvFPzyfSouRzS9ee1AEhzxnilwTTQexo4H+FIBOcYNIRzk07rimkZ4PegBMfNijGMkn/Jo5Bz703jkjqaAFBBUZ6CndDx2pu7qPWj6cZ70wJCewBoIBxTWIz7Up4wP5UAIfpR1GKOmM0vUmgBAOMGmn1pc0n160ANPANNp7Gmn2FADTjNJ9KU5zzzTaAAnrTeM07igjnBpgR43UzHrwaeRgU0jnFADT2pOMZHH86cR603PHH4UAKOFyKXcc80wkdaX3oEHYA/SkHT0pRkCkpgLxjkde9AbpTCCDTsgECgB4IpckUzpTqAFPWm+lLmjimIb9OlN/pTjzxSEelADCOxpMYPrSmj6UwEP96mj68ntTj2ApO/PNADsgcil7D0qMdBTtwxz3oAMsVwKD14pc9x60YwPXPFADdxwcY96XOAT69ulGAwLflTT+HpQAuNw54/pScDJHP8qUnPtjrSgZHTn+dACAgqMGg49eaQ9elOBwMetAERHNMxjr+dS4XHUUbScZ60xEZBAAFGOCfSnY9eMUmPegBnPfvTx0x1xTSBnjmkzt46UAO4/KlbPemgil96YCZ7LRkij5lPtS8igQc9D0pAOx6Cgd+aQnGR6UABx/n1phXnFSdQD3FIQG+nrTAib0/OmnmpCBjPamEUxDccYpMU7H/1qQ8Z/SgBAO1GBwDS4oI5z2FMBuOgNKTjgUdDzSUCJAwxg96CTjHf+lN9x+NA45NAEo60/knA/wAmq4Yk47VIDg4pgf/UtF/m2nvyKjZBu65PXNPJVUDDtUCBcY9+c1kWKfmG4nIX/PNQH26N3IqVlzkL1HYGkbtkAgg8+nvQBDgHAcflUeCxJOBjvUnds5AHX29KYSpYbQQQKYhDwwbpjtTclDwfl607hsk8HsPamAgnIyM8j1NMB21Qw6kHmk3Fhxnn8qaxIIC5PvTGIOVIyeBTESkAnIHWlJ7Nz0NIMAAjnj+VNXaScc+tAD/lOV5288/WnkBu+B1qDLMcjoB+GakByc9j1pAKSQARz61E5boeOnvTvTB+XGce1JkMckfKfp/OgBjbiAwPNJgkkE4p78jcT1GB9aax4H0yaYCFuM9O34Uc5weOxxTe2OpHTNAyw69KYDwc4XFSDJGO+ef/ANdRA49yaUHB4GfekBKWyOeBTT0JIxnrSBcAZpSCTuJ/yaAI2J4YryD2o5BAzx7dqUsBkg8H9aA/7z5ugPT2xTAQHkA84zmk+6FzyV6444oYfNhRwfxpNr5wDkdT/hQArEDccZwcilUbj8w+mOlMcqSC3BA49M0v3j8pwaYh6+rDHGKY2MDPOPShcluDwBz9adwAVbk/p26UgGtwMdiOaU9gCc+9G/PBHB9elMIJPbGe1MB+ckDPSjsCeT160zbj7nt+VHAAFADwQeKBxUecj5uvWjceuM0AShuvp6U0kfj29qABjJpozQAvUZpoGOKUkDHNNI5oAXjOR1o4zx+VNPXj8KQegpgSIABzn2p3H3c+1RDJ6nmnBievWkBIMDmlB7U3pj0pcc+9ACnpignI5oGcYNIRx7igBef60vIpvP0pQB3oAkHbFJnnrUeaf70APHpQTjgGmZozQAuM9eKb8vbtTuo/rSHkZFADTkgcnA9KOhz0yaCOc9KOnvzQAvJ47U5W3DP60zOew4pMjOf0FAEgO4A0pOaYDkHn8KXn0xQA6kP5UpOTxTPfrQAuM80hopOg5oAYetNI5x2qTP8A+qmkUAM96OPzpWwR6U080wCmjkYJpf6UuDjJNAEbA4xUYwOOmKfkbuKDz1oEMyMUKe55pSvXFNYjoR+FACjHQdqDnP49KTIHHpS7snNAAexpCetGc4ozTABnHFLn+GjFNBBx2OKAHdPrS9e9NBxSgjOKYC5FB54pR60nSgQ05NNOMClwaXAAzQAz2xSHpTsZximjpyOlMBp64o4HP6UuewpDwOaAFzzlRTicjKgVHklqcPp1oAcOfbNL82TkU1Tt6/SjqcigAzzg0noeTRjjJPejjOTxTAB6g5prHHJH1pwJI9jSE5z70CAdhjIoPv0/SlCnnrjpxTTlcAkc0AHB/DpTCqninqc5Hp2pcA8rQBHjIz3FN+UDPWpD1wKYQAc0AIBgZFBAFKQcYFNxnpQA8ncMYBpMDpSk03PGc96YCj3pD1oHqaG9qBBnn3NHXg0uAe1NOe1ACkADjqDSFc0pGevFHQfSmBGQB1603FS8Fce1MI696YiPjNIRk5p2PWg+lADTwKQ8nHNO7GgA0wG5yOKXr/jSH3o5xmgQ4ccdqBgHDdab1pRgdaAP/9WUt95lP5UjEbv1/wD1UpYkjaOOaUruYjP1rIsiym7d0P3T7DrTGDfeYYPQAn2qTrlW7dfemcqN33geuaAGMfm56Hof8ajcbi3QDj6Yp7fKNxHPbHTmowzAEdR6UxCfKFGT16Co2Jzx24/WlwRwQOn/ANekIK8E8Dp/jTAVsMN+eKZjJJPPvQTwVB7YFC7h8vTp1piHHrhsHApi4JyBjGaMkcDrz/8AWp2WAyCevSgA58wnBHqaeBg7z0HU9c1Hzx37mnZCLkkfyFADzzyMZ/SmnAA4H09KRxwMcd+KCSeMZoAT5ieOc4/CmZPVBwOpNSN0pjn5T2zwcUARnJO7GO31zTjgd/qKQlCee2Mf0phO3k8k8GgBw3ZIHal3biTigHgL36UAcDsKYEmSQVzxSAggY6EVGo3EEZqTb8xx2oAQA9T17U0njDc88UH1APf86ccAEECgBpPYn/PekPT5eBjnt+tKxCHKnNR53ZJUg4wc9fbmgCQFS3OCOgpm45+UBcdPemqdoO04A9f51IAvQ8nHOcUxCBSqtweecihlQjYDkg8H0pQSvHUjv6mjGDnPOKAA4bKH6Ui7gpGOh+gNK2Rljkj0oODj0z3yKAGlTkc/jSDCj5vwpFAGCR04yOKUgZ4oAUkIRjmlVgckfrUbfMvGc5+tOwRnBzQA89aQ+g7UmcgkUbvoQaADtk0mf1p3HA9KaetACDjJNJz6/hTzz9BTSR0x160wBiR0pB144oA/Sm9c56CgCQE9Txjinds9aZ1GaUkHIFAD/wBKOQM00NngninZ7CkAdgfWlOO/5UHgU3nPFADgR9aUe1N56mgHigCTkGl3dKj+lOxjPNADhkZpDjrRx3HNKDx9KAGnvzzSkA89KOehpCQTigBoVcdKCM96CABj+tGe1AC7u1P6gg9TUIwG47mpOMcigBc4IwcE0nGPl5Jpo56ZyKU/MeOKAH54pvXhTQc4zRgfnQA360mOeacfrSY5NADe/HamY9ak9s0wj1pgJxmm5yMincZ4pOnSgQw4P0FJgU7tSEdBigBhwOn40046kdaewzznmmnpg0AN46A0EHPoO5pxUHp1NMHy9TQAuSAc9KQUmOeB7UituOfemA4kkcE/SlOeM005BpwwRQAnfofWlHGOOtNJ55ozjgUwHg/hS5zxTOc+tAPNAh/402l9RRx1oATkjnj0pDyOaecUwjkUwG/TnFMPpUnem8Z9qAG89v0o6Uvfbikx6mgB2SDuBpBzyeM96TofWg+g6UwJMqF+lRnA6UZP3j1NKPm+XGSaQCDnnFGDgYIxSjHT3p2OxpgJ19s0xsgZHrS888YFJn17UCFGCc9T2pgxk/5FPI6n9aMcAeh60AB600gdD2oX72M8UpI6en4UAMyRzmg9cg0H1FJnnA6CgBMHdxSn5uGo680mPm70wFyKTqKOORSYBP0oEOzuJFHQ0uF5OfxpOOv6UAGO9GMHnvSY9aCDTAAfb2p2AOtNyBR/OgBrKR0phFTE9sUzBxQBFQetPYEdKaeaYhpyRgfnSZyMd6cTzikwBwe9MBp6UD+VOOM01ueDQI//1pdhHB59KaSW5Heg527PfvzSYwTjPArIsDhSfTik3HbgEe4ozwWGR+tRjAxjAIGBQAwtuDA+vX9aYCCcAdOv/wBenqcZB7VEd3Y4A4x0PNMQ3cCSuOe/1prZ5z0HSnkLu3jjI9e9Rlc4AOMjgUwG5ZTk5B7j0FJ8w5PH+e1KSD8o6kYGeKaCcjJ56UxD8kH5T25J700e5JyeKfwDtXJJGTSDGDx0oAQj5cjsM07H7sCmZ3MD29KQHccheRQBKdqDaOMD69aAc4JAx2z2NRq7EZODzyPpSltwJ7nt9KAHln3KPrnsKjJ2jAGPX+VPyoGH70nyPgrzt7UARgYBQfLyf0qNjj755zk1LIuCWI4NNI3gAjjrQA0DJPGBTm+9k59qUMRlWxwe4qMnOWbvTAkHyjr+VL79CPU0wEZ5PU9aM5OT9aAJckggnOaUKR36VGCcdfapMsOCeM0ANXJHIyeowOlNJ2DknP8ASnMw2+vHbpUZJClj1Azz60ANJJXHX09fxpwAyCpBC8Z70zGfwOR6mlA6KpIPXkYpiFUAKXcgAml3l+emPzFR57FTn34Jp4B2+vGM/wD1qAHbScc8Y7Um/geo6+1NJByueSO1O6FlwNxGKAEwRn6/nSHdnjNLuJG4Djufek7g7uMcevFADW445OaeSQNvv2ppJ3YJ60g+bmgBSNrcU7JCkCmKVIySAfQU7IAAOaAEzjt14p5468UwNk+x6UpAK89aADjn1oJ4+tH3sbaafSmAZHak5wPr0pD0wKOMetAhe2FOM07g8j6UwDHSl4PNAx2ADmng8VGGxnAzigNu56dqAJcjvR16Gmj73rS5wOKQB170Z70h/Sl+lAByTT85wO9MHHB7Up6c0ASA5pcg9Kiz604kdR2oAcD7ZpKPf9KBj86AE6mhj2FGQTgUhzz6D0oAMDOSeKOc5/Gm545707IxmgBR9ATS5bgUztjqaPnXpQA/nv3pRyMGowSevFOP5UAHuKMZGT+tLxj603gnHpQADim8nmnZpOcelADTjFN6fSnk4pp6UxDcYGKQ+9KcY470nQ5oAQ8+nTrTeval4Jx6UHpQAw8celIRxz0p/Wm/Xg0ARe1OB+Y0HJpCCOaYCnBz65pCOeeaaSByAc+tBJAyeaAFPr2FOI9KYckDnvSjd9KAFGaAR0P+RSBuMUZHTrTAdnA5p2DUXv6U7OBz3oESZFNJGKBgUd8UAIeRmk7c0vOeKOfWmAwYBppHfNPIzxTQAOe3vQA3PcUmOhBp+B1prYPvTAAeMinDg9OtRkehpc8YoESEetGR+VRg856in5UH37UDEIPpzSEcAmnZyMg03HYdaBC5NITj8M9KTbjp37U4EZ2npigAzwf0pG6nPekBAGCeR0pcdc0AAOOB0pDjg4o6EjNLnjjvQA3APApmB3qQjuKaRjpQAwk+lJk4JxjNOJOMHrTRnoKYhcnGCcUAgcigE5pSe9AC47Y60Ec+1NJ3Gl4HP60AHXijpRjPOeKM8UwE780Hnk0cZozg/WgAPoOhphU496kGe9IAO9AiLaM0hzUmPWmkEdqYDDjPFJ9aeQehpOCOKYH/2Q==";

var skybox_south = "data:image/jpeg;base64,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";

class OML {
  constructor(container, OML) {
    this.skyboxSize = 100;
    this.container = container;
    this.renderer = new WebGLRenderer({ antialias: true });
    this.renderer.setSize(container.clientWidth, container.clientHeight);
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.vr.enabled = true;
    this.renderer.shadowMap.enabled = true;
    this.webvr = new WebVR(this.renderer, result => {
      if (result) {
        let webVRRequestAnimateResult = this.webvr.requestAnimationFrame(() => {
          this._animate.call(this, true);
        });
        if (!webVRRequestAnimateResult) {
          this.renderer.animate(() => {
            this._animate.call(this);
          });
        }
      } else {
        this.renderer.animate(() => {
          this._animate.call(this);
        });
      }
    });
    container.appendChild(this.renderer.domElement);
    container.style.overflow = 'hidden';
    this.scene = new Scene();
    this.camera = new PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
    this.camera.position.set(0, 1.7, 1);
    this.scene.add(this.camera);
    this.light = new DirectionalLight(0xffffff, 0.7);
    this.scene.add(this.light);
    this.ambientLight = new AmbientLight(0xffffff, 0.3);
    this.scene.add(this.ambientLight);
    this._setLight([60, 30, 0]);
    const cubeLoader = new CubeTextureLoader();
    cubeLoader.load([skybox_east, skybox_west, skybox_up, skybox_down, skybox_north, skybox_south], cubeTexture => {
      const cubeShader = ShaderLib['cube'];
      cubeShader.uniforms['tCube'].value = cubeTexture;
      cubeShader.uniforms['tFlip'].value = 1;
      const skyBoxMaterial = new ShaderMaterial({
        fragmentShader: cubeShader.fragmentShader,
        vertexShader: cubeShader.vertexShader,
        uniforms: cubeShader.uniforms,
        depthWrite: false,
        side: BackSide
      });
      const skyMesh = new Mesh(new BoxGeometry(this.skyboxSize, this.skyboxSize, this.skyboxSize, 1, 1, 1), skyBoxMaterial);
      this.scene.add(skyMesh);
    });
    window.addEventListener('resize', () => {
      this.onResize.call(this);
    }, false);
    this.parser = new OMLParser(this.scene);
    if (OML) {
      this.setOML(OML);
    }
  }
  onResize() {
    this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
  }
  enterVR() {
    this.webvr.enterVR();
  }
  setOML(OML) {
    this.parser.setOML(OML);
  }
  _setLight(params) {
    const lightVector = new Vector3(0, 0, 1);
    if (params.length == 3) {
      const eu = new Euler(-Math.PI * params[0] / 180, -Math.PI * params[1] / 180, Math.PI * params[2] / 180, 'XYZ');
      lightVector.applyEuler(eu);
    }
    if (params.length == 4) {
      const qt = new Quaternion(params[0], params[1], -params[2], Math.PI * params[3] / 180);
      lightVector.applyQuaternion(qt);
    }
    this.light.position.set(lightVector.x, lightVector.y, lightVector.z);
    this.ambientLight.position.set(lightVector.x, lightVector.y, lightVector.z);
  }
  _animate(callRequestAnimationFrame) {
    this.renderer.render(this.scene, this.camera);
    if (callRequestAnimationFrame) this.webvr.requestAnimationFrame(() => {
      this._animate.call(this, true);
    });
  }
}

return OML;

})));
